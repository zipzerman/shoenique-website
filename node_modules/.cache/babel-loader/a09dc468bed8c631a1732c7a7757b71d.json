{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc'; // A RegExp matching ISO 8601 UTC timestamps with optional fraction.\n\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\nvar Timestamp =\n/** @class */\nfunction () {\n  function Timestamp(seconds, nanos) {\n    this.seconds = seconds;\n    this.nanos = nanos;\n    assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n    assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos); // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n\n    assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds); // This will break in the year 10,000.\n\n    assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n  }\n\n  Timestamp.now = function () {\n    return Timestamp.fromEpochMilliseconds(Date.now());\n  };\n\n  Timestamp.fromDate = function (date) {\n    return Timestamp.fromEpochMilliseconds(date.getTime());\n  };\n\n  Timestamp.fromEpochMilliseconds = function (milliseconds) {\n    var seconds = Math.floor(milliseconds / 1000);\n    var nanos = (milliseconds - seconds * 1000) * 1e6;\n    return new Timestamp(seconds, nanos);\n  };\n\n  Timestamp.fromISOString = function (utc) {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n    // Parse the nanos right out of the string.\n    var nanos = 0;\n    var fraction = isoRegExp.exec(utc);\n    assert(!!fraction, 'invalid timestamp: ' + utc);\n\n    if (fraction[1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      var nanoStr = fraction[1];\n      nanoStr = (nanoStr + '000000000').substr(0, 9);\n      nanos = parseInt(nanoStr, 10);\n    } // Parse the date to get the seconds.\n\n\n    var date = new Date(utc);\n    var seconds = Math.floor(date.getTime() / 1000);\n    return new Timestamp(seconds, nanos);\n  };\n\n  Timestamp.prototype.toDate = function () {\n    return new Date(this.toEpochMilliseconds());\n  };\n\n  Timestamp.prototype.toEpochMilliseconds = function () {\n    return this.seconds * 1000 + this.nanos / 1e6;\n  };\n\n  Timestamp.prototype.compareTo = function (other) {\n    if (this.seconds === other.seconds) {\n      return primitiveComparator(this.nanos, other.nanos);\n    }\n\n    return primitiveComparator(this.seconds, other.seconds);\n  };\n\n  Timestamp.prototype.equals = function (other) {\n    return other.seconds === this.seconds && other.nanos === this.nanos;\n  };\n\n  Timestamp.prototype.toString = function () {\n    return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n  };\n\n  return Timestamp;\n}();\n\nexport { Timestamp };","map":{"version":3,"sources":["../src/core/timestamp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\n\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\nexport class Timestamp {\n  static now(): Timestamp {\n    return Timestamp.fromEpochMilliseconds(Date.now());\n  }\n\n  static fromDate(date: Date): Timestamp {\n    return Timestamp.fromEpochMilliseconds(date.getTime());\n  }\n\n  static fromEpochMilliseconds(milliseconds: number): Timestamp {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = (milliseconds - seconds * 1000) * 1e6;\n    return new Timestamp(seconds, nanos);\n  }\n\n  static fromISOString(utc: string): Timestamp {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n\n    // Parse the nanos right out of the string.\n    let nanos = 0;\n    const fraction = isoRegExp.exec(utc);\n    assert(!!fraction, 'invalid timestamp: ' + utc);\n    if (fraction![1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      let nanoStr = fraction![1];\n      nanoStr = (nanoStr + '000000000').substr(0, 9);\n      nanos = parseInt(nanoStr, 10);\n    }\n\n    // Parse the date to get the seconds.\n    const date = new Date(utc);\n    const seconds = Math.floor(date.getTime() / 1000);\n\n    return new Timestamp(seconds, nanos);\n  }\n\n  constructor(readonly seconds: number, readonly nanos: number) {\n    assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n    assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n    // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n    assert(\n      seconds >= -62135596800,\n      'timestamp seconds out of range: ' + seconds\n    );\n    // This will break in the year 10,000.\n    assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n  }\n\n  toDate(): Date {\n    return new Date(this.toEpochMilliseconds());\n  }\n\n  toEpochMilliseconds(): number {\n    return this.seconds * 1000 + this.nanos / 1e6;\n  }\n\n  compareTo(other: Timestamp): number {\n    if (this.seconds === other.seconds) {\n      return primitiveComparator(this.nanos, other.nanos);\n    }\n    return primitiveComparator(this.seconds, other.seconds);\n  }\n\n  equals(other: Timestamp): boolean {\n    return other.seconds === this.seconds && other.nanos === this.nanos;\n  }\n\n  toString(): string {\n    return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}