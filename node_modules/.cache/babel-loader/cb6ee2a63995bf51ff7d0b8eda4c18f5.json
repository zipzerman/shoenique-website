{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { Deferred } from './promise';\nimport { Code, FirestoreError } from './error';\n\nvar AsyncQueue =\n/** @class */\nfunction () {\n  function AsyncQueue() {\n    // The last promise in the queue.\n    this.tail = Promise.resolve(); // A list with timeout handles and their respective deferred promises.\n    // Contains an entry for each operation that is queued to run in the future\n    // (i.e. it has a delay that has not yet elapsed). Prior to cleanup, this list\n    // may also contain entries that have already been run (in which case `handle` is\n    // null).\n\n    this.delayedOperations = []; // The number of operations that are queued to be run in the future (i.e. they\n    // have a delay that has not yet elapsed). Unlike `delayedOperations`, this\n    // is guaranteed to only contain operations that have not yet been run.\n    //\n    // Visible for testing.\n\n    this.delayedOperationsCount = 0; // Flag set while there's an outstanding AsyncQueue operation, used for\n    // assertion sanity-checks.\n\n    this.operationInProgress = false;\n  }\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   *\n   * Can optionally specify a delay (in milliseconds) to wait before queuing the\n   * operation.\n   */\n\n\n  AsyncQueue.prototype.schedule = function (op, delay) {\n    var _this = this;\n\n    if (this.failure) {\n      fail('AsyncQueue is already failed: ' + (this.failure.stack || this.failure.message));\n    }\n\n    if ((delay || 0) > 0) {\n      this.delayedOperationsCount++;\n      var delayedOp_1 = {\n        handle: null,\n        op: op,\n        deferred: new Deferred()\n      };\n      delayedOp_1.handle = setTimeout(function () {\n        _this.scheduleInternal(function () {\n          return delayedOp_1.op().then(function (result) {\n            delayedOp_1.deferred.resolve(result);\n          });\n        });\n\n        delayedOp_1.handle = null;\n        _this.delayedOperationsCount--;\n\n        if (_this.delayedOperationsCount === 0) {\n          _this.delayedOperations = [];\n        }\n      }, delay);\n      this.delayedOperations.push(delayedOp_1);\n      return delayedOp_1.deferred.promise;\n    } else {\n      return this.scheduleInternal(op);\n    }\n  };\n\n  AsyncQueue.prototype.scheduleInternal = function (op) {\n    var _this = this;\n\n    this.tail = this.tail.then(function () {\n      _this.operationInProgress = true;\n      return op().catch(function (error) {\n        _this.failure = error;\n        _this.operationInProgress = false;\n        var message = error.stack || error.message || '';\n        log.error('INTERNAL UNHANDLED ERROR: ', message); // Escape the promise chain and throw the error globally so that\n        // e.g. any global crash reporting library detects and reports it.\n        // (but not for simulated errors in our tests since this breaks mocha)\n\n        if (message.indexOf('Firestore Test Simulated Error') < 0) {\n          setTimeout(function () {\n            throw error;\n          }, 0);\n        } // Re-throw the error so that this.tail becomes a rejected Promise and\n        // all further attempts to chain (via .then) will just short-circuit\n        // and return the rejected Promise.\n\n\n        throw error;\n      }).then(function () {\n        _this.operationInProgress = false;\n      });\n    });\n    return this.tail;\n  };\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n\n\n  AsyncQueue.prototype.verifyOperationInProgress = function () {\n    assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n  };\n  /**\n   * Waits until all currently scheduled tasks are finished executing. Tasks\n   * scheduled with a delay can be rejected or queued for immediate execution.\n   */\n\n\n  AsyncQueue.prototype.drain = function (executeDelayedTasks) {\n    var _this = this;\n\n    this.delayedOperations.forEach(function (entry) {\n      if (entry.handle) {\n        clearTimeout(entry.handle);\n\n        if (executeDelayedTasks) {\n          _this.scheduleInternal(entry.op).then(entry.deferred.resolve, entry.deferred.reject);\n        } else {\n          entry.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled by shutdown'));\n        }\n      }\n    });\n    this.delayedOperations = [];\n    this.delayedOperationsCount = 0;\n    return this.schedule(function () {\n      return Promise.resolve();\n    });\n  };\n\n  return AsyncQueue;\n}();\n\nexport { AsyncQueue };","map":{"version":3,"sources":["../src/util/async_queue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { AnyDuringMigration, AnyJs } from './misc';\nimport { Deferred } from './promise';\nimport { Code, FirestoreError } from './error';\n\ntype DelayedOperation<T> = {\n  // tslint:disable-next-line:no-any Accept any return type from setTimeout().\n  handle: any;\n  op: () => Promise<T>;\n  deferred: Deferred<T>;\n};\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<AnyJs | void> = Promise.resolve();\n\n  // A list with timeout handles and their respective deferred promises.\n  // Contains an entry for each operation that is queued to run in the future\n  // (i.e. it has a delay that has not yet elapsed). Prior to cleanup, this list\n  // may also contain entries that have already been run (in which case `handle` is\n  // null).\n  private delayedOperations: DelayedOperation<AnyJs>[] = [];\n\n  // The number of operations that are queued to be run in the future (i.e. they\n  // have a delay that has not yet elapsed). Unlike `delayedOperations`, this\n  // is guaranteed to only contain operations that have not yet been run.\n  //\n  // Visible for testing.\n  delayedOperationsCount = 0;\n\n  // visible for testing\n  failure: Error;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   *\n   * Can optionally specify a delay (in milliseconds) to wait before queuing the\n   * operation.\n   */\n  schedule<T>(op: () => Promise<T>, delay?: number): Promise<T> {\n    if (this.failure) {\n      fail(\n        'AsyncQueue is already failed: ' +\n          (this.failure.stack || this.failure.message)\n      );\n    }\n\n    if ((delay || 0) > 0) {\n      this.delayedOperationsCount++;\n      const delayedOp: DelayedOperation<T> = {\n        handle: null,\n        op: op,\n        deferred: new Deferred<T>()\n      };\n      delayedOp.handle = setTimeout(() => {\n        this.scheduleInternal(() => {\n          return delayedOp.op().then(result => {\n            delayedOp.deferred.resolve(result);\n          });\n        });\n        delayedOp.handle = null;\n\n        this.delayedOperationsCount--;\n        if (this.delayedOperationsCount === 0) {\n          this.delayedOperations = [];\n        }\n      }, delay);\n      this.delayedOperations.push(delayedOp);\n      return delayedOp.deferred.promise;\n    } else {\n      return this.scheduleInternal(op);\n    }\n  }\n\n  private scheduleInternal<T>(op: () => Promise<T>): Promise<T> {\n    this.tail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch(error => {\n          this.failure = error;\n          this.operationInProgress = false;\n          const message = error.stack || error.message || '';\n          log.error('INTERNAL UNHANDLED ERROR: ', message);\n\n          // Escape the promise chain and throw the error globally so that\n          // e.g. any global crash reporting library detects and reports it.\n          // (but not for simulated errors in our tests since this breaks mocha)\n          if (message.indexOf('Firestore Test Simulated Error') < 0) {\n            setTimeout(() => {\n              throw error;\n            }, 0);\n          }\n\n          // Re-throw the error so that this.tail becomes a rejected Promise and\n          // all further attempts to chain (via .then) will just short-circuit\n          // and return the rejected Promise.\n          throw error;\n        })\n        .then(() => {\n          this.operationInProgress = false;\n        });\n    });\n    return this.tail as AnyDuringMigration;\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    assert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  /**\n   * Waits until all currently scheduled tasks are finished executing. Tasks\n   * scheduled with a delay can be rejected or queued for immediate execution.\n   */\n  drain(executeDelayedTasks: boolean): Promise<void> {\n    this.delayedOperations.forEach(entry => {\n      if (entry.handle) {\n        clearTimeout(entry.handle);\n        if (executeDelayedTasks) {\n          this.scheduleInternal(entry.op).then(\n            entry.deferred.resolve,\n            entry.deferred.reject\n          );\n        } else {\n          entry.deferred.reject(\n            new FirestoreError(\n              Code.CANCELLED,\n              'Operation cancelled by shutdown'\n            )\n          );\n        }\n      }\n    });\n    this.delayedOperations = [];\n    this.delayedOperationsCount = 0;\n    return this.schedule(() => Promise.resolve());\n  }\n}\n"]},"metadata":{},"sourceType":"module"}