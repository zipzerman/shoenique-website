{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorCode, EventType, WebChannel, XhrIoPool, createWebChannelTransport } from '@firebase/webchannel-wrapper';\nimport { SDK_VERSION } from '../core/version';\nimport { mapCodeFromHttpStatus, mapCodeFromRpcStatus } from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nvar LOG_TAG = 'Connection';\nvar RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';\nvar RPC_URL_VERSION = 'v1beta1';\n/** Maps RPC names to the corresponding REST endpoint name. */\n\nvar RPC_NAME_REST_MAPPING = {\n  BatchGetDocuments: 'batchGet',\n  Commit: 'commit'\n}; // TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\n\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\n\nvar WebChannelConnection =\n/** @class */\nfunction () {\n  function WebChannelConnection(info) {\n    this.databaseId = info.databaseId;\n    this.pool = new XhrIoPool();\n    var proto = info.ssl ? 'https' : 'http';\n    this.baseUrl = proto + '://' + info.host;\n  }\n  /**\n   * Modifies the headers for a request, adding any authorization token if\n   * present and any additional headers for the request.\n   */\n\n\n  WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n    if (token) {\n      for (var header in token.authHeaders) {\n        if (token.authHeaders.hasOwnProperty(header)) {\n          headers[header] = token.authHeaders[header];\n        }\n      }\n    }\n\n    headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE; // This header is used to improve routing and project isolation by the\n    // backend.\n\n    headers['google-cloud-resource-prefix'] = \"projects/\" + this.databaseId.projectId + \"/\" + (\"databases/\" + this.databaseId.database);\n  };\n\n  WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {\n    var _this = this;\n\n    var url = this.makeUrl(rpcName);\n    return new Promise(function (resolve, reject) {\n      _this.pool.getObject(function (xhr) {\n        xhr.listenOnce(EventType.COMPLETE, function () {\n          try {\n            switch (xhr.getLastErrorCode()) {\n              case ErrorCode.NO_ERROR:\n                var json = xhr.getResponseJson();\n                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                resolve(json);\n                break;\n\n              case ErrorCode.TIMEOUT:\n                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" timed out');\n                reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));\n                break;\n\n              case ErrorCode.HTTP_ERROR:\n                var status_1 = xhr.getStatus();\n                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n\n                if (status_1 > 0) {\n                  reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                } else {\n                  // If we received an HTTP_ERROR but there's no status code,\n                  // it's most probably a connection issue\n                  log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed');\n                  reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));\n                }\n\n                break;\n\n              default:\n                fail('RPC \"' + rpcName + '\" failed with unanticipated ' + 'webchannel error ' + xhr.getLastErrorCode() + ': ' + xhr.getLastError() + ', giving up.');\n            }\n          } finally {\n            log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n\n            _this.pool.releaseObject(xhr);\n          }\n        });\n        var requestString = JSON.stringify(request);\n        log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString); // Content-Type: text/plain will avoid preflight requests which might\n        // mess with CORS and redirects by proxies. If we add custom headers\n        // we will need to change this code to potentially use the\n        // $httpOverwrite parameter supported by ESF to avoid\n        // triggering preflight requests.\n\n        var headers = {\n          'Content-Type': 'text/plain'\n        };\n\n        _this.modifyHeadersForRequest(headers, token);\n\n        xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n      });\n    });\n  };\n\n  WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {\n    // The REST API automatically aggregates all of the streamed results, so we\n    // can just use the normal invoke() method.\n    return this.invokeRPC(rpcName, request, token);\n  };\n\n  WebChannelConnection.prototype.openStream = function (rpcName, token) {\n    var urlParts = [this.baseUrl, '/', RPC_STREAM_SERVICE, '/', rpcName, '/channel'];\n    var webchannelTransport = createWebChannelTransport();\n    var request = {\n      // Background channel test avoids the initial two test calls and decreases\n      // initial cold start time.\n      // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n      // we should monitor closely for any reports.\n      backgroundChannelTest: true,\n      // Required for backend stickiness, routing behavior is based on this\n      // parameter.\n      httpSessionIdParam: 'gsessionid',\n      initMessageHeaders: {},\n      // Send our custom headers as a '$httpHeaders=' url param to avoid CORS\n      // preflight round-trip. This is formally defined here:\n      // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40\n      httpHeadersOverwriteParam: '$httpHeaders',\n      sendRawJson: true,\n      supportsCrossDomainXhr: true\n    };\n    this.modifyHeadersForRequest(request.initMessageHeaders, token);\n    var url = urlParts.join('');\n    log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request); // tslint:disable-next-line:no-any Because listen isn't defined on it.\n\n    var channel = webchannelTransport.createWebChannel(url, request); // WebChannel supports sending the first message with the handshake - saving\n    // a network round trip. However, it will have to call send in the same\n    // JS event loop as open. In order to enforce this, we delay actually\n    // opening the WebChannel until send is called. Whether we have called\n    // open is tracked with this variable.\n\n    var opened = false; // A flag to determine whether the stream was closed (by us or through an\n    // error/close event) to avoid delivering multiple close events or sending\n    // on a closed stream\n\n    var closed = false; // tslint:disable-next-line:no-any\n\n    var streamBridge = new StreamBridge({\n      sendFn: function sendFn(msg) {\n        if (!closed) {\n          if (!opened) {\n            log.debug(LOG_TAG, 'Opening WebChannel transport.');\n            channel.open();\n            opened = true;\n          }\n\n          log.debug(LOG_TAG, 'WebChannel sending:', msg);\n          channel.send(msg);\n        } else {\n          log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n        }\n      },\n      closeFn: function closeFn() {\n        return channel.close();\n      }\n    }); // Closure events are guarded and exceptions are swallowed, so catch any\n    // exception and rethrow using a setTimeout so they become visible again.\n    // Note that eventually this function could go away if we are confident\n    // enough the code is exception free.\n\n    var unguardedEventListen = function unguardedEventListen(type, fn) {\n      // TODO(dimond): closure typing seems broken because WebChannel does\n      // not implement goog.events.Listenable\n      channel.listen(type, function (param) {\n        try {\n          fn(param);\n        } catch (e) {\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      });\n    };\n\n    unguardedEventListen(WebChannel.EventType.OPEN, function () {\n      if (!closed) {\n        log.debug(LOG_TAG, 'WebChannel transport opened.');\n      }\n    });\n    unguardedEventListen(WebChannel.EventType.CLOSE, function () {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport closed');\n        streamBridge.callOnClose();\n      }\n    });\n    unguardedEventListen(WebChannel.EventType.ERROR, function (err) {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n        streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));\n      }\n    });\n    unguardedEventListen(WebChannel.EventType.MESSAGE, function (msg) {\n      if (!closed) {\n        // WebChannel delivers message events as array. If batching\n        // is not enabled (it's off by default) each message will be\n        // delivered alone, resulting in a single element array.\n        var msgData = msg.data[0];\n        assert(!!msgData, 'Got a webchannel message without data.'); // TODO(b/35143891): There is a bug in One Platform that caused errors\n        // (and only errors) to be wrapped in an extra array. To be forward\n        // compatible with the bug we need to check either condition. The latter\n        // can be removed once the fix has been rolled out.\n\n        var error = msgData.error || msgData[0] && msgData[0].error;\n\n        if (error) {\n          log.debug(LOG_TAG, 'WebChannel received error:', error); // error.status will be a string like 'OK' or 'NOT_FOUND'.\n\n          var status_2 = error.status;\n          var code = mapCodeFromRpcStatus(status_2);\n          var message = error.message;\n\n          if (code === undefined) {\n            code = Code.INTERNAL;\n            message = 'Unknown error status: ' + status_2 + ' with message ' + error.message;\n          } // Mark closed so no further events are propagated\n\n\n          closed = true;\n          streamBridge.callOnClose(new FirestoreError(code, message));\n          channel.close();\n        } else {\n          log.debug(LOG_TAG, 'WebChannel received:', msgData);\n          streamBridge.callOnMessage(msgData);\n        }\n      }\n    });\n    setTimeout(function () {\n      // Technically we could/should wait for the WebChannel opened event,\n      // but because we want to send the first message with the WebChannel\n      // handshake we pretend the channel opened here (asynchronously), and\n      // then delay the actual open until the first message is sent.\n      streamBridge.callOnOpen();\n    }, 0);\n    return streamBridge;\n  }; // visible for testing\n\n\n  WebChannelConnection.prototype.makeUrl = function (rpcName) {\n    var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];\n    assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);\n    var url = [this.baseUrl, '/', RPC_URL_VERSION];\n    url.push('/projects/');\n    url.push(this.databaseId.projectId);\n    url.push('/databases/');\n    url.push(this.databaseId.database);\n    url.push('/documents');\n    url.push(':');\n    url.push(urlRpcName);\n    return url.join('');\n  };\n\n  return WebChannelConnection;\n}();\n\nexport { WebChannelConnection };","map":{"version":3,"sources":["../src/platform_browser/webchannel_connection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  EventType,\n  WebChannel,\n  XhrIoPool,\n  createWebChannelTransport\n} from '@firebase/webchannel-wrapper';\n\nimport { Token } from '../api/credentials';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { SDK_VERSION } from '../core/version';\nimport { Connection, Stream } from '../remote/connection';\nimport {\n  mapCodeFromHttpStatus,\n  mapCodeFromRpcStatus\n} from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { Rejecter, Resolver } from '../util/promise';\n\nconst LOG_TAG = 'Connection';\n\nconst RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';\nconst RPC_URL_VERSION = 'v1beta1';\n\n/** Maps RPC names to the corresponding REST endpoint name. */\nconst RPC_NAME_REST_MAPPING = {\n  BatchGetDocuments: 'batchGet',\n  Commit: 'commit'\n};\n\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nconst X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\n\nconst XHR_TIMEOUT_SECS = 15;\n\nexport class WebChannelConnection implements Connection {\n  private readonly databaseId: DatabaseId;\n  private readonly baseUrl: string;\n  private readonly pool: XhrIoPool;\n\n  constructor(info: DatabaseInfo) {\n    this.databaseId = info.databaseId;\n    this.pool = new XhrIoPool();\n    const proto = info.ssl ? 'https' : 'http';\n    this.baseUrl = proto + '://' + info.host;\n  }\n\n  /**\n   * Modifies the headers for a request, adding any authorization token if\n   * present and any additional headers for the request.\n   */\n  private modifyHeadersForRequest(\n    headers: { [key: string]: string },\n    token: Token | null\n  ) {\n    if (token) {\n      for (const header in token.authHeaders) {\n        if (token.authHeaders.hasOwnProperty(header)) {\n          headers[header] = token.authHeaders[header];\n        }\n      }\n    }\n    headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n    // This header is used to improve routing and project isolation by the\n    // backend.\n    headers['google-cloud-resource-prefix'] =\n      `projects/${this.databaseId.projectId}/` +\n      `databases/${this.databaseId.database}`;\n  }\n\n  invokeRPC(rpcName: string, request: any, token: Token | null): Promise<any> {\n    const url = this.makeUrl(rpcName);\n\n    return new Promise((resolve: Resolver<any>, reject: Rejecter) => {\n      this.pool.getObject((xhr: any) => {\n        xhr.listenOnce(EventType.COMPLETE, () => {\n          try {\n            switch (xhr.getLastErrorCode()) {\n              case ErrorCode.NO_ERROR:\n                const json = xhr.getResponseJson();\n                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                resolve(json);\n                break;\n              case ErrorCode.TIMEOUT:\n                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" timed out');\n                reject(\n                  new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out')\n                );\n                break;\n              case ErrorCode.HTTP_ERROR:\n                const status = xhr.getStatus();\n                log.debug(\n                  LOG_TAG,\n                  'RPC \"' + rpcName + '\" failed with status:',\n                  status,\n                  'response text:',\n                  xhr.getResponseText()\n                );\n                if (status > 0) {\n                  reject(\n                    new FirestoreError(\n                      mapCodeFromHttpStatus(status),\n                      'Server responded with status ' + xhr.getStatusText()\n                    )\n                  );\n                } else {\n                  // If we received an HTTP_ERROR but there's no status code,\n                  // it's most probably a connection issue\n                  log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed');\n                  reject(\n                    new FirestoreError(Code.UNAVAILABLE, 'Connection failed.')\n                  );\n                }\n                break;\n              default:\n                fail(\n                  'RPC \"' +\n                    rpcName +\n                    '\" failed with unanticipated ' +\n                    'webchannel error ' +\n                    xhr.getLastErrorCode() +\n                    ': ' +\n                    xhr.getLastError() +\n                    ', giving up.'\n                );\n            }\n          } finally {\n            log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n            this.pool.releaseObject(xhr);\n          }\n        });\n\n        const requestString = JSON.stringify(request);\n        log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n        // Content-Type: text/plain will avoid preflight requests which might\n        // mess with CORS and redirects by proxies. If we add custom headers\n        // we will need to change this code to potentially use the\n        // $httpOverwrite parameter supported by ESF to avoid\n        // triggering preflight requests.\n        const headers: any = { 'Content-Type': 'text/plain' };\n\n        this.modifyHeadersForRequest(headers, token);\n\n        xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n      });\n    });\n  }\n\n  invokeStreamingRPC(\n    rpcName: string,\n    request: any,\n    token: Token | null\n  ): Promise<any[]> {\n    // The REST API automatically aggregates all of the streamed results, so we\n    // can just use the normal invoke() method.\n    return this.invokeRPC(rpcName, request, token);\n  }\n\n  openStream(rpcName: string, token: Token | null): Stream<any, any> {\n    const urlParts = [\n      this.baseUrl,\n      '/',\n      RPC_STREAM_SERVICE,\n      '/',\n      rpcName,\n      '/channel'\n    ];\n    const webchannelTransport = createWebChannelTransport();\n    const request = {\n      // Background channel test avoids the initial two test calls and decreases\n      // initial cold start time.\n      // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n      // we should monitor closely for any reports.\n      backgroundChannelTest: true,\n      // Required for backend stickiness, routing behavior is based on this\n      // parameter.\n      httpSessionIdParam: 'gsessionid',\n      initMessageHeaders: {},\n      // Send our custom headers as a '$httpHeaders=' url param to avoid CORS\n      // preflight round-trip. This is formally defined here:\n      // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40\n      httpHeadersOverwriteParam: '$httpHeaders',\n      sendRawJson: true,\n      supportsCrossDomainXhr: true\n    };\n    this.modifyHeadersForRequest(request.initMessageHeaders, token);\n    const url = urlParts.join('');\n    log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n    // tslint:disable-next-line:no-any Because listen isn't defined on it.\n    const channel = webchannelTransport.createWebChannel(url, request) as any;\n\n    // WebChannel supports sending the first message with the handshake - saving\n    // a network round trip. However, it will have to call send in the same\n    // JS event loop as open. In order to enforce this, we delay actually\n    // opening the WebChannel until send is called. Whether we have called\n    // open is tracked with this variable.\n    let opened = false;\n\n    // A flag to determine whether the stream was closed (by us or through an\n    // error/close event) to avoid delivering multiple close events or sending\n    // on a closed stream\n    let closed = false;\n\n    // tslint:disable-next-line:no-any\n    const streamBridge = new StreamBridge<any, any>({\n      sendFn: (msg: any) => {\n        if (!closed) {\n          if (!opened) {\n            log.debug(LOG_TAG, 'Opening WebChannel transport.');\n            channel.open();\n            opened = true;\n          }\n          log.debug(LOG_TAG, 'WebChannel sending:', msg);\n          channel.send(msg);\n        } else {\n          log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n        }\n      },\n      closeFn: () => channel.close()\n    });\n\n    // Closure events are guarded and exceptions are swallowed, so catch any\n    // exception and rethrow using a setTimeout so they become visible again.\n    // Note that eventually this function could go away if we are confident\n    // enough the code is exception free.\n    const unguardedEventListen = (\n      type: WebChannel.EventType,\n      fn: (param: any) => void\n    ) => {\n      // TODO(dimond): closure typing seems broken because WebChannel does\n      // not implement goog.events.Listenable\n      channel.listen(type, (param: any) => {\n        try {\n          fn(param);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          }, 0);\n        }\n      });\n    };\n\n    unguardedEventListen(WebChannel.EventType.OPEN, () => {\n      if (!closed) {\n        log.debug(LOG_TAG, 'WebChannel transport opened.');\n      }\n    });\n\n    unguardedEventListen(WebChannel.EventType.CLOSE, () => {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport closed');\n        streamBridge.callOnClose();\n      }\n    });\n\n    unguardedEventListen(WebChannel.EventType.ERROR, (err: any) => {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n        streamBridge.callOnClose(\n          new FirestoreError(\n            Code.UNAVAILABLE,\n            'The operation could not be completed'\n          )\n        );\n      }\n    });\n\n    unguardedEventListen(WebChannel.EventType.MESSAGE, (msg: any) => {\n      if (!closed) {\n        // WebChannel delivers message events as array. If batching\n        // is not enabled (it's off by default) each message will be\n        // delivered alone, resulting in a single element array.\n        const msgData = msg.data[0];\n        assert(!!msgData, 'Got a webchannel message without data.');\n        // TODO(b/35143891): There is a bug in One Platform that caused errors\n        // (and only errors) to be wrapped in an extra array. To be forward\n        // compatible with the bug we need to check either condition. The latter\n        // can be removed once the fix has been rolled out.\n        const error = msgData.error || (msgData[0] && msgData[0].error);\n        if (error) {\n          log.debug(LOG_TAG, 'WebChannel received error:', error);\n          // error.status will be a string like 'OK' or 'NOT_FOUND'.\n          const status: string = error.status;\n          let code = mapCodeFromRpcStatus(status);\n          let message = error.message;\n          if (code === undefined) {\n            code = Code.INTERNAL;\n            message =\n              'Unknown error status: ' +\n              status +\n              ' with message ' +\n              error.message;\n          }\n          // Mark closed so no further events are propagated\n          closed = true;\n          streamBridge.callOnClose(new FirestoreError(code, message));\n          channel.close();\n        } else {\n          log.debug(LOG_TAG, 'WebChannel received:', msgData);\n          streamBridge.callOnMessage(msgData);\n        }\n      }\n    });\n\n    setTimeout(() => {\n      // Technically we could/should wait for the WebChannel opened event,\n      // but because we want to send the first message with the WebChannel\n      // handshake we pretend the channel opened here (asynchronously), and\n      // then delay the actual open until the first message is sent.\n      streamBridge.callOnOpen();\n    }, 0);\n    return streamBridge;\n  }\n\n  // visible for testing\n  makeUrl(rpcName: string): string {\n    const urlRpcName = RPC_NAME_REST_MAPPING[rpcName];\n    assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);\n    const url = [this.baseUrl, '/', RPC_URL_VERSION];\n    url.push('/projects/');\n    url.push(this.databaseId.projectId);\n\n    url.push('/databases/');\n    url.push(this.databaseId.database);\n    url.push('/documents');\n\n    url.push(':');\n    url.push(urlRpcName);\n    return url.join('');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}