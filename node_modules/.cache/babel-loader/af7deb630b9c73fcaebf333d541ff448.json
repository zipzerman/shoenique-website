{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { PersistencePromise } from './persistence_promise';\nvar LOG_TAG = 'SimpleDb';\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\n\nvar SimpleDb =\n/** @class */\nfunction () {\n  function SimpleDb(db) {\n    this.db = db;\n  }\n  /** Opens the specified database, creating or upgrading it if necessary. */\n\n\n  SimpleDb.openOrCreate = function (name, version, runUpgrade) {\n    assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');\n    debug(LOG_TAG, 'Opening database:', name);\n    return new PersistencePromise(function (resolve, reject) {\n      // TODO(mikelehen): Investigate browser compatibility.\n      // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n      // suggests IE9 and older WebKit browsers handle upgrade\n      // differently.\n      var request = window.indexedDB.open(name, version);\n\n      request.onsuccess = function (event) {\n        var db = event.target.result;\n        resolve(new SimpleDb(db));\n      };\n\n      request.onerror = function (event) {\n        reject(event.target.error);\n      };\n\n      request.onupgradeneeded = function (event) {\n        debug(LOG_TAG, 'Database \"' + name + '\" requires upgrade from version:', event.oldVersion); // TODO(mikelehen): If/when we need to do an actual data\n        // migration, we'll want to wrap db in a SimpleDb and have the\n        // runUpgrade function return a PersistencePromise, since we'll\n        // likely need to do async reads and writes. For now we're\n        // cheating and just passing the raw IndexedDB in, since\n        // createObjectStore(), etc. are synchronous.\n\n        var db = event.target.result;\n        runUpgrade(db, event.oldVersion);\n      };\n    }).toPromise();\n  };\n  /** Deletes the specified database. */\n\n\n  SimpleDb.delete = function (name) {\n    debug(LOG_TAG, 'Removing database:', name);\n    return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n  };\n  /** Returns true if IndexedDB is available in the current environment. */\n\n\n  SimpleDb.isAvailable = function () {\n    if (typeof window === 'undefined' || window.indexedDB == null) {\n      return false;\n    } // We extensively use indexed array values and compound keys,\n    // which IE and Edge do not support. However, they still have indexedDB\n    // defined on the window, so we need to check for them here and make sure\n    // to return that persistence is not enabled for those browsers.\n    // For tracking support of this feature, see here:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n    // Check the UA string to find out the browser.\n\n\n    var ua = window.navigator.userAgent; // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n    // Edge\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n    // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n\n    if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {\n    var transaction = new SimpleDbTransaction(this.db, mode, objectStores);\n    var transactionFnResult = transactionFn(transaction).catch(function (error) {\n      // Abort the transaction if there was an\n      // error.\n      transaction.abort();\n      return PersistencePromise.reject(error);\n    }).toPromise(); // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n    // fire), but still return the original transactionFnResult back to the\n    // caller.\n\n    return transaction.completionPromise.then(function () {\n      return transactionFnResult;\n    });\n  };\n\n  SimpleDb.prototype.close = function () {\n    this.db.close();\n  };\n\n  return SimpleDb;\n}();\n\nexport { SimpleDb };\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\n\nvar IterationController =\n/** @class */\nfunction () {\n  function IterationController(dbCursor) {\n    this.dbCursor = dbCursor;\n    this.shouldStop = false;\n    this.nextKey = null;\n  }\n\n  Object.defineProperty(IterationController.prototype, \"isDone\", {\n    get: function get() {\n      return this.shouldStop;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IterationController.prototype, \"skipToKey\", {\n    get: function get() {\n      return this.nextKey;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IterationController.prototype, \"cursor\", {\n    set: function set(value) {\n      this.dbCursor = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * This function can be called to stop iteration at any point.\n   */\n\n  IterationController.prototype.done = function () {\n    this.shouldStop = true;\n  };\n  /**\n   * This function can be called to skip to that next key, which could be\n   * an index or a primary key.\n   */\n\n\n  IterationController.prototype.skip = function (key) {\n    this.nextKey = key;\n  };\n  /**\n   * Delete the current cursor value from the object store.\n   *\n   * NOTE: You CANNOT do this with a keysOnly query.\n   */\n\n\n  IterationController.prototype.delete = function () {\n    return wrapRequest(this.dbCursor.delete());\n  };\n\n  return IterationController;\n}();\n\nexport { IterationController };\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\n\nvar SimpleDbTransaction =\n/** @class */\nfunction () {\n  function SimpleDbTransaction(db, mode, objectStoresNames) {\n    var _this = this;\n\n    this.aborted = false;\n    this.transaction = db.transaction(objectStoresNames, mode);\n    this.completionPromise = new Promise(function (resolve, reject) {\n      // We consider aborting to be \"normal\" and just resolve the promise.\n      // May need to revisit if/when we actually need to abort transactions.\n      _this.transaction.onabort = _this.transaction.oncomplete = function (event) {\n        resolve();\n      };\n\n      _this.transaction.onerror = function (event) {\n        reject(event.target.error);\n      };\n    });\n  }\n\n  SimpleDbTransaction.prototype.abort = function () {\n    if (!this.aborted) {\n      debug(LOG_TAG, 'Aborting transaction.');\n      this.aborted = true;\n      this.transaction.abort();\n    }\n  };\n  /**\n   * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n   * operations performed on the SimpleDbStore happen within the context of this\n   * transaction and it cannot be used anymore once the transaction is\n   * completed.\n   *\n   * Note that we can't actually enforce that the KeyType and ValueType are\n   * correct, but they allow type safety through the rest of the consuming code.\n   */\n\n\n  SimpleDbTransaction.prototype.store = function (storeName) {\n    var store = this.transaction.objectStore(storeName);\n    assert(!!store, 'Object store not part of transaction: ' + storeName);\n    return new SimpleDbStore(store);\n  };\n\n  return SimpleDbTransaction;\n}();\n\nexport { SimpleDbTransaction };\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\n\nvar SimpleDbStore =\n/** @class */\nfunction () {\n  function SimpleDbStore(store) {\n    this.store = store;\n  }\n\n  SimpleDbStore.prototype.put = function (keyOrValue, value) {\n    var request;\n\n    if (value !== undefined) {\n      debug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n      request = this.store.put(value, keyOrValue);\n    } else {\n      debug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n      request = this.store.put(keyOrValue);\n    }\n\n    return wrapRequest(request);\n  };\n  /**\n   * Gets the object with the specified key from the specified store, or null\n   * if no object exists with the specified key.\n   *\n   * @key The key of the object to get.\n   * @return The object with the specified key or null if no object exists.\n   */\n\n\n  SimpleDbStore.prototype.get = function (key) {\n    var _this = this;\n\n    var request = this.store.get(key); // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n\n    return wrapRequest(request).next(function (result) {\n      // Normalize nonexistence to null.\n      if (result === undefined) {\n        result = null;\n      }\n\n      debug(LOG_TAG, 'GET', _this.store.name, key, result);\n      return result;\n    });\n  };\n\n  SimpleDbStore.prototype.delete = function (key) {\n    debug(LOG_TAG, 'DELETE', this.store.name, key);\n    var request = this.store.delete(key);\n    return wrapRequest(request);\n  };\n\n  SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {\n    var cursor = this.cursor(this.options(indexOrRange, range));\n    var results = [];\n    return this.iterateCursor(cursor, function (key, value) {\n      results.push(value);\n    }).next(function () {\n      return results;\n    });\n  };\n\n  SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {\n    debug(LOG_TAG, 'DELETE ALL', this.store.name);\n    var options = this.options(indexOrRange, range);\n    options.keysOnly = false;\n    var cursor = this.cursor(options);\n    return this.iterateCursor(cursor, function (key, value, control) {\n      // NOTE: Calling delete() on a cursor is documented as more efficient than\n      // calling delete() on an object store with a single key\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n      // however, this requires us *not* to use a keysOnly cursor\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n      // may want to compare the performance of each method.\n      return control.delete();\n    });\n  };\n\n  SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {\n    var options;\n\n    if (!callback) {\n      options = {};\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    var cursor = this.cursor(options);\n    return this.iterateCursor(cursor, callback);\n  };\n\n  SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {\n    var results = [];\n    return new PersistencePromise(function (resolve, reject) {\n      cursorRequest.onerror = function (event) {\n        reject(event.target.error);\n      };\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (!cursor) {\n          resolve();\n          return;\n        }\n\n        var controller = new IterationController(cursor);\n        var userResult = fn(cursor.primaryKey, cursor.value, controller);\n\n        if (userResult instanceof PersistencePromise) {\n          results.push(userResult);\n        }\n\n        if (controller.isDone) {\n          resolve();\n        } else if (controller.skipToKey === null) {\n          cursor.continue();\n        } else {\n          cursor.continue(controller.skipToKey);\n        }\n      };\n    }).next(function () {\n      return PersistencePromise.waitFor(results);\n    });\n  };\n\n  SimpleDbStore.prototype.options = function (indexOrRange, range) {\n    var indexName = undefined;\n\n    if (indexOrRange !== undefined) {\n      if (typeof indexOrRange === 'string') {\n        indexName = indexOrRange;\n      } else {\n        assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');\n        range = indexOrRange;\n      }\n    }\n\n    return {\n      index: indexName,\n      range: range\n    };\n  };\n\n  SimpleDbStore.prototype.cursor = function (options) {\n    var direction = 'next';\n\n    if (options.reverse) {\n      direction = 'prev';\n    }\n\n    if (options.index) {\n      var index = this.store.index(options.index);\n\n      if (options.keysOnly) {\n        return index.openKeyCursor(options.range, direction);\n      } else {\n        return index.openCursor(options.range, direction);\n      }\n    } else {\n      return this.store.openCursor(options.range, direction);\n    }\n  };\n\n  return SimpleDbStore;\n}();\n\nexport { SimpleDbStore };\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\n\nfunction wrapRequest(request) {\n  return new PersistencePromise(function (resolve, reject) {\n    request.onsuccess = function (event) {\n      var result = event.target.result;\n      resolve(result);\n    };\n\n    request.onerror = function (event) {\n      reject(event.target.error);\n    };\n  });\n}","map":{"version":3,"sources":["../src/local/simple_db.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { AnyDuringMigration } from '../util/misc';\n\nimport { PersistencePromise } from './persistence_promise';\n\nconst LOG_TAG = 'SimpleDb';\n\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nexport class SimpleDb {\n  /** Opens the specified database, creating or upgrading it if necessary. */\n  static openOrCreate(\n    name: string,\n    version: number,\n    runUpgrade: (db: IDBDatabase, oldVersion: number) => void\n  ): Promise<SimpleDb> {\n    assert(\n      SimpleDb.isAvailable(),\n      'IndexedDB not supported in current environment.'\n    );\n    debug(LOG_TAG, 'Opening database:', name);\n    return new PersistencePromise<SimpleDb>((resolve, reject) => {\n      // TODO(mikelehen): Investigate browser compatibility.\n      // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n      // suggests IE9 and older WebKit browsers handle upgrade\n      // differently.\n      const request = window.indexedDB.open(name, version);\n\n      request.onsuccess = (event: Event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        resolve(new SimpleDb(db));\n      };\n\n      request.onerror = (event: ErrorEvent) => {\n        reject((event.target as IDBOpenDBRequest).error);\n      };\n\n      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n        debug(\n          LOG_TAG,\n          'Database \"' + name + '\" requires upgrade from version:',\n          event.oldVersion\n        );\n        // TODO(mikelehen): If/when we need to do an actual data\n        // migration, we'll want to wrap db in a SimpleDb and have the\n        // runUpgrade function return a PersistencePromise, since we'll\n        // likely need to do async reads and writes. For now we're\n        // cheating and just passing the raw IndexedDB in, since\n        // createObjectStore(), etc. are synchronous.\n        const db = (event.target as IDBOpenDBRequest).result;\n        runUpgrade(db, event.oldVersion);\n      };\n    }).toPromise();\n  }\n\n  /** Deletes the specified database. */\n  static delete(name: string): Promise<void> {\n    debug(LOG_TAG, 'Removing database:', name);\n    return wrapRequest<void>(window.indexedDB.deleteDatabase(name)).toPromise();\n  }\n\n  /** Returns true if IndexedDB is available in the current environment. */\n  static isAvailable(): boolean {\n    if (typeof window === 'undefined' || window.indexedDB == null) {\n      return false;\n    }\n    // We extensively use indexed array values and compound keys,\n    // which IE and Edge do not support. However, they still have indexedDB\n    // defined on the window, so we need to check for them here and make sure\n    // to return that persistence is not enabled for those browsers.\n    // For tracking support of this feature, see here:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n\n    // Check the UA string to find out the browser.\n    const ua = window.navigator.userAgent;\n\n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n\n    // Edge\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n    // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n\n    if (\n      ua.indexOf('MSIE ') > 0 ||\n      ua.indexOf('Trident/') > 0 ||\n      ua.indexOf('Edge/') > 0\n    ) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  constructor(private db: IDBDatabase) {}\n\n  runTransaction<T>(\n    mode: 'readonly' | 'readwrite',\n    objectStores: string[],\n    transactionFn: (transaction: SimpleDbTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    const transaction = new SimpleDbTransaction(this.db, mode, objectStores);\n    const transactionFnResult = transactionFn(transaction)\n      .catch(error => {\n        // Abort the transaction if there was an\n        // error.\n        transaction.abort();\n        return PersistencePromise.reject(error);\n      })\n      .toPromise();\n\n    // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n    // fire), but still return the original transactionFnResult back to the\n    // caller.\n    return transaction.completionPromise.then(\n      () => transactionFnResult\n    ) as AnyDuringMigration;\n  }\n\n  close() {\n    this.db.close();\n  }\n}\n\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nexport class IterationController {\n  private shouldStop = false;\n  private nextKey: IDBValidKey | IDBKeyRange | null = null;\n\n  constructor(private dbCursor: IDBCursorWithValue) {}\n\n  get isDone(): boolean {\n    return this.shouldStop;\n  }\n\n  get skipToKey(): IDBValidKey | IDBKeyRange | null {\n    return this.nextKey;\n  }\n\n  set cursor(value: IDBCursorWithValue) {\n    this.dbCursor = value;\n  }\n\n  /**\n   * This function can be called to stop iteration at any point.\n   */\n  done(): void {\n    this.shouldStop = true;\n  }\n\n  /**\n   * This function can be called to skip to that next key, which could be\n   * an index or a primary key.\n   */\n  skip(key: IDBValidKey | IDBKeyRange): void {\n    this.nextKey = key;\n  }\n\n  /**\n   * Delete the current cursor value from the object store.\n   *\n   * NOTE: You CANNOT do this with a keysOnly query.\n   */\n  delete(): PersistencePromise<void> {\n    return wrapRequest<void>(this.dbCursor.delete());\n  }\n}\n\n/**\n * Callback used with iterate() method.\n */\nexport type IterateCallback<KeyType, ValueType> = (\n  key: KeyType,\n  value: ValueType,\n  control: IterationController\n) => void | PersistencePromise<void>;\n\n/** Options available to the iterate() method. */\nexport interface IterateOptions {\n  /** Index to iterate over (else primary keys will be iterated) */\n  index?: string;\n\n  /** IndxedDB Range to iterate over (else entire store will be iterated) */\n  range?: IDBKeyRange;\n\n  /** If true, values aren't read while iterating. */\n  keysOnly?: boolean;\n\n  /** If true, iterate over the store in reverse. */\n  reverse?: boolean;\n}\n\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nexport class SimpleDbTransaction {\n  private transaction: IDBTransaction;\n  private aborted = false;\n\n  /**\n   * A promise that resolves with the result of the IndexedDb transaction.\n   *\n   * Note: A transaction explicitly aborted via abort() is considered successful\n   * and this promise will resolve as successful.\n   */\n  readonly completionPromise: Promise<void>;\n\n  constructor(db: IDBDatabase, mode: string, objectStoresNames: string[]) {\n    this.transaction = db.transaction(\n      objectStoresNames,\n      mode as AnyDuringMigration\n    );\n\n    this.completionPromise = new Promise<void>((resolve, reject) => {\n      // We consider aborting to be \"normal\" and just resolve the promise.\n      // May need to revisit if/when we actually need to abort transactions.\n      this.transaction.onabort = this.transaction.oncomplete = event => {\n        resolve();\n      };\n      this.transaction.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error);\n      };\n    });\n  }\n\n  abort(): void {\n    if (!this.aborted) {\n      debug(LOG_TAG, 'Aborting transaction.');\n      this.aborted = true;\n      this.transaction.abort();\n    }\n  }\n\n  /**\n   * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n   * operations performed on the SimpleDbStore happen within the context of this\n   * transaction and it cannot be used anymore once the transaction is\n   * completed.\n   *\n   * Note that we can't actually enforce that the KeyType and ValueType are\n   * correct, but they allow type safety through the rest of the consuming code.\n   */\n  store<KeyType extends IDBValidKey, ValueType>(\n    storeName: string\n  ): SimpleDbStore<KeyType, ValueType> {\n    const store = this.transaction.objectStore(storeName);\n    assert(!!store, 'Object store not part of transaction: ' + storeName);\n    return new SimpleDbStore<KeyType, ValueType>(store);\n  }\n}\n\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nexport class SimpleDbStore<KeyType extends IDBValidKey, ValueType> {\n  constructor(private store: IDBObjectStore) {}\n\n  /**\n   * Writes a value into the Object Store.\n   *\n   * @param key Optional explicit key to use when writing the object, else the\n   * key will be auto-assigned (e.g. via the defined keyPath for the store).\n   * @param value The object to write.\n   */\n  put(value: ValueType): PersistencePromise<void>;\n  put(key: KeyType, value: ValueType): PersistencePromise<void>;\n  put(\n    keyOrValue: KeyType | ValueType,\n    value?: ValueType\n  ): PersistencePromise<void> {\n    let request;\n    if (value !== undefined) {\n      debug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n      request = this.store.put(value, keyOrValue as KeyType);\n    } else {\n      debug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n      request = this.store.put(keyOrValue as ValueType);\n    }\n    return wrapRequest<void>(request);\n  }\n\n  /**\n   * Gets the object with the specified key from the specified store, or null\n   * if no object exists with the specified key.\n   *\n   * @key The key of the object to get.\n   * @return The object with the specified key or null if no object exists.\n   */\n  get(key: KeyType): PersistencePromise<ValueType | null> {\n    const request = this.store.get(key);\n    // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n    return wrapRequest<any>(request).next(result => {\n      // Normalize nonexistence to null.\n      if (result === undefined) {\n        result = null;\n      }\n      debug(LOG_TAG, 'GET', this.store.name, key, result);\n      return result;\n    });\n  }\n\n  delete(key: KeyType | IDBKeyRange): PersistencePromise<void> {\n    debug(LOG_TAG, 'DELETE', this.store.name, key);\n    const request = this.store.delete(key);\n    return wrapRequest<void>(request);\n  }\n\n  loadAll(): PersistencePromise<ValueType[]>;\n  loadAll(range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(index: string, range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<ValueType[]> {\n    const cursor = this.cursor(this.options(indexOrRange, range));\n    const results: ValueType[] = [];\n    return this.iterateCursor(cursor, (key, value) => {\n      results.push(value);\n    }).next(() => {\n      return results;\n    });\n  }\n\n  deleteAll(): PersistencePromise<void>;\n  deleteAll(range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(index: string, range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<void> {\n    debug(LOG_TAG, 'DELETE ALL', this.store.name);\n    const options = this.options(indexOrRange, range);\n    options.keysOnly = false;\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, (key, value, control) => {\n      // NOTE: Calling delete() on a cursor is documented as more efficient than\n      // calling delete() on an object store with a single key\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n      // however, this requires us *not* to use a keysOnly cursor\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n      // may want to compare the performance of each method.\n      return control.delete();\n    });\n  }\n\n  /**\n   * Iterates over keys and values in an object store.\n   *\n   * @param options Options specifying how to iterate the objects in the store.\n   * @param callback will be called for each iterated object. Iteration can be\n   * canceled at any point by calling the doneFn passed to the callback.\n   * The callback can return a PersistencePromise if it performs async\n   * operations but note that iteration will continue without waiting for them\n   * to complete.\n   * @returns A PersistencePromise that resolves once all PersistencePromises\n   * returned by callbacks resolve.\n   */\n  iterate(\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    options: IterateOptions,\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    optionsOrCallback: IterateOptions | IterateCallback<KeyType, ValueType>,\n    callback?: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    let options;\n    if (!callback) {\n      options = {};\n      callback = optionsOrCallback as IterateCallback<KeyType, ValueType>;\n    } else {\n      options = optionsOrCallback;\n    }\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, callback);\n  }\n\n  private iterateCursor(\n    cursorRequest: IDBRequest,\n    fn: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    const results: Array<PersistencePromise<void>> = [];\n    return new PersistencePromise((resolve, reject) => {\n      cursorRequest.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error);\n      };\n      cursorRequest.onsuccess = (event: Event) => {\n        const cursor: IDBCursorWithValue = (event.target as IDBRequest).result;\n        if (!cursor) {\n          resolve();\n          return;\n        }\n        const controller = new IterationController(cursor);\n        const userResult = fn(cursor.primaryKey, cursor.value, controller);\n        if (userResult instanceof PersistencePromise) {\n          results.push(userResult);\n        }\n        if (controller.isDone) {\n          resolve();\n        } else if (controller.skipToKey === null) {\n          cursor.continue();\n        } else {\n          cursor.continue(controller.skipToKey);\n        }\n      };\n    }).next(() => {\n      return PersistencePromise.waitFor(results);\n    });\n  }\n\n  private options(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): IterateOptions {\n    let indexName: string | undefined = undefined;\n    if (indexOrRange !== undefined) {\n      if (typeof indexOrRange === 'string') {\n        indexName = indexOrRange;\n      } else {\n        assert(\n          range === undefined,\n          '3rd argument must not be defined if 2nd is a range.'\n        );\n        range = indexOrRange;\n      }\n    }\n    return { index: indexName, range };\n  }\n\n  private cursor(options: IterateOptions): IDBRequest {\n    let direction = 'next';\n    if (options.reverse) {\n      direction = 'prev';\n    }\n    if (options.index) {\n      const index = this.store.index(options.index);\n      if (options.keysOnly) {\n        return index.openKeyCursor(\n          options.range,\n          direction as AnyDuringMigration\n        );\n      } else {\n        return index.openCursor(options.range, direction as AnyDuringMigration);\n      }\n    } else {\n      return this.store.openCursor(\n        options.range,\n        direction as AnyDuringMigration\n      );\n    }\n  }\n}\n\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest<R>(request: IDBRequest): PersistencePromise<R> {\n  return new PersistencePromise<R>((resolve, reject) => {\n    request.onsuccess = (event: Event) => {\n      const result = (event.target as IDBRequest).result;\n      resolve(result);\n    };\n\n    request.onerror = (event: Event) => {\n      reject((event.target as IDBRequest).error);\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"module"}