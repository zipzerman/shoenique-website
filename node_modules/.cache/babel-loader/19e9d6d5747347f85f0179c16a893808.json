{"ast":null,"code":"import _toConsumableArray from \"C:/Users/junecsnp/Desktop/JuneWeb+Shoe/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:/Users/junecsnp/Desktop/JuneWeb+Shoe/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\nvar t = Symbol(),\n    e = Symbol(),\n    r = Symbol(),\n    n = Object.getPrototypeOf,\n    s = new WeakMap(),\n    o = function o(t) {\n  return t && (n(t) === Object.prototype || n(t) === Array.prototype || !!s.get(t));\n},\n    i = function i(t) {\n  return \"object\" == typeof t && null !== t;\n},\n    c = function c(n) {\n  var s = {\n    o: n,\n    t: !1,\n    r: function r(t) {\n      if (!this.t) {\n        var _e = this.a.get(this.o);\n\n        _e || (_e = new Set(), this.a.set(this.o, _e)), _e.add(t);\n      }\n    },\n    u: function u() {\n      this.t = !0, this.a.delete(this.o);\n    },\n    get: function get(t, e) {\n      return e === r ? this.o : (this.r(e), l(t[e], this.a, this.c));\n    },\n    has: function has(t, r) {\n      return r === e ? (this.u(), !0) : (this.r(r), r in t);\n    },\n    ownKeys: function ownKeys(e) {\n      return this.r(t), Reflect.ownKeys(e);\n    }\n  };\n  return Object.isFrozen(n) && (s.set = s.deleteProperty = function () {\n    return !1;\n  }), s;\n},\n    l = function l(t, e, s) {\n  if (!o(t)) return t;\n  var i = t[r] || t;\n  var l = s && s.get(i);\n  return l || (l = c(i), l.p = new Proxy(function (t) {\n    return Object.isFrozen(t) ? Array.isArray(t) ? Array.from(t) : Object.create(n(t), function (t) {\n      var e = Object.getOwnPropertyDescriptors(t);\n      return Object.values(e).forEach(function (t) {\n        t.configurable = !0;\n      }), e;\n    }(t)) : t;\n  }(i), l), s && s.set(i, l)), l.a = e, l.c = s, l.p;\n},\n    u = function u(t, e) {\n  var r = Reflect.ownKeys(t),\n      n = Reflect.ownKeys(e);\n  return r.length !== n.length || r.some(function (t, e) {\n    return t !== n[e];\n  });\n},\n    h = 1,\n    a = 2,\n    f = 4,\n    y = 8,\n    g = function g(e, r, n, s) {\n  var o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  if (Object.is(e, r) && (!i(e) || 0 == (2 & o))) return !1;\n  if (!i(e) || !i(r)) return !0;\n  var c = n.get(e);\n  if (!c) return 0 == (1 & o);\n\n  if (s && 0 == (2 & o)) {\n    var _t = s.get(e);\n\n    if (_t && _t.n === r) return _t.g;\n    s.set(e, {\n      n: r,\n      g: !1\n    });\n  }\n\n  var l = null;\n\n  var _iterator = _createForOfIteratorHelper(c),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _i = _step.value;\n\n      var _c = _i === t ? u(e, r) : g(e[_i], r[_i], n, s, o >>> 2 << 2 | o >>> 2);\n\n      if (!0 !== _c && !1 !== _c || (l = _c), l) break;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null === l && (l = 0 == (1 & o)), s && 0 == (2 & o) && s.set(e, {\n    n: r,\n    g: l\n  }), l;\n},\n    b = function b(t) {\n  return !!o(t) && e in t;\n},\n    p = function p(t) {\n  return o(t) && t[r] || null;\n},\n    O = function O(t) {\n  s.set(t, !0);\n},\n    j = function j(t, e) {\n  var r = [],\n      n = function n(t, s) {\n    var o = e.get(t);\n    o ? o.forEach(function (e) {\n      n(t[e], s ? [].concat(_toConsumableArray(s), [e]) : [e]);\n    }) : s && r.push(s);\n  };\n\n  return n(t), r;\n};\n\nexport { h as MODE_ASSUME_UNCHANGED_IF_UNAFFECTED, f as MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP, a as MODE_IGNORE_REF_EQUALITY, y as MODE_IGNORE_REF_EQUALITY_IN_DEEP, j as affectedToPathList, l as createDeepProxy, p as getUntrackedObject, g as isDeepChanged, O as markToTrack, b as trackMemo };","map":{"version":3,"sources":["../src/index.ts"],"names":["OWN_KEYS_SYMBOL","Symbol","TRACK_MEMO_SYMBOL","GET_ORIGINAL_SYMBOL","getProto","Object","getPrototypeOf","objectsToTrack","WeakMap","isObjectToTrack","obj","prototype","Array","get","isObject","x","descriptors","getOwnPropertyDescriptors","values","forEach","descriptor","configurable","isFrozen","isArray","from","create","createProxyHandler","origObj","handler","o","t","[object Object]","key","this","used","Set","set","add","delete","target","createDeepProxy","has","ownKeys","Reflect","deleteProperty","affected","proxyCache","proxyHandler","Proxy","isOwnKeysChanged","nextObj","origKeys","nextKeys","length","some","k","i","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED","MODE_IGNORE_REF_EQUALITY","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP","MODE_IGNORE_REF_EQUALITY_IN_DEEP","isDeepChanged","cache","mode","is","hit","n","g","changed","c","trackMemo","getUntrackedObject","markToTrack","affectedToPathList","list","walk","path","push"],"mappings":"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","sourcesContent":["// symbols\nconst OWN_KEYS_SYMBOL = Symbol();\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\n// properties\nconst TRACK_OBJECT_PROPERTY = 't';\nconst AFFECTED_PROPERTY = 'a';\nconst RECORD_USAGE_PROPERTY = 'r';\nconst RECORD_OBJECT_AS_USED_PROPERTY = 'u';\nconst ORIGINAL_OBJECT_PROPERTY = 'o';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\n\n// get object prototype\nconst getProto = Object.getPrototypeOf;\n\nconst objectsToTrack = new WeakMap<object, boolean>();\n\n// check if obj is a plain object or an array\nconst isObjectToTrack = <T>(obj: T): obj is T extends object ? T : never => (\n  obj && (\n    getProto(obj) === Object.prototype\n    || getProto(obj) === Array.prototype\n    || !!objectsToTrack.get(obj as unknown as object)\n  )\n);\n\n// check if it is object\nconst isObject = (x: unknown): x is object => (\n  typeof x === 'object' && x !== null\n);\n\nconst getPropDescs = (obj: object) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  Object.values(descriptors).forEach((descriptor) => {\n    descriptor.configurable = true;\n  });\n  return descriptors;\n};\n\n// copy obj if frozen\nconst unfreeze = (obj: object) => (\n  !Object.isFrozen(obj) ? obj\n    : Array.isArray(obj) ? Array.from(obj)\n      : /* otherwise */ Object.create(getProto(obj), getPropDescs(obj))\n);\n\ntype Affected = WeakMap<object, Set<string | number | symbol>>;\ntype ProxyCache<T extends object> = WeakMap<object, ProxyHandler<T>>;\ntype ProxyHandler<T extends object> = {\n  [PROXY_PROPERTY]?: T;\n  [PROXY_CACHE_PROPERTY]?: ProxyCache<object>;\n  [AFFECTED_PROPERTY]?: Affected;\n  [TRACK_OBJECT_PROPERTY]: boolean;\n  [ORIGINAL_OBJECT_PROPERTY]: T;\n  [RECORD_USAGE_PROPERTY](key: string | number | symbol): void;\n  [RECORD_OBJECT_AS_USED_PROPERTY](): void;\n  get(target: T, key: string | number | symbol): unknown;\n  has(target: T, key: string | number | symbol): boolean;\n  ownKeys(target: T): (string | number | symbol)[];\n  set?(target: T, key: string | number | symbol, value: unknown): boolean;\n  deleteProperty?(target: T, key: string | number | symbol): boolean;\n};\n\nconst createProxyHandler = <T extends object>(origObj: T) => {\n  const handler: ProxyHandler<T> = {\n    [ORIGINAL_OBJECT_PROPERTY]: origObj,\n    [TRACK_OBJECT_PROPERTY]: false, // for trackMemo\n    [RECORD_USAGE_PROPERTY](key) {\n      if (!this[TRACK_OBJECT_PROPERTY]) {\n        let used = (this[AFFECTED_PROPERTY] as Affected).get(this[ORIGINAL_OBJECT_PROPERTY]);\n        if (!used) {\n          used = new Set();\n          (this[AFFECTED_PROPERTY] as Affected).set(this[ORIGINAL_OBJECT_PROPERTY], used);\n        }\n        used.add(key);\n      }\n    },\n    [RECORD_OBJECT_AS_USED_PROPERTY]() {\n      this[TRACK_OBJECT_PROPERTY] = true;\n      (this[AFFECTED_PROPERTY] as Affected).delete(this[ORIGINAL_OBJECT_PROPERTY]);\n    },\n    get(target, key) {\n      if (key === GET_ORIGINAL_SYMBOL) {\n        return this[ORIGINAL_OBJECT_PROPERTY];\n      }\n      this[RECORD_USAGE_PROPERTY](key);\n      return createDeepProxy(\n        (target as any)[key],\n        (this[AFFECTED_PROPERTY] as Affected),\n        this[PROXY_CACHE_PROPERTY],\n      );\n    },\n    has(target, key) {\n      if (key === TRACK_MEMO_SYMBOL) {\n        this[RECORD_OBJECT_AS_USED_PROPERTY]();\n        return true;\n      }\n      // LIMITATION:\n      // We simply record the same as get.\n      // This means { a: {} } and { a: {} } is detected as changed,\n      // if 'a' in obj is handled.\n      this[RECORD_USAGE_PROPERTY](key);\n      return key in target;\n    },\n    ownKeys(target) {\n      this[RECORD_USAGE_PROPERTY](OWN_KEYS_SYMBOL);\n      return Reflect.ownKeys(target);\n    },\n  };\n  if (Object.isFrozen(origObj)) {\n    handler.set = handler.deleteProperty = () => false;\n  }\n  return handler;\n};\n\n/**\n * create a proxy\n *\n * It will recursively create a proxy upon access.\n *\n * @example\n * import { createDeepProxy } from 'proxy-compare';\n *\n * const obj = ...;\n * const affected = new WeakMap();\n * const proxy = createDeepProxy(obj, affected);\n */\nexport const createDeepProxy = <T>(\n  obj: T,\n  affected: WeakMap<object, unknown>,\n  proxyCache?: WeakMap<object, unknown>,\n): T => {\n  if (!isObjectToTrack(obj)) return obj;\n  const origObj = (\n    obj as { [GET_ORIGINAL_SYMBOL]?: typeof obj }\n  )[GET_ORIGINAL_SYMBOL]; // unwrap proxy\n  const target = origObj || obj;\n  let proxyHandler: ProxyHandler<typeof target> | undefined = (\n    proxyCache && (proxyCache as ProxyCache<typeof target>).get(target)\n  );\n  if (!proxyHandler) {\n    proxyHandler = createProxyHandler<T extends object ? T : never>(target);\n    proxyHandler[PROXY_PROPERTY] = new Proxy(unfreeze(target), proxyHandler) as typeof target;\n    if (proxyCache) {\n      proxyCache.set(target, proxyHandler);\n    }\n  }\n  proxyHandler[AFFECTED_PROPERTY] = affected as Affected;\n  proxyHandler[PROXY_CACHE_PROPERTY] = proxyCache as ProxyCache<object> | undefined;\n  return proxyHandler[PROXY_PROPERTY] as typeof target;\n};\n\nconst isOwnKeysChanged = (origObj: object, nextObj: object) => {\n  const origKeys = Reflect.ownKeys(origObj);\n  const nextKeys = Reflect.ownKeys(nextObj);\n  return origKeys.length !== nextKeys.length\n    || origKeys.some((k, i) => k !== nextKeys[i]);\n};\n\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED = /*   */ 0b00001;\nexport const MODE_IGNORE_REF_EQUALITY = /*              */ 0b00010;\n\nconst IN_DEEP_SHIFT = 2;\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP = (\n  MODE_ASSUME_UNCHANGED_IF_UNAFFECTED << IN_DEEP_SHIFT\n);\nexport const MODE_IGNORE_REF_EQUALITY_IN_DEEP = (\n  MODE_IGNORE_REF_EQUALITY << IN_DEEP_SHIFT\n);\n\ntype DeepChangedCache = WeakMap<object, {\n  [NEXT_OBJECT_PROPERTY]: object;\n  [CHANGED_PROPERTY]: boolean;\n}>;\n\n/**\n * compare two object\n *\n * It will compare only with affected object properties\n *\n * @example\n * import { isDeepChanged } from 'proxy-compare';\n *\n * const objToCompare = ...;\n * const changed = isDeepChanged(obj, objToCompare, affected);\n */\nexport const isDeepChanged = (\n  origObj: unknown,\n  nextObj: unknown,\n  affected: WeakMap<object, unknown>,\n  cache?: WeakMap<object, unknown>,\n  mode = 0,\n): boolean => {\n  if (Object.is(origObj, nextObj) && (\n    !isObject(origObj) || (mode & MODE_IGNORE_REF_EQUALITY) === 0)\n  ) {\n    return false;\n  }\n  if (!isObject(origObj) || !isObject(nextObj)) return true;\n  const used = (affected as Affected).get(origObj);\n  if (!used) return (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    const hit = (cache as DeepChangedCache).get(origObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles\n    (cache as DeepChangedCache).set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: false,\n    });\n  }\n  let changed: boolean | null = null;\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key of used) {\n    const c = key === OWN_KEYS_SYMBOL ? isOwnKeysChanged(origObj, nextObj)\n      : isDeepChanged(\n        (origObj as any)[key],\n        (nextObj as any)[key],\n        affected,\n        cache,\n        ((mode >>> IN_DEEP_SHIFT) << IN_DEEP_SHIFT) | (mode >>> IN_DEEP_SHIFT),\n      );\n    if (c === true || c === false) changed = c;\n    if (changed) break;\n  }\n  if (changed === null) changed = (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    cache.set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: changed,\n    });\n  }\n  return changed;\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj: unknown) => {\n  if (isObjectToTrack(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n// get original object from proxy\nexport const getUntrackedObject = <T>(obj: T): T | null => {\n  if (isObjectToTrack(obj)) {\n    return (obj as { [GET_ORIGINAL_SYMBOL]?: T })[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n\n// mark object to track (even if it is not plain)\nexport const markToTrack = (obj: object) => {\n  objectsToTrack.set(obj, true);\n};\n\n// convert affected to path list\nexport const affectedToPathList = (\n  obj: unknown,\n  affected: WeakMap<object, unknown>,\n) => {\n  const list: (string | number | symbol)[][] = [];\n  const walk = (x: unknown, path?: (string | number | symbol)[]) => {\n    const used = (affected as Affected).get(x as object);\n    if (used) {\n      used.forEach((key) => {\n        walk((x as any)[key], path ? [...path, key] : [key]);\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(obj);\n  return list;\n};\n"]},"metadata":{},"sourceType":"module"}