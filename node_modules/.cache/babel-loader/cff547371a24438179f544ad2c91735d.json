{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nexport var DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\n\nvar Path =\n/** @class */\nfunction () {\n  function Path(segments, offset, length) {\n    this.init(segments, offset, length);\n  }\n  /**\n   * An initialization method that can be called from outside the constructor.\n   * We need this so that we can have a non-static construct method that returns\n   * the polymorphic `this` type.\n   */\n\n\n  Path.prototype.init = function (segments, offset, length) {\n    if (offset === undefined) {\n      offset = 0;\n    } else if (offset > segments.length) {\n      fail('offset ' + offset + ' out of range ' + segments.length);\n    }\n\n    if (length === undefined) {\n      length = segments.length - offset;\n    } else if (length > segments.length - offset) {\n      fail('length ' + length + ' out of range ' + (segments.length - offset));\n    }\n\n    this.segments = segments;\n    this.offset = offset;\n    this.len = length;\n  };\n  /**\n   * Constructs a new instance of Path using the same concrete type as `this`.\n   * We need this instead of using the normal constructor, because polymorphic\n   * `this` doesn't work on static methods.\n   */\n\n\n  Path.prototype.construct = function (segments, offset, length) {\n    var path = Object.create(Object.getPrototypeOf(this));\n    path.init(segments, offset, length);\n    return path;\n  };\n\n  Object.defineProperty(Path.prototype, \"length\", {\n    get: function get() {\n      return this.len;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Path.prototype.equals = function (other) {\n    return Path.comparator(this, other) === 0;\n  };\n\n  Path.prototype.child = function (nameOrPath) {\n    var segments = this.segments.slice(this.offset, this.limit());\n\n    if (nameOrPath instanceof Path) {\n      nameOrPath.forEach(function (segment) {\n        segments.push(segment);\n      });\n    } else if (typeof nameOrPath === 'string') {\n      segments.push(nameOrPath);\n    } else {\n      fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n    }\n\n    return this.construct(segments);\n  };\n  /** The index of one past the last segment of the path. */\n\n\n  Path.prototype.limit = function () {\n    return this.offset + this.length;\n  };\n\n  Path.prototype.popFirst = function (size) {\n    size = size === undefined ? 1 : size;\n    assert(this.length >= size, \"Can't call popFirst() with less segments\");\n    return this.construct(this.segments, this.offset + size, this.length - size);\n  };\n\n  Path.prototype.popLast = function () {\n    assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n    return this.construct(this.segments, this.offset, this.length - 1);\n  };\n\n  Path.prototype.firstSegment = function () {\n    assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n    return this.segments[this.offset];\n  };\n\n  Path.prototype.lastSegment = function () {\n    assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n    return this.segments[this.limit() - 1];\n  };\n\n  Path.prototype.get = function (index) {\n    assert(index < this.length, 'Index out of range');\n    return this.segments[this.offset + index];\n  };\n\n  Path.prototype.isEmpty = function () {\n    return this.length === 0;\n  };\n\n  Path.prototype.isPrefixOf = function (other) {\n    if (other.length < this.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      if (this.get(i) !== other.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Path.prototype.forEach = function (fn) {\n    for (var i = this.offset, end = this.limit(); i < end; i++) {\n      fn(this.segments[i]);\n    }\n  };\n\n  Path.prototype.toArray = function () {\n    return this.segments.slice(this.offset, this.limit());\n  };\n\n  Path.comparator = function (p1, p2) {\n    var len = Math.min(p1.length, p2.length);\n\n    for (var i = 0; i < len; i++) {\n      var left = p1.get(i);\n      var right = p2.get(i);\n      if (left < right) return -1;\n      if (left > right) return 1;\n    }\n\n    if (p1.length < p2.length) return -1;\n    if (p1.length > p2.length) return 1;\n    return 0;\n  };\n\n  return Path;\n}();\n\nexport { Path };\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\n\nvar ResourcePath =\n/** @class */\nfunction (_super) {\n  __extends(ResourcePath, _super);\n\n  function ResourcePath() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ResourcePath.prototype.canonicalString = function () {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n    return this.toArray().join('/');\n  };\n\n  ResourcePath.prototype.toString = function () {\n    return this.canonicalString();\n  };\n  /**\n   * Creates a resource path from the given slash-delimited string.\n   */\n\n\n  ResourcePath.fromString = function (path) {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n    if (path.indexOf('//') >= 0) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid path (\" + path + \"). Paths must not contain // in them.\");\n    } // We may still have an empty segment at the beginning or end if they had a\n    // leading or trailing slash (which we allow).\n\n\n    var segments = path.split('/').filter(function (segment) {\n      return segment.length > 0;\n    });\n    return new ResourcePath(segments);\n  };\n\n  ResourcePath.EMPTY_PATH = new ResourcePath([]);\n  return ResourcePath;\n}(Path);\n\nexport { ResourcePath };\nvar identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/** A dot-separated path for navigating sub-objects within a document. */\n\nvar FieldPath =\n/** @class */\nfunction (_super) {\n  __extends(FieldPath, _super);\n\n  function FieldPath() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Returns true if the string could be used as a segment in a field path\n   * without escaping.\n   */\n\n\n  FieldPath.isValidIdentifier = function (segment) {\n    return identifierRegExp.test(segment);\n  };\n\n  FieldPath.prototype.canonicalString = function () {\n    return this.toArray().map(function (str) {\n      str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n\n      if (!FieldPath.isValidIdentifier(str)) {\n        str = '`' + str + '`';\n      }\n\n      return str;\n    }).join('.');\n  };\n\n  FieldPath.prototype.toString = function () {\n    return this.canonicalString();\n  };\n  /**\n   * Returns true if this field references the key of a document.\n   */\n\n\n  FieldPath.prototype.isKeyField = function () {\n    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n  };\n  /**\n   * The field designating the key of a document.\n   */\n\n\n  FieldPath.keyField = function () {\n    return new FieldPath([DOCUMENT_KEY_NAME]);\n  };\n  /**\n   * Parses a field string from the given server-formatted string.\n   *\n   * - Splitting the empty string is not allowed (for now at least).\n   * - Empty segments within the string (e.g. if there are two consecutive\n   *   separators) are not allowed.\n   *\n   * TODO(b/37244157): we should make this more strict. Right now, it allows\n   * non-identifier path components, even if they aren't escaped.\n   */\n\n\n  FieldPath.fromServerFormat = function (path) {\n    var segments = [];\n    var current = '';\n    var i = 0;\n\n    var addCurrentSegment = function addCurrentSegment() {\n      if (current.length === 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, begin \" + \"with '.', end with '.', or contain '..'\");\n      }\n\n      segments.push(current);\n      current = '';\n    };\n\n    var inBackticks = false;\n\n    while (i < path.length) {\n      var c = path[i];\n\n      if (c === '\\\\') {\n        if (i + 1 === path.length) {\n          throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n        }\n\n        var next = path[i + 1];\n\n        if (!(next === '\\\\' || next === '.' || next === '`')) {\n          throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n        }\n\n        current += next;\n        i += 2;\n      } else if (c === '`') {\n        inBackticks = !inBackticks;\n        i++;\n      } else if (c === '.' && !inBackticks) {\n        addCurrentSegment();\n        i++;\n      } else {\n        current += c;\n        i++;\n      }\n    }\n\n    addCurrentSegment();\n\n    if (inBackticks) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n    }\n\n    return new FieldPath(segments);\n  };\n\n  FieldPath.EMPTY_PATH = new FieldPath([]);\n  return FieldPath;\n}(Path);\n\nexport { FieldPath };","map":{"version":3,"sources":["../src/model/path.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n\nexport const DOCUMENT_KEY_NAME = '__name__';\n\n/**\n * Path represents an ordered sequence of string segments.\n */\nexport abstract class Path {\n  private segments: string[];\n  private offset: number;\n  private len: number;\n\n  public constructor(segments: string[], offset?: number, length?: number) {\n    this.init(segments, offset, length);\n  }\n\n  /**\n   * An initialization method that can be called from outside the constructor.\n   * We need this so that we can have a non-static construct method that returns\n   * the polymorphic `this` type.\n   */\n  private init(segments: string[], offset?: number, length?: number) {\n    if (offset === undefined) {\n      offset = 0;\n    } else if (offset > segments.length) {\n      fail('offset ' + offset + ' out of range ' + segments.length);\n    }\n\n    if (length === undefined) {\n      length = segments.length - offset;\n    } else if (length > segments.length - offset) {\n      fail('length ' + length + ' out of range ' + (segments.length - offset));\n    }\n    this.segments = segments;\n    this.offset = offset;\n    this.len = length;\n  }\n\n  /**\n   * Constructs a new instance of Path using the same concrete type as `this`.\n   * We need this instead of using the normal constructor, because polymorphic\n   * `this` doesn't work on static methods.\n   */\n  private construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): this {\n    const path: this = Object.create(Object.getPrototypeOf(this));\n    path.init(segments, offset, length);\n    return path;\n  }\n\n  get length(): number {\n    return this.len;\n  }\n\n  equals(other: Path): boolean {\n    return Path.comparator(this, other) === 0;\n  }\n\n  child(nameOrPath: string | this): this {\n    const segments = this.segments.slice(this.offset, this.limit());\n    if (nameOrPath instanceof Path) {\n      nameOrPath.forEach(segment => {\n        segments.push(segment);\n      });\n    } else if (typeof nameOrPath === 'string') {\n      segments.push(nameOrPath);\n    } else {\n      fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n    }\n    return this.construct(segments);\n  }\n\n  /** The index of one past the last segment of the path. */\n  private limit(): number {\n    return this.offset + this.length;\n  }\n\n  popFirst(size?: number): this {\n    size = size === undefined ? 1 : size;\n    assert(this.length >= size, \"Can't call popFirst() with less segments\");\n    return this.construct(\n      this.segments,\n      this.offset + size,\n      this.length - size\n    );\n  }\n\n  popLast(): this {\n    assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n    return this.construct(this.segments, this.offset, this.length - 1);\n  }\n\n  firstSegment(): string {\n    assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n    return this.segments[this.offset];\n  }\n\n  lastSegment(): string {\n    assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n    return this.segments[this.limit() - 1];\n  }\n\n  get(index: number): string {\n    assert(index < this.length, 'Index out of range');\n    return this.segments[this.offset + index];\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  isPrefixOf(other: this): boolean {\n    if (other.length < this.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== other.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  forEach(fn: (segment: string) => void): void {\n    for (let i = this.offset, end = this.limit(); i < end; i++) {\n      fn(this.segments[i]);\n    }\n  }\n\n  toArray(): string[] {\n    return this.segments.slice(this.offset, this.limit());\n  }\n\n  static comparator(p1: Path, p2: Path): number {\n    const len = Math.min(p1.length, p2.length);\n    for (let i = 0; i < len; i++) {\n      const left = p1.get(i);\n      const right = p2.get(i);\n      if (left < right) return -1;\n      if (left > right) return 1;\n    }\n    if (p1.length < p2.length) return -1;\n    if (p1.length > p2.length) return 1;\n    return 0;\n  }\n}\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nexport class ResourcePath extends Path {\n  canonicalString(): string {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    return this.toArray().join('/');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Creates a resource path from the given slash-delimited string.\n   */\n  static fromString(path: string): ResourcePath {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    if (path.indexOf('//') >= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid path (${path}). Paths must not contain // in them.`\n      );\n    }\n\n    // We may still have an empty segment at the beginning or end if they had a\n    // leading or trailing slash (which we allow).\n    const segments = path.split('/').filter(segment => segment.length > 0);\n\n    return new ResourcePath(segments);\n  }\n\n  static EMPTY_PATH = new ResourcePath([]);\n}\n\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n/** A dot-separated path for navigating sub-objects within a document. */\nexport class FieldPath extends Path {\n  /**\n   * Returns true if the string could be used as a segment in a field path\n   * without escaping.\n   */\n  private static isValidIdentifier(segment: string) {\n    return identifierRegExp.test(segment);\n  }\n\n  canonicalString(): string {\n    return this.toArray()\n      .map(str => {\n        str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n        if (!FieldPath.isValidIdentifier(str)) {\n          str = '`' + str + '`';\n        }\n        return str;\n      })\n      .join('.');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Returns true if this field references the key of a document.\n   */\n  isKeyField(): boolean {\n    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n  }\n\n  /**\n   * The field designating the key of a document.\n   */\n  static keyField(): FieldPath {\n    return new FieldPath([DOCUMENT_KEY_NAME]);\n  }\n\n  /**\n   * Parses a field string from the given server-formatted string.\n   *\n   * - Splitting the empty string is not allowed (for now at least).\n   * - Empty segments within the string (e.g. if there are two consecutive\n   *   separators) are not allowed.\n   *\n   * TODO(b/37244157): we should make this more strict. Right now, it allows\n   * non-identifier path components, even if they aren't escaped.\n   */\n  static fromServerFormat(path: string): FieldPath {\n    const segments: string[] = [];\n    let current = '';\n    let i = 0;\n\n    const addCurrentSegment = () => {\n      if (current.length === 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid field path (${path}). Paths must not be empty, begin ` +\n            `with '.', end with '.', or contain '..'`\n        );\n      }\n      segments.push(current);\n      current = '';\n    };\n\n    let inBackticks = false;\n\n    while (i < path.length) {\n      const c = path[i];\n      if (c === '\\\\') {\n        if (i + 1 === path.length) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has trailing escape character: ' + path\n          );\n        }\n        const next = path[i + 1];\n        if (!(next === '\\\\' || next === '.' || next === '`')) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has invalid escape sequence: ' + path\n          );\n        }\n        current += next;\n        i += 2;\n      } else if (c === '`') {\n        inBackticks = !inBackticks;\n        i++;\n      } else if (c === '.' && !inBackticks) {\n        addCurrentSegment();\n        i++;\n      } else {\n        current += c;\n        i++;\n      }\n    }\n    addCurrentSegment();\n\n    if (inBackticks) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Unterminated ` in path: ' + path\n      );\n    }\n\n    return new FieldPath(segments);\n  }\n\n  static EMPTY_PATH = new FieldPath([]);\n}\n"]},"metadata":{},"sourceType":"module"}