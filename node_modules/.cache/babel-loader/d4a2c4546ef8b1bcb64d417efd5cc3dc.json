{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { Code, FirestoreError } from '../util/error';\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\n\nvar Transaction =\n/** @class */\nfunction () {\n  function Transaction(datastore) {\n    this.datastore = datastore; // The version of each document that was read during this transaction.\n\n    this.readVersions = documentVersionMap();\n    this.mutations = [];\n    this.committed = false;\n  }\n\n  Transaction.prototype.recordVersion = function (doc) {\n    var docVersion = doc.version;\n\n    if (doc instanceof NoDocument) {\n      // For deleted docs, we must use baseVersion 0 when we overwrite them.\n      docVersion = SnapshotVersion.forDeletedDoc();\n    }\n\n    var existingVersion = this.readVersions.get(doc.key);\n\n    if (existingVersion !== null) {\n      if (!docVersion.equals(existingVersion)) {\n        // This transaction will fail no matter what.\n        throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n      }\n    } else {\n      this.readVersions = this.readVersions.insert(doc.key, docVersion);\n    }\n  };\n\n  Transaction.prototype.lookup = function (keys) {\n    var _this = this;\n\n    if (this.committed) {\n      return Promise.reject('Transaction has already completed.');\n    }\n\n    if (this.mutations.length > 0) {\n      return Promise.reject('Transactions lookups are invalid after writes.');\n    }\n\n    return this.datastore.lookup(keys).then(function (docs) {\n      docs.forEach(function (doc) {\n        return _this.recordVersion(doc);\n      });\n      return docs;\n    });\n  };\n\n  Transaction.prototype.write = function (mutations) {\n    if (this.committed) {\n      throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n    }\n\n    this.mutations = this.mutations.concat(mutations);\n  };\n  /**\n   * Returns the version of this document when it was read in this transaction,\n   * as a precondition, or no precondition if it was not read.\n   */\n\n\n  Transaction.prototype.precondition = function (key) {\n    var version = this.readVersions.get(key);\n\n    if (version) {\n      return Precondition.updateTime(version);\n    } else {\n      return Precondition.NONE;\n    }\n  };\n  /**\n   * Returns the precondition for a document if the operation is an update.\n   */\n\n\n  Transaction.prototype.preconditionForUpdate = function (key) {\n    var version = this.readVersions.get(key);\n\n    if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n      // The document doesn't exist, so fail the transaction.\n      throw new FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n    } else if (version) {\n      // Document exists, base precondition on document update time.\n      return Precondition.updateTime(version);\n    } else {\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Precondition.exists(true);\n    }\n  };\n\n  Transaction.prototype.set = function (key, data) {\n    this.write(data.toMutations(key, this.precondition(key)));\n  };\n\n  Transaction.prototype.update = function (key, data) {\n    this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n  };\n\n  Transaction.prototype.delete = function (key) {\n    this.write([new DeleteMutation(key, this.precondition(key))]); // Since the delete will be applied before all following writes, we need to\n    // ensure that the precondition for the next write will be exists: false.\n\n    this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());\n  };\n\n  Transaction.prototype.commit = function () {\n    var _this = this;\n\n    var unwritten = this.readVersions; // For each mutation, note that the doc was written.\n\n    this.mutations.forEach(function (mutation) {\n      unwritten = unwritten.remove(mutation.key);\n    });\n\n    if (!unwritten.isEmpty()) {\n      return Promise.reject(Error('Every document read in a transaction must also be written.'));\n    }\n\n    return this.datastore.commit(this.mutations).then(function () {\n      _this.committed = true;\n    });\n  };\n\n  return Transaction;\n}();\n\nexport { Transaction };","map":{"version":3,"sources":["../src/core/transaction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParsedSetData, ParsedUpdateData } from '../api/user_data_converter';\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { Datastore } from '../remote/datastore';\nimport { Code, FirestoreError } from '../util/error';\n\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nexport class Transaction {\n  // The version of each document that was read during this transaction.\n  private readVersions = documentVersionMap();\n  private mutations: Mutation[] = [];\n  private committed = false;\n\n  constructor(private datastore: Datastore) {}\n\n  private recordVersion(doc: MaybeDocument) {\n    let docVersion = doc.version;\n    if (doc instanceof NoDocument) {\n      // For deleted docs, we must use baseVersion 0 when we overwrite them.\n      docVersion = SnapshotVersion.forDeletedDoc();\n    }\n    const existingVersion = this.readVersions.get(doc.key);\n    if (existingVersion !== null) {\n      if (!docVersion.equals(existingVersion)) {\n        // This transaction will fail no matter what.\n        throw new FirestoreError(\n          Code.ABORTED,\n          'Document version changed between two reads.'\n        );\n      }\n    } else {\n      this.readVersions = this.readVersions.insert(doc.key, docVersion);\n    }\n  }\n\n  lookup(keys: DocumentKey[]): Promise<MaybeDocument[]> {\n    if (this.committed) {\n      return Promise.reject<MaybeDocument[]>(\n        'Transaction has already completed.'\n      );\n    }\n    if (this.mutations.length > 0) {\n      return Promise.reject<MaybeDocument[]>(\n        'Transactions lookups are invalid after writes.'\n      );\n    }\n    return this.datastore.lookup(keys).then(docs => {\n      docs.forEach(doc => this.recordVersion(doc));\n      return docs;\n    });\n  }\n\n  private write(mutations: Mutation[]) {\n    if (this.committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Transaction has already completed.'\n      );\n    }\n    this.mutations = this.mutations.concat(mutations);\n  }\n\n  /**\n   * Returns the version of this document when it was read in this transaction,\n   * as a precondition, or no precondition if it was not read.\n   */\n  private precondition(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key);\n    if (version) {\n      return Precondition.updateTime(version);\n    } else {\n      return Precondition.NONE;\n    }\n  }\n\n  /**\n   * Returns the precondition for a document if the operation is an update.\n   */\n  private preconditionForUpdate(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key);\n    if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n      // The document doesn't exist, so fail the transaction.\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        \"Can't update a document that doesn't exist.\"\n      );\n    } else if (version) {\n      // Document exists, base precondition on document update time.\n      return Precondition.updateTime(version);\n    } else {\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Precondition.exists(true);\n    }\n  }\n\n  set(key: DocumentKey, data: ParsedSetData) {\n    this.write(data.toMutations(key, this.precondition(key)));\n  }\n\n  update(key: DocumentKey, data: ParsedUpdateData) {\n    this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n  }\n\n  delete(key: DocumentKey) {\n    this.write([new DeleteMutation(key, this.precondition(key))]);\n    // Since the delete will be applied before all following writes, we need to\n    // ensure that the precondition for the next write will be exists: false.\n    this.readVersions = this.readVersions.insert(\n      key,\n      SnapshotVersion.forDeletedDoc()\n    );\n  }\n\n  commit(): Promise<void> {\n    let unwritten = this.readVersions;\n    // For each mutation, note that the doc was written.\n    this.mutations.forEach(mutation => {\n      unwritten = unwritten.remove(mutation.key);\n    });\n    if (!unwritten.isEmpty()) {\n      return Promise.reject(\n        Error('Every document read in a transaction must also be written.')\n      );\n    }\n    return this.datastore.commit(this.mutations).then(() => {\n      this.committed = true;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}