{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createSubscribe } from '@firebase/util';\nimport { patchProperty, deepCopy, deepExtend, ErrorFactory } from '@firebase/util';\n\nvar contains = function contains(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]'; // An array to capture listeners before the true auth functions\n// exist\n\nvar tokenListeners = [];\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\n\nvar FirebaseAppImpl =\n/** @class */\nfunction () {\n  function FirebaseAppImpl(options, name, firebase_) {\n    this.firebase_ = firebase_;\n    this.isDeleted_ = false;\n    this.services_ = {};\n    this.name_ = name;\n    this.options_ = deepCopy(options);\n    this.INTERNAL = {\n      getUid: function getUid() {\n        return null;\n      },\n      getToken: function getToken() {\n        return Promise.resolve(null);\n      },\n      addAuthTokenListener: function addAuthTokenListener(callback) {\n        tokenListeners.push(callback); // Make sure callback is called, asynchronously, in the absence of the auth module\n\n        setTimeout(function () {\n          return callback(null);\n        }, 0);\n      },\n      removeAuthTokenListener: function removeAuthTokenListener(callback) {\n        tokenListeners = tokenListeners.filter(function (listener) {\n          return listener !== callback;\n        });\n      }\n    };\n  }\n\n  Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\n    get: function get() {\n      this.checkDestroyed_();\n      return this.name_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\n    get: function get() {\n      this.checkDestroyed_();\n      return this.options_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FirebaseAppImpl.prototype.delete = function () {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.checkDestroyed_();\n\n      resolve();\n    }).then(function () {\n      _this.firebase_.INTERNAL.removeApp(_this.name_);\n\n      var services = [];\n      Object.keys(_this.services_).forEach(function (serviceKey) {\n        Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {\n          services.push(_this.services_[serviceKey][instanceKey]);\n        });\n      });\n      return Promise.all(services.map(function (service) {\n        return service.INTERNAL.delete();\n      }));\n    }).then(function () {\n      _this.isDeleted_ = true;\n      _this.services_ = {};\n    });\n  };\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n\n\n  FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\n    if (instanceIdentifier === void 0) {\n      instanceIdentifier = DEFAULT_ENTRY_NAME;\n    }\n\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;\n      var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  };\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n\n\n  FirebaseAppImpl.prototype.extendApp = function (props) {\n    var _this = this; // Copy the object onto the FirebaseAppImpl prototype\n\n\n    deepExtend(this, props);\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     *\n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should\n     * provide these stubs and the upgrade logic\n     */\n\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(function (listener) {\n        _this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  };\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n\n\n  FirebaseAppImpl.prototype.checkDestroyed_ = function () {\n    if (this.isDeleted_) {\n      error('app-deleted', {\n        name: this.name_\n      });\n    }\n  };\n\n  return FirebaseAppImpl;\n}(); // Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n\n\nFirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log('dc');\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\n\nexport function createFirebaseNamespace() {\n  var apps_ = {};\n  var factories = {};\n  var appHooks = {}; // A namespace is a plain JavaScript Object.\n\n  var namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app,\n    apps: null,\n    Promise: Promise,\n    SDK_VERSION: '4.8.0',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: Promise,\n      deepExtend: deepExtend\n    }\n  }; // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n\n  patchProperty(namespace, 'default', namespace); // firebase.apps is a read-only getter.\n\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n\n  function removeApp(name) {\n    var app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n\n\n  function app(name) {\n    name = name || DEFAULT_ENTRY_NAME;\n\n    if (!contains(apps_, name)) {\n      error('no-app', {\n        name: name\n      });\n    }\n\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n  /**\n   * Create a new App instance (name must be unique).\n   */\n\n  function initializeApp(options, name) {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', {\n          name: name + ''\n        });\n      }\n    }\n\n    if (contains(apps_, name)) {\n      error('duplicate-app', {\n        name: name\n      });\n    }\n\n    var app = new FirebaseAppImpl(options, name, namespace);\n    apps_[name] = app;\n    callAppHooks(app, 'create');\n    return app;\n  }\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n\n\n  function getApps() {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(function (name) {\n      return apps_[name];\n    });\n  }\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n\n\n  function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', {\n        name: name\n      });\n    } // Capture the service factory for later service instantiation\n\n\n    factories[name] = createService; // Capture the appHook, if passed\n\n    if (appHook) {\n      appHooks[name] = appHook; // Run the **new** app hook on all existing apps\n\n      getApps().forEach(function (app) {\n        appHook('create', app);\n      });\n    } // The Service namespace is an accessor function ...\n\n\n    var serviceNamespace = function serviceNamespace(appArg) {\n      if (appArg === void 0) {\n        appArg = app();\n      }\n\n      if (typeof appArg[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', {\n          name: name\n        });\n      } // Forward service instance lookup to the FirebaseApp.\n\n\n      return appArg[name]();\n    }; // ... and a container for service-level properties.\n\n\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    } // Monkey-patch the serviceNamespace onto the firebase namespace\n\n\n    namespace[name] = serviceNamespace; // Patch the FirebaseAppImpl prototype\n\n    FirebaseAppImpl.prototype[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var serviceFxn = this._getService.bind(this, name);\n\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n\n\n  function extendNamespace(props) {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app, eventName) {\n    Object.keys(factories).forEach(function (serviceName) {\n      // Ignore virtual services\n      var factoryName = useAsService(app, serviceName);\n\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  } // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n\n\n  function useAsService(app, name) {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    var useService = name;\n    var options = app.options;\n    return useService;\n  }\n\n  return namespace;\n}\n\nfunction error(code, args) {\n  throw appErrors.create(code, args);\n} // TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\n\n\nvar errors = {\n  'no-app': \"No Firebase App '{$name}' has been created - \" + 'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported': 'Initializing the Firebase SDK with a service ' + 'account is only allowed in a Node.js environment. On client ' + 'devices, you should instead initialize the SDK with an api key and ' + 'auth domain',\n  'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.'\n};\nvar appErrors = new ErrorFactory('app', 'Firebase', errors);","map":{"version":3,"sources":["dist/esm/src/firebaseApp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createSubscribe, Observer, Subscribe } from '@firebase/util';\nimport {\n  patchProperty,\n  deepCopy,\n  deepExtend,\n  ErrorFactory,\n  FirebaseError\n} from '@firebase/util';\n\nexport interface FirebaseAuthTokenData {\n  accessToken: string;\n}\n\nexport interface FirebaseAppInternals {\n  getToken(refreshToken?: boolean): Promise<FirebaseAuthTokenData | null>;\n  getUid(): string | null;\n  addAuthTokenListener(fn: (token: string | null) => void): void;\n  removeAuthTokenListener(fn: (token: string | null) => void): void;\n}\n\nexport type FirebaseOptions = {\n  apiKey?: string;\n  authDomain?: string;\n  databaseURL?: string;\n  projectId?: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  [name: string]: any;\n};\n\n// An instance of the firebase.App\nexport interface FirebaseApp {\n  /**\n   * The (read-only) name (identifier) for this App. '[DEFAULT]' is the default\n   * App.\n   */\n  name: string;\n\n  /**\n   * The (read-only) configuration options from the app initialization.\n   */\n  options: FirebaseOptions;\n\n  /**\n   * Make the given App unusable and free resources.\n   */\n  delete(): Promise<void>;\n\n  INTERNAL: FirebaseAppInternals;\n}\n\nexport interface FirebaseServiceInternals {\n  /**\n   * Delete the service and free it's resources - called from\n   * app.delete().\n   */\n  delete(): Promise<void>;\n}\n\n// Services are exposed through instances - each of which is associated with a\n// FirebaseApp.\nexport interface FirebaseService {\n  app: FirebaseApp;\n  INTERNAL?: FirebaseServiceInternals;\n}\n\nexport type AppHook = (event: string, app: FirebaseApp) => void;\n\n/**\n * Firebase Services create instances given a Firebase App instance and can\n * optionally add properties and methods to each FirebaseApp via the extendApp()\n * function.\n */\nexport interface FirebaseServiceFactory {\n  (\n    app: FirebaseApp,\n    extendApp?: (props: { [prop: string]: any }) => void,\n    instanceString?: string\n  ): FirebaseService;\n}\n\n/**\n * All ServiceNamespaces extend from FirebaseServiceNamespace\n */\nexport interface FirebaseServiceNamespace<T extends FirebaseService> {\n  (app?: FirebaseApp): T;\n}\n\nexport interface FirebaseErrorFactory<T> {\n  create(code: T, data?: { [prop: string]: any }): FirebaseError;\n}\n\nexport interface FirebaseErrorFactoryClass {\n  new (\n    service: string,\n    serviceName: string,\n    errors: { [code: string]: string }\n  ): FirebaseErrorFactory<any>;\n}\n\nexport interface FirebaseNamespace {\n  /**\n   * Create (and intialize) a FirebaseApp.\n   *\n   * @param options Options to configure the services use in the App.\n   * @param name The optional name of the app to initialize ('[DEFAULT]' if\n   *   none)\n   */\n  initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n\n  app: {\n    /**\n     * Retrieve an instance of a FirebaseApp.\n     *\n     * Usage: firebase.app()\n     *\n     * @param name The optional name of the app to return ('[DEFAULT]' if none)\n     */\n    (name?: string): FirebaseApp;\n\n    /**\n     * For testing FirebaseApp instances:\n     *   app() instanceof firebase.app.App\n     * DO NOT call this constuctor directly (use firebase.app() instead).\n     */\n    App: Function;\n  };\n\n  /**\n   * A (read-only) array of all the initialized Apps.\n   */\n  apps: FirebaseApp[];\n\n  // Inherit the type information of our exported Promise implementation from\n  // es6-promises.\n  Promise: typeof Promise;\n\n  // The current SDK version ('${JSCORE_VERSION}').\n  SDK_VERSION: string;\n\n  // TODO: Migrate to firebase-app-internal.d.ts\n  INTERNAL: {\n    /**\n     * Internal API to register a Firebase Service into the firebase namespace.\n     *\n     * Each service will create a child namespace (firease.name) which acts as\n     * both a namespace for service specific properties, and also as a service\n     * accessor function (firebase.name() or firebase.name(app)).\n     *\n     * @param name The Firebase Service being registered.\n     * @param createService Factory function to create a service instance.\n     * @param serviceProperties Properties to copy to the service's namespace.\n     * @param appHook All appHooks called before intializeApp returns to caller.\n     * @param allowMultipleInstances Whether the registered service supports\n     *   multiple instances per app. If not specified, the default is false.\n     */\n    registerService(\n      name: string,\n      createService: FirebaseServiceFactory,\n      serviceProperties?: { [prop: string]: any },\n      appHook?: AppHook,\n      allowMultipleInstances?: boolean\n    ): FirebaseServiceNamespace<FirebaseService>;\n\n    /**\n     * Just used for testing to start from a fresh namespace.\n     */\n    createFirebaseNamespace(): FirebaseNamespace;\n\n    /**\n     * Internal API to install properties on the top-level firebase namespace.\n     * @prop props The top level properties of this object are copied to the\n     *   namespace.\n     */\n    extendNamespace(props: { [prop: string]: any }): void;\n\n    /**\n     * Create a Subscribe function.  A proxy Observer is created so that\n     * events can be sent to single Observer to be fanned out automatically.\n     */\n    createSubscribe<T>(\n      executor: (observer: Observer<T>) => void,\n      onNoObservers?: (observer: Observer<T>) => void\n    ): Subscribe<T>;\n\n    /**\n     * Utility exposed for internal testing.\n     */\n    deepExtend(target: any, source: any): any;\n\n    /**\n     * Internal API to remove an app from the list of registered apps.\n     */\n    removeApp(name: string): void;\n\n    /**\n     * Service factories for each registered service.\n     */\n    factories: { [name: string]: FirebaseServiceFactory };\n\n    /*\n     * Convert service name to factory name to use.\n     */\n    useAsService(app: FirebaseApp, serviceName: string): string | null;\n\n    /**\n     * Use to construct all thrown FirebaseError's.\n     */\n    ErrorFactory: FirebaseErrorFactoryClass;\n  };\n}\n\nconst contains = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nclass FirebaseAppImpl implements FirebaseApp {\n  private options_: FirebaseOptions;\n  private name_: string;\n  private isDeleted_ = false;\n  private services_: {\n    [name: string]: {\n      [serviceName: string]: FirebaseService;\n    };\n  } = {};\n\n  public INTERNAL;\n\n  constructor(\n    options: FirebaseOptions,\n    name: string,\n    private firebase_: FirebaseNamespace\n  ) {\n    this.name_ = name;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      getUid: () => null,\n      getToken: () => Promise.resolve(null),\n      addAuthTokenListener: (callback: (token: string | null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      removeAuthTokenListener: callback => {\n        tokenListeners = tokenListeners.filter(\n          listener => listener !== callback\n        );\n      }\n    };\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new Promise(resolve => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        let services: FirebaseService[] = [];\n        Object.keys(this.services_).forEach(serviceKey => {\n          Object.keys(this.services_[serviceKey]).forEach(instanceKey => {\n            services.push(this.services_[serviceKey][instanceKey]);\n          });\n        });\n        return Promise.all(\n          services.map(service => {\n            return service.INTERNAL!.delete();\n          })\n        );\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier =\n        instanceIdentifier !== DEFAULT_ENTRY_NAME\n          ? instanceIdentifier\n          : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](\n        this,\n        this.extendApp.bind(this),\n        instanceSpecifier\n      );\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: { [name: string]: any }): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     *\n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should\n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error('app-deleted', { name: this.name_ });\n    }\n  }\n}\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log('dc');\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  let apps_: { [name: string]: FirebaseApp } = {};\n  let factories: { [service: string]: FirebaseServiceFactory } = {};\n  let appHooks: { [service: string]: AppHook } = {};\n\n  // A namespace is a plain JavaScript Object.\n  let namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app as any,\n    apps: null as any,\n    Promise: Promise,\n    SDK_VERSION: '${JSCORE_VERSION}',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: Promise,\n      deepExtend: deepExtend\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    let app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', { name: name });\n    }\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', { name: name + '' });\n      }\n    }\n    if (contains(apps_, name)) {\n      error('duplicate-app', { name: name });\n    }\n\n    let app = new FirebaseAppImpl(\n      options,\n      name!,\n      namespace as FirebaseNamespace\n    );\n\n    apps_[name!] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(name => apps_[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n    name: string,\n    createService: FirebaseServiceFactory,\n    serviceProperties?: { [prop: string]: any },\n    appHook?: AppHook,\n    allowMultipleInstances?: boolean\n  ): FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', { name: name });\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    const serviceNamespace = (appArg: FirebaseApp = app()) => {\n      if (typeof (appArg as any)[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', { name: name });\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return (appArg as any)[name]();\n    };\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    (namespace as any)[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: { [prop: string]: any }): void {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    Object.keys(factories).forEach(serviceName => {\n      // Ignore virtual services\n      let factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    let useService = name;\n    let options = app.options;\n\n    return useService;\n  }\n\n  return (namespace as any) as FirebaseNamespace;\n}\n\ntype AppError =\n  | 'no-app'\n  | 'bad-app-name'\n  | 'duplicate-app'\n  | 'app-deleted'\n  | 'duplicate-service'\n  | 'sa-not-supported'\n  | 'invalid-app-argument';\n\nfunction error(code: AppError, args?: { [name: string]: any }) {\n  throw appErrors.create(code, args);\n}\n\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nlet errors: { [code: string]: string } = {\n  'no-app':\n    \"No Firebase App '{$name}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported':\n    'Initializing the Firebase SDK with a service ' +\n    'account is only allowed in a Node.js environment. On client ' +\n    'devices, you should instead initialize the SDK with an api key and ' +\n    'auth domain',\n  'invalid-app-argument':\n    'firebase.{$name}() takes either no argument or a ' +\n    'Firebase App instance.'\n};\n\nlet appErrors = new ErrorFactory<AppError>('app', 'Firebase', errors);\n"]},"metadata":{},"sourceType":"module"}