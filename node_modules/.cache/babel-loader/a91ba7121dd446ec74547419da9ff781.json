{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\n\nvar MemoryMutationQueue =\n/** @class */\nfunction () {\n  function MemoryMutationQueue() {\n    /**\n     * The set of all mutations that have been sent but not yet been applied to\n     * the backend.\n     */\n    this.mutationQueue = [];\n    /** Next value to use when assigning sequential IDs to each mutation batch. */\n\n    this.nextBatchId = 1;\n    /** The highest acknowledged mutation in the queue. */\n\n    this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n    /** The last received stream token from the server, used to acknowledge which\n     * responses the client has processed. Stream tokens are opaque checkpoint\n     * markers whose only real value is their inclusion in the next request.\n     */\n\n    this.lastStreamToken = emptyByteString();\n    /** The garbage collector to notify about potential garbage keys. */\n\n    this.garbageCollector = null;\n    /** An ordered mapping between documents and the mutations batch IDs. */\n\n    this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n  }\n\n  MemoryMutationQueue.prototype.start = function (transaction) {\n    // NOTE: The queue may be shutdown / started multiple times, since we\n    // maintain the queue for the duration of the app session in case a user\n    // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n    // accommodate tests that expect as much), we reset nextBatchId and\n    // highestAcknowledgedBatchId if the queue is empty.\n    if (this.mutationQueue.length === 0) {\n      this.nextBatchId = 1;\n      this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n    }\n\n    assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');\n    return PersistencePromise.resolve();\n  };\n\n  MemoryMutationQueue.prototype.checkEmpty = function (transaction) {\n    return PersistencePromise.resolve(this.mutationQueue.length === 0);\n  };\n\n  MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {\n    return PersistencePromise.resolve(this.nextBatchId);\n  };\n\n  MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n    return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n  };\n\n  MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n    var batchId = batch.batchId;\n    assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n    var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged'); // Verify that the batch in the queue is the one to be acknowledged.\n\n    var check = this.mutationQueue[batchIndex];\n    assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' + batchId + ', got batch ' + check.batchId);\n    assert(!check.isTombstone(), \"Can't acknowledge a previously removed batch\");\n    this.highestAcknowledgedBatchId = batchId;\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  };\n\n  MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {\n    return PersistencePromise.resolve(this.lastStreamToken);\n  };\n\n  MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  };\n\n  MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n    assert(mutations.length !== 0, 'Mutation batches should not be empty');\n    var batchId = this.nextBatchId;\n    this.nextBatchId++;\n\n    if (this.mutationQueue.length > 0) {\n      var prior = this.mutationQueue[this.mutationQueue.length - 1];\n      assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');\n    }\n\n    var batch = new MutationBatch(batchId, localWriteTime, mutations);\n    this.mutationQueue.push(batch); // Track references by document key.\n\n    for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n      var mutation = mutations_1[_i];\n      this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n    }\n\n    return PersistencePromise.resolve(batch);\n  };\n\n  MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n    return PersistencePromise.resolve(this.findMutationBatch(batchId));\n  };\n\n  MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n    var size = this.mutationQueue.length; // All batches with batchId <= this.highestAcknowledgedBatchId have been\n    // acknowledged so the first unacknowledged batch after batchID will have a\n    // batchID larger than both of these values.\n\n    batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId); // The requested batchId may still be out of range so normalize it to the\n    // start of the queue.\n\n    var rawIndex = this.indexOfBatchId(batchId);\n    var index = rawIndex < 0 ? 0 : rawIndex; // Finally return the first non-tombstone batch.\n\n    for (; index < size; index++) {\n      var batch = this.mutationQueue[index];\n\n      if (!batch.isTombstone()) {\n        return PersistencePromise.resolve(batch);\n      }\n    }\n\n    return PersistencePromise.resolve(null);\n  };\n\n  MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n    return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));\n  };\n\n  MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n    var count = this.mutationQueue.length;\n    var endIndex = this.indexOfBatchId(batchId);\n\n    if (endIndex < 0) {\n      endIndex = 0;\n    } else if (endIndex >= count) {\n      endIndex = count;\n    } else {\n      // The endIndex is in the queue so increment to pull everything in the\n      // queue including it.\n      endIndex++;\n    }\n\n    return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));\n  };\n\n  MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n    var _this = this;\n\n    var start = new DocReference(documentKey, 0);\n    var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n    var result = [];\n    this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {\n      assert(documentKey.equals(ref.key), \"Should only iterate over a single key's batches\");\n\n      var batch = _this.findMutationBatch(ref.targetOrBatchId);\n\n      assert(batch !== null, 'Batches in the index must exist in the main table');\n      result.push(batch);\n    });\n    return PersistencePromise.resolve(result);\n  };\n\n  MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n    var _this = this; // Use the query path as a prefix for testing if a document matches the\n    // query.\n\n\n    var prefix = query.path;\n    var immediateChildrenPathLength = prefix.length + 1; // Construct a document reference for actually scanning the index. Unlike\n    // the prefix the document key in this reference must have an even number of\n    // segments. The empty segment can be used a suffix of the query path\n    // because it precedes all other segments in an ordered traversal.\n\n    var startPath = prefix;\n\n    if (!DocumentKey.isDocumentKey(startPath)) {\n      startPath = startPath.child('');\n    }\n\n    var start = new DocReference(new DocumentKey(startPath), 0); // Find unique batchIDs referenced by all documents potentially matching the\n    // query.\n\n    var uniqueBatchIDs = new SortedSet(primitiveComparator);\n    this.batchesByDocumentKey.forEachWhile(function (ref) {\n      var rowKeyPath = ref.key.path;\n\n      if (!prefix.isPrefixOf(rowKeyPath)) {\n        return false;\n      } else {\n        // Rows with document keys more than one segment longer than the query\n        // path can't be matches. For example, a query on 'rooms' can't match\n        // the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (rowKeyPath.length === immediateChildrenPathLength) {\n          uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n        }\n\n        return true;\n      }\n    }, start); // Construct an array of matching batches, sorted by batchID to ensure that\n    // multiple mutations affecting the same document key are applied in order.\n\n    var result = [];\n    uniqueBatchIDs.forEach(function (batchId) {\n      var batch = _this.findMutationBatch(batchId);\n\n      if (batch !== null) {\n        result.push(batch);\n      }\n    });\n    return PersistencePromise.resolve(result);\n  };\n\n  MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n    var batchCount = batches.length;\n    assert(batchCount > 0, 'Should not remove mutations when none exist.');\n    var firstBatchId = batches[0].batchId;\n    var queueCount = this.mutationQueue.length; // Find the position of the first batch for removal. This need not be the\n    // first entry in the queue.\n\n    var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n    assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue'); // Check that removed batches are contiguous (while excluding tombstones).\n\n    var batchIndex = 1;\n    var queueIndex = startIndex + 1;\n\n    while (batchIndex < batchCount && queueIndex < queueCount) {\n      var batch = this.mutationQueue[queueIndex];\n\n      if (batch.isTombstone()) {\n        queueIndex++;\n        continue;\n      }\n\n      assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');\n      batchIndex++;\n      queueIndex++;\n    } // Only actually remove batches if removing at the front of the queue.\n    // Previously rejected batches may have left tombstones in the queue, so\n    // expand the removal range to include any tombstones.\n\n\n    if (startIndex === 0) {\n      for (; queueIndex < queueCount; queueIndex++) {\n        var batch = this.mutationQueue[queueIndex];\n\n        if (!batch.isTombstone()) {\n          break;\n        }\n      }\n\n      var length_1 = queueIndex - startIndex;\n      this.mutationQueue.splice(startIndex, length_1);\n    } else {\n      // Mark the tombstones\n      for (var i = startIndex; i < queueIndex; i++) {\n        this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n      }\n    }\n\n    var references = this.batchesByDocumentKey;\n\n    for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n      var batch = batches_1[_i];\n      var batchId = batch.batchId;\n\n      for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n        var mutation = _b[_a];\n        var key = mutation.key;\n\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(key);\n        }\n\n        var ref = new DocReference(key, batchId);\n        references = references.delete(ref);\n      }\n    }\n\n    this.batchesByDocumentKey = references;\n    return PersistencePromise.resolve();\n  };\n\n  MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {\n    this.garbageCollector = garbageCollector;\n  };\n\n  MemoryMutationQueue.prototype.containsKey = function (txn, key) {\n    var ref = new DocReference(key, 0);\n    var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n  };\n\n  MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {\n    if (this.mutationQueue.length === 0) {\n      assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');\n    }\n\n    return PersistencePromise.resolve();\n  };\n  /**\n   * A private helper that collects all the mutations batches in the queue up to\n   * but not including the given endIndex. All tombstones in the queue are\n   * excluded.\n   */\n\n\n  MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {\n    var result = [];\n\n    for (var i = 0; i < endIndex; i++) {\n      var batch = this.mutationQueue[i];\n\n      if (!batch.isTombstone()) {\n        result.push(batch);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Finds the index of the given batchId in the mutation queue and asserts that\n   * the resulting index is within the bounds of the queue.\n   *\n   * @param batchId The batchId to search for\n   * @param action A description of what the caller is doing, phrased in passive\n   * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n   */\n\n\n  MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {\n    var index = this.indexOfBatchId(batchId);\n    assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);\n    return index;\n  };\n  /**\n   * Finds the index of the given batchId in the mutation queue. This operation\n   * is O(1).\n   *\n   * @return The computed index of the batch with the given batchId, based on\n   * the state of the queue. Note this index can be negative if the requested\n   * batchId has already been remvoed from the queue or past the end of the\n   * queue if the batchId is larger than the last added batch.\n   */\n\n\n  MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {\n    if (this.mutationQueue.length === 0) {\n      // As an index this is past the end of the queue\n      return 0;\n    } // Examine the front of the queue to figure out the difference between the\n    // batchId and indexes in the array. Note that since the queue is ordered\n    // by batchId, if the first batch has a larger batchId then the requested\n    // batchId doesn't exist in the queue.\n\n\n    var firstBatchId = this.mutationQueue[0].batchId;\n    return batchId - firstBatchId;\n  };\n  /**\n   * A version of lookupMutationBatch that doesn't return a promise, this makes\n   * other functions that uses this code easier to read and more efficent.\n   */\n\n\n  MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {\n    var index = this.indexOfBatchId(batchId);\n\n    if (index < 0 || index >= this.mutationQueue.length) {\n      return null;\n    }\n\n    var batch = this.mutationQueue[index];\n    assert(batch.batchId === batchId, 'If found batch must match');\n    return batch.isTombstone() ? null : batch;\n  };\n\n  return MemoryMutationQueue;\n}();\n\nexport { MemoryMutationQueue };","map":{"version":3,"sources":["../src/local/memory_mutation_queue.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAKH,SAAS,WAAT,QAA4B,uBAA5B;AAEA,SAAS,eAAT,EAA0B,aAA1B,QAA+C,yBAA/C;AACA,SAAS,eAAT,QAAgC,sBAAhC;AACA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,mBAAT,QAAoC,cAApC;AACA,SAAS,SAAT,QAA0B,oBAA1B;AAKA,SAAS,kBAAT,QAAmC,uBAAnC;AACA,SAAS,YAAT,QAA6B,iBAA7B;;AAEA,IAAA,mBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,mBAAA,GAAA;AACE;;;AAGG;AACK,SAAA,aAAA,GAAiC,EAAjC;AAER;;AACQ,SAAA,WAAA,GAAuB,CAAvB;AAER;;AACQ,SAAA,0BAAA,GAAsC,eAAtC;AAER;;;AAGG;;AACK,SAAA,eAAA,GAAmC,eAAe,EAAlD;AAER;;AACQ,SAAA,gBAAA,GAA4C,IAA5C;AAER;;AACQ,SAAA,oBAAA,GAAuB,IAAI,SAAJ,CAAc,YAAY,CAAC,YAA3B,CAAvB;AAsaT;;AApaC,EAAA,mBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,WAAN,EAAyC;AACvC;AACA;AACA;AACA;AACA;AACA,QAAI,KAAK,aAAL,CAAmB,MAAnB,KAA8B,CAAlC,EAAqC;AACnC,WAAK,WAAL,GAAmB,CAAnB;AACA,WAAK,0BAAL,GAAkC,eAAlC;AACD;;AACD,IAAA,MAAM,CACJ,KAAK,0BAAL,GAAkC,KAAK,WADnC,EAEJ,8DAFI,CAAN;AAIA,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GAfD;;AAiBA,EAAA,mBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,WAAX,EAA8C;AAC5C,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAAK,aAAL,CAAmB,MAAnB,KAA8B,CAAzD,CAAP;AACD,GAFD;;AAIA,EAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UACE,WADF,EACqC;AAEnC,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAAK,WAAhC,CAAP;AACD,GAJD;;AAMA,EAAA,mBAAA,CAAA,SAAA,CAAA,6BAAA,GAAA,UACE,WADF,EACqC;AAEnC,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAAK,0BAAhC,CAAP;AACD,GAJD;;AAMA,EAAA,mBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UACE,WADF,EAEE,KAFF,EAGE,WAHF,EAG8B;AAE5B,QAAM,OAAO,GAAG,KAAK,CAAC,OAAtB;AACA,IAAA,MAAM,CACJ,OAAO,GAAG,KAAK,0BADX,EAEJ,iDAFI,CAAN;AAKA,QAAM,UAAU,GAAG,KAAK,sBAAL,CAA4B,OAA5B,EAAqC,cAArC,CAAnB,CAR4B,CAU5B;;AACA,QAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,UAAnB,CAAd;AACA,IAAA,MAAM,CACJ,OAAO,KAAK,KAAK,CAAC,OADd,EAEJ,4CACE,OADF,GAEE,cAFF,GAGE,KAAK,CAAC,OALJ,CAAN;AAOA,IAAA,MAAM,CACJ,CAAC,KAAK,CAAC,WAAN,EADG,EAEJ,8CAFI,CAAN;AAKA,SAAK,0BAAL,GAAkC,OAAlC;AACA,SAAK,eAAL,GAAuB,WAAvB;AACA,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GA9BD;;AAgCA,EAAA,mBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UACE,WADF,EACqC;AAEnC,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAAK,eAAhC,CAAP;AACD,GAJD;;AAMA,EAAA,mBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE8B;AAE5B,SAAK,eAAL,GAAuB,WAAvB;AACA,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GAND;;AAQA,EAAA,mBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UACE,WADF,EAEE,cAFF,EAGE,SAHF,EAGuB;AAErB,IAAA,MAAM,CAAC,SAAS,CAAC,MAAV,KAAqB,CAAtB,EAAyB,sCAAzB,CAAN;AAEA,QAAM,OAAO,GAAG,KAAK,WAArB;AACA,SAAK,WAAL;;AAEA,QAAI,KAAK,aAAL,CAAmB,MAAnB,GAA4B,CAAhC,EAAmC;AACjC,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,KAAK,aAAL,CAAmB,MAAnB,GAA4B,CAA/C,CAAd;AACA,MAAA,MAAM,CACJ,KAAK,CAAC,OAAN,GAAgB,OADZ,EAEJ,0DAFI,CAAN;AAID;;AAED,QAAM,KAAK,GAAG,IAAI,aAAJ,CAAkB,OAAlB,EAA2B,cAA3B,EAA2C,SAA3C,CAAd;AACA,SAAK,aAAL,CAAmB,IAAnB,CAAwB,KAAxB,EAhBqB,CAkBrB;;AACA,SAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,WAAA,GAAA,SAAvB,EAAuB,EAAA,GAAA,WAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAAgC;AAA3B,UAAM,QAAQ,GAAA,WAAA,CAAA,EAAA,CAAd;AACH,WAAK,oBAAL,GAA4B,KAAK,oBAAL,CAA0B,GAA1B,CAC1B,IAAI,YAAJ,CAAiB,QAAQ,CAAC,GAA1B,EAA+B,OAA/B,CAD0B,CAA5B;AAGD;;AAED,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAA3B,CAAP;AACD,GA7BD;;AA+BA,EAAA,mBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UACE,WADF,EAEE,OAFF,EAEkB;AAEhB,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAAK,iBAAL,CAAuB,OAAvB,CAA3B,CAAP;AACD,GALD;;AAOA,EAAA,mBAAA,CAAA,SAAA,CAAA,gCAAA,GAAA,UACE,WADF,EAEE,OAFF,EAEkB;AAEhB,QAAM,IAAI,GAAG,KAAK,aAAL,CAAmB,MAAhC,CAFgB,CAIhB;AACA;AACA;;AACA,IAAA,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,OAAO,GAAG,CAAnB,EAAsB,KAAK,0BAA3B,CAAV,CAPgB,CAShB;AACA;;AACA,QAAM,QAAQ,GAAG,KAAK,cAAL,CAAoB,OAApB,CAAjB;AACA,QAAI,KAAK,GAAG,QAAQ,GAAG,CAAX,GAAe,CAAf,GAAmB,QAA/B,CAZgB,CAchB;;AACA,WAAO,KAAK,GAAG,IAAf,EAAqB,KAAK,EAA1B,EAA8B;AAC5B,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,KAAnB,CAAd;;AACA,UAAI,CAAC,KAAK,CAAC,WAAN,EAAL,EAA0B;AACxB,eAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAA3B,CAAP;AACD;AACF;;AACD,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,IAA3B,CAAP;AACD,GAxBD;;AA0BA,EAAA,mBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UACE,WADF,EACqC;AAEnC,WAAO,kBAAkB,CAAC,OAAnB,CACL,KAAK,oCAAL,CAA0C,KAAK,aAAL,CAAmB,MAA7D,CADK,CAAP;AAGD,GAND;;AAQA,EAAA,mBAAA,CAAA,SAAA,CAAA,mCAAA,GAAA,UACE,WADF,EAEE,OAFF,EAEkB;AAEhB,QAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,MAAjC;AAEA,QAAI,QAAQ,GAAG,KAAK,cAAL,CAAoB,OAApB,CAAf;;AACA,QAAI,QAAQ,GAAG,CAAf,EAAkB;AAChB,MAAA,QAAQ,GAAG,CAAX;AACD,KAFD,MAEO,IAAI,QAAQ,IAAI,KAAhB,EAAuB;AAC5B,MAAA,QAAQ,GAAG,KAAX;AACD,KAFM,MAEA;AACL;AACA;AACA,MAAA,QAAQ;AACT;;AAED,WAAO,kBAAkB,CAAC,OAAnB,CACL,KAAK,oCAAL,CAA0C,QAA1C,CADK,CAAP;AAGD,GApBD;;AAsBA,EAAA,mBAAA,CAAA,SAAA,CAAA,yCAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE0B;AAF1B,QAAA,KAAA,GAAA,IAAA;;AAIE,QAAM,KAAK,GAAG,IAAI,YAAJ,CAAiB,WAAjB,EAA8B,CAA9B,CAAd;AACA,QAAM,GAAG,GAAG,IAAI,YAAJ,CAAiB,WAAjB,EAA8B,MAAM,CAAC,iBAArC,CAAZ;AACA,QAAM,MAAM,GAAoB,EAAhC;AACA,SAAK,oBAAL,CAA0B,cAA1B,CAAyC,CAAC,KAAD,EAAQ,GAAR,CAAzC,EAAuD,UAAA,GAAA,EAAG;AACxD,MAAA,MAAM,CACJ,WAAW,CAAC,MAAZ,CAAmB,GAAG,CAAC,GAAvB,CADI,EAEJ,iDAFI,CAAN;;AAIA,UAAM,KAAK,GAAG,KAAI,CAAC,iBAAL,CAAuB,GAAG,CAAC,eAA3B,CAAd;;AACA,MAAA,MAAM,CACJ,KAAK,KAAK,IADN,EAEJ,mDAFI,CAAN;AAIA,MAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACD,KAXD;AAaA,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,MAA3B,CAAP;AACD,GArBD;;AAuBA,EAAA,mBAAA,CAAA,SAAA,CAAA,mCAAA,GAAA,UACE,WADF,EAEE,KAFF,EAEc;AAFd,QAAA,KAAA,GAAA,IAAA,CAEc,CAEZ;AACA;;;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,IAArB;AACA,QAAM,2BAA2B,GAAG,MAAM,CAAC,MAAP,GAAgB,CAApD,CALY,CAOZ;AACA;AACA;AACA;;AACA,QAAI,SAAS,GAAG,MAAhB;;AACA,QAAI,CAAC,WAAW,CAAC,aAAZ,CAA0B,SAA1B,CAAL,EAA2C;AACzC,MAAA,SAAS,GAAG,SAAS,CAAC,KAAV,CAAgB,EAAhB,CAAZ;AACD;;AAED,QAAM,KAAK,GAAG,IAAI,YAAJ,CAAiB,IAAI,WAAJ,CAAgB,SAAhB,CAAjB,EAA6C,CAA7C,CAAd,CAhBY,CAkBZ;AACA;;AACA,QAAI,cAAc,GAAG,IAAI,SAAJ,CAAsB,mBAAtB,CAArB;AAEA,SAAK,oBAAL,CAA0B,YAA1B,CAAuC,UAAA,GAAA,EAAG;AACxC,UAAM,UAAU,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAA3B;;AACA,UAAI,CAAC,MAAM,CAAC,UAAP,CAAkB,UAAlB,CAAL,EAAoC;AAClC,eAAO,KAAP;AACD,OAFD,MAEO;AACL;AACA;AACA;AACA;AACA;AACA,YAAI,UAAU,CAAC,MAAX,KAAsB,2BAA1B,EAAuD;AACrD,UAAA,cAAc,GAAG,cAAc,CAAC,GAAf,CAAmB,GAAG,CAAC,eAAvB,CAAjB;AACD;;AACD,eAAO,IAAP;AACD;AACF,KAfD,EAeG,KAfH,EAtBY,CAuCZ;AACA;;AACA,QAAM,MAAM,GAAoB,EAAhC;AACA,IAAA,cAAc,CAAC,OAAf,CAAuB,UAAA,OAAA,EAAO;AAC5B,UAAM,KAAK,GAAG,KAAI,CAAC,iBAAL,CAAuB,OAAvB,CAAd;;AACA,UAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,QAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACD;AACF,KALD;AAMA,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,MAA3B,CAAP;AACD,GAnDD;;AAqDA,EAAA,mBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UACE,WADF,EAEE,OAFF,EAE0B;AAExB,QAAM,UAAU,GAAG,OAAO,CAAC,MAA3B;AACA,IAAA,MAAM,CAAC,UAAU,GAAG,CAAd,EAAiB,8CAAjB,CAAN;AAEA,QAAM,YAAY,GAAG,OAAO,CAAC,CAAD,CAAP,CAAW,OAAhC;AACA,QAAM,UAAU,GAAG,KAAK,aAAL,CAAmB,MAAtC,CANwB,CAQxB;AACA;;AACA,QAAM,UAAU,GAAG,KAAK,sBAAL,CAA4B,YAA5B,EAA0C,SAA1C,CAAnB;AACA,IAAA,MAAM,CACJ,KAAK,aAAL,CAAmB,UAAnB,EAA+B,OAA/B,KAA2C,YADvC,EAEJ,yCAFI,CAAN,CAXwB,CAgBxB;;AACA,QAAI,UAAU,GAAG,CAAjB;AACA,QAAI,UAAU,GAAG,UAAU,GAAG,CAA9B;;AACA,WAAO,UAAU,GAAG,UAAb,IAA2B,UAAU,GAAG,UAA/C,EAA2D;AACzD,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,UAAnB,CAAd;;AACA,UAAI,KAAK,CAAC,WAAN,EAAJ,EAAyB;AACvB,QAAA,UAAU;AACV;AACD;;AAED,MAAA,MAAM,CACJ,KAAK,CAAC,OAAN,KAAkB,OAAO,CAAC,UAAD,CAAP,CAAoB,OADlC,EAEJ,iDAFI,CAAN;AAIA,MAAA,UAAU;AACV,MAAA,UAAU;AACX,KAhCuB,CAkCxB;AACA;AACA;;;AACA,QAAI,UAAU,KAAK,CAAnB,EAAsB;AACpB,aAAO,UAAU,GAAG,UAApB,EAAgC,UAAU,EAA1C,EAA8C;AAC5C,YAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,UAAnB,CAAd;;AACA,YAAI,CAAC,KAAK,CAAC,WAAN,EAAL,EAA0B;AACxB;AACD;AACF;;AACD,UAAM,QAAM,GAAG,UAAU,GAAG,UAA5B;AACA,WAAK,aAAL,CAAmB,MAAnB,CAA0B,UAA1B,EAAsC,QAAtC;AACD,KATD,MASO;AACL;AACA,WAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,UAA7B,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,aAAK,aAAL,CAAmB,CAAnB,IAAwB,KAAK,aAAL,CAAmB,CAAnB,EAAsB,WAAtB,EAAxB;AACD;AACF;;AAED,QAAI,UAAU,GAAG,KAAK,oBAAtB;;AACA,SAAoB,IAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,OAApB,EAAoB,EAAA,GAAA,SAAA,CAAA,MAApB,EAAoB,EAAA,EAApB,EAA2B;AAAtB,UAAM,KAAK,GAAA,SAAA,CAAA,EAAA,CAAX;AACH,UAAM,OAAO,GAAG,KAAK,CAAC,OAAtB;;AACA,WAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,CAAC,SAA7B,EAAuB,EAAA,GAAA,EAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAAsC;AAAjC,YAAM,QAAQ,GAAA,EAAA,CAAA,EAAA,CAAd;AACH,YAAM,GAAG,GAAG,QAAQ,CAAC,GAArB;;AACA,YAAI,KAAK,gBAAL,KAA0B,IAA9B,EAAoC;AAClC,eAAK,gBAAL,CAAsB,sBAAtB,CAA6C,GAA7C;AACD;;AAED,YAAM,GAAG,GAAG,IAAI,YAAJ,CAAiB,GAAjB,EAAsB,OAAtB,CAAZ;AACA,QAAA,UAAU,GAAG,UAAU,CAAC,MAAX,CAAkB,GAAlB,CAAb;AACD;AACF;;AACD,SAAK,oBAAL,GAA4B,UAA5B;AACA,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GAtED;;AAwEA,EAAA,mBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,gBAApB,EAA6D;AAC3D,SAAK,gBAAL,GAAwB,gBAAxB;AACD,GAFD;;AAIA,EAAA,mBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UACE,GADF,EAEE,GAFF,EAEkB;AAEhB,QAAM,GAAG,GAAG,IAAI,YAAJ,CAAiB,GAAjB,EAAsB,CAAtB,CAAZ;AACA,QAAM,QAAQ,GAAG,KAAK,oBAAL,CAA0B,iBAA1B,CAA4C,GAA5C,CAAjB;AACA,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,GAAG,CAAC,MAAJ,CAAW,QAAQ,IAAI,QAAQ,CAAC,GAAhC,CAA3B,CAAP;AACD,GAPD;;AASA,EAAA,mBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UACE,GADF,EAC6B;AAE3B,QAAI,KAAK,aAAL,CAAmB,MAAnB,KAA8B,CAAlC,EAAqC;AACnC,MAAA,MAAM,CACJ,KAAK,oBAAL,CAA0B,OAA1B,EADI,EAEJ,6EAFI,CAAN;AAID;;AACD,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GAVD;AAYA;;;;AAIG;;;AACK,EAAA,mBAAA,CAAA,SAAA,CAAA,oCAAA,GAAR,UACE,QADF,EACkB;AAEhB,QAAM,MAAM,GAAoB,EAAhC;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AACjC,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,CAAnB,CAAd;;AACA,UAAI,CAAC,KAAK,CAAC,WAAN,EAAL,EAA0B;AACxB,QAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACD;AACF;;AAED,WAAO,MAAP;AACD,GAbO;AAeR;;;;;;;AAOG;;;AACK,EAAA,mBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,OAA/B,EAAiD,MAAjD,EAA+D;AAC7D,QAAM,KAAK,GAAG,KAAK,cAAL,CAAoB,OAApB,CAAd;AACA,IAAA,MAAM,CACJ,KAAK,IAAI,CAAT,IAAc,KAAK,GAAG,KAAK,aAAL,CAAmB,MADrC,EAEJ,8BAA8B,MAF1B,CAAN;AAIA,WAAO,KAAP;AACD,GAPO;AASR;;;;;;;;AAQG;;;AACK,EAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAR,UAAuB,OAAvB,EAAuC;AACrC,QAAI,KAAK,aAAL,CAAmB,MAAnB,KAA8B,CAAlC,EAAqC;AACnC;AACA,aAAO,CAAP;AACD,KAJoC,CAMrC;AACA;AACA;AACA;;;AACA,QAAM,YAAY,GAAG,KAAK,aAAL,CAAmB,CAAnB,EAAsB,OAA3C;AACA,WAAO,OAAO,GAAG,YAAjB;AACD,GAZO;AAcR;;;AAGG;;;AACK,EAAA,mBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,OAA1B,EAA0C;AACxC,QAAM,KAAK,GAAG,KAAK,cAAL,CAAoB,OAApB,CAAd;;AACA,QAAI,KAAK,GAAG,CAAR,IAAa,KAAK,IAAI,KAAK,aAAL,CAAmB,MAA7C,EAAqD;AACnD,aAAO,IAAP;AACD;;AAED,QAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,KAAnB,CAAd;AACA,IAAA,MAAM,CAAC,KAAK,CAAC,OAAN,KAAkB,OAAnB,EAA4B,2BAA5B,CAAN;AACA,WAAO,KAAK,CAAC,WAAN,KAAsB,IAAtB,GAA6B,KAApC;AACD,GATO;;AAUV,SAAA,mBAAA;AAAC,CA7bD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\n\nexport class MemoryMutationQueue implements MutationQueue {\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  private mutationQueue: MutationBatch[] = [];\n\n  /** Next value to use when assigning sequential IDs to each mutation batch. */\n  private nextBatchId: BatchId = 1;\n\n  /** The highest acknowledged mutation in the queue. */\n  private highestAcknowledgedBatchId: BatchId = BATCHID_UNKNOWN;\n\n  /** The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   */\n  private lastStreamToken: ProtoByteString = emptyByteString();\n\n  /** The garbage collector to notify about potential garbage keys. */\n  private garbageCollector: GarbageCollector | null = null;\n\n  /** An ordered mapping between documents and the mutations batch IDs. */\n  private batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    // NOTE: The queue may be shutdown / started multiple times, since we\n    // maintain the queue for the duration of the app session in case a user\n    // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n    // accommodate tests that expect as much), we reset nextBatchId and\n    // highestAcknowledgedBatchId if the queue is empty.\n    if (this.mutationQueue.length === 0) {\n      this.nextBatchId = 1;\n      this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n    }\n    assert(\n      this.highestAcknowledgedBatchId < this.nextBatchId,\n      'highestAcknowledgedBatchId must be less than the nextBatchId'\n    );\n    return PersistencePromise.resolve();\n  }\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    return PersistencePromise.resolve(this.mutationQueue.length === 0);\n  }\n\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.nextBatchId);\n  }\n\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n  }\n\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    const batchId = batch.batchId;\n    assert(\n      batchId > this.highestAcknowledgedBatchId,\n      'Mutation batchIDs must be acknowledged in order'\n    );\n\n    const batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n\n    // Verify that the batch in the queue is the one to be acknowledged.\n    const check = this.mutationQueue[batchIndex];\n    assert(\n      batchId === check.batchId,\n      'Queue ordering failure: expected batch ' +\n        batchId +\n        ', got batch ' +\n        check.batchId\n    );\n    assert(\n      !check.isTombstone(),\n      \"Can't acknowledge a previously removed batch\"\n    );\n\n    this.highestAcknowledgedBatchId = batchId;\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  }\n\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString> {\n    return PersistencePromise.resolve(this.lastStreamToken);\n  }\n\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    assert(mutations.length !== 0, 'Mutation batches should not be empty');\n\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n\n    if (this.mutationQueue.length > 0) {\n      const prior = this.mutationQueue[this.mutationQueue.length - 1];\n      assert(\n        prior.batchId < batchId,\n        'Mutation batchIDs must be monotonically increasing order'\n      );\n    }\n\n    const batch = new MutationBatch(batchId, localWriteTime, mutations);\n    this.mutationQueue.push(batch);\n\n    // Track references by document key.\n    for (const mutation of mutations) {\n      this.batchesByDocumentKey = this.batchesByDocumentKey.add(\n        new DocReference(mutation.key, batchId)\n      );\n    }\n\n    return PersistencePromise.resolve(batch);\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return PersistencePromise.resolve(this.findMutationBatch(batchId));\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const size = this.mutationQueue.length;\n\n    // All batches with batchId <= this.highestAcknowledgedBatchId have been\n    // acknowledged so the first unacknowledged batch after batchID will have a\n    // batchID larger than both of these values.\n    batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);\n\n    // The requested batchId may still be out of range so normalize it to the\n    // start of the queue.\n    const rawIndex = this.indexOfBatchId(batchId);\n    let index = rawIndex < 0 ? 0 : rawIndex;\n\n    // Finally return the first non-tombstone batch.\n    for (; index < size; index++) {\n      const batch = this.mutationQueue[index];\n      if (!batch.isTombstone()) {\n        return PersistencePromise.resolve(batch);\n      }\n    }\n    return PersistencePromise.resolve(null);\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    return PersistencePromise.resolve(\n      this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length)\n    );\n  }\n\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]> {\n    const count = this.mutationQueue.length;\n\n    let endIndex = this.indexOfBatchId(batchId);\n    if (endIndex < 0) {\n      endIndex = 0;\n    } else if (endIndex >= count) {\n      endIndex = count;\n    } else {\n      // The endIndex is in the queue so increment to pull everything in the\n      // queue including it.\n      endIndex++;\n    }\n\n    return PersistencePromise.resolve(\n      this.getAllLiveMutationBatchesBeforeIndex(endIndex)\n    );\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    const start = new DocReference(documentKey, 0);\n    const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n    const result: MutationBatch[] = [];\n    this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n      assert(\n        documentKey.equals(ref.key),\n        \"Should only iterate over a single key's batches\"\n      );\n      const batch = this.findMutationBatch(ref.targetOrBatchId);\n      assert(\n        batch !== null,\n        'Batches in the index must exist in the main table'\n      );\n      result.push(batch!);\n    });\n\n    return PersistencePromise.resolve(result);\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    // Use the query path as a prefix for testing if a document matches the\n    // query.\n    const prefix = query.path;\n    const immediateChildrenPathLength = prefix.length + 1;\n\n    // Construct a document reference for actually scanning the index. Unlike\n    // the prefix the document key in this reference must have an even number of\n    // segments. The empty segment can be used a suffix of the query path\n    // because it precedes all other segments in an ordered traversal.\n    let startPath = prefix;\n    if (!DocumentKey.isDocumentKey(startPath)) {\n      startPath = startPath.child('');\n    }\n\n    const start = new DocReference(new DocumentKey(startPath), 0);\n\n    // Find unique batchIDs referenced by all documents potentially matching the\n    // query.\n    let uniqueBatchIDs = new SortedSet<number>(primitiveComparator);\n\n    this.batchesByDocumentKey.forEachWhile(ref => {\n      const rowKeyPath = ref.key.path;\n      if (!prefix.isPrefixOf(rowKeyPath)) {\n        return false;\n      } else {\n        // Rows with document keys more than one segment longer than the query\n        // path can't be matches. For example, a query on 'rooms' can't match\n        // the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (rowKeyPath.length === immediateChildrenPathLength) {\n          uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n        }\n        return true;\n      }\n    }, start);\n\n    // Construct an array of matching batches, sorted by batchID to ensure that\n    // multiple mutations affecting the same document key are applied in order.\n    const result: MutationBatch[] = [];\n    uniqueBatchIDs.forEach(batchId => {\n      const batch = this.findMutationBatch(batchId);\n      if (batch !== null) {\n        result.push(batch);\n      }\n    });\n    return PersistencePromise.resolve(result);\n  }\n\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void> {\n    const batchCount = batches.length;\n    assert(batchCount > 0, 'Should not remove mutations when none exist.');\n\n    const firstBatchId = batches[0].batchId;\n    const queueCount = this.mutationQueue.length;\n\n    // Find the position of the first batch for removal. This need not be the\n    // first entry in the queue.\n    const startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n    assert(\n      this.mutationQueue[startIndex].batchId === firstBatchId,\n      'Removed batches must exist in the queue'\n    );\n\n    // Check that removed batches are contiguous (while excluding tombstones).\n    let batchIndex = 1;\n    let queueIndex = startIndex + 1;\n    while (batchIndex < batchCount && queueIndex < queueCount) {\n      const batch = this.mutationQueue[queueIndex];\n      if (batch.isTombstone()) {\n        queueIndex++;\n        continue;\n      }\n\n      assert(\n        batch.batchId === batches[batchIndex].batchId,\n        'Removed batches must be contiguous in the queue'\n      );\n      batchIndex++;\n      queueIndex++;\n    }\n\n    // Only actually remove batches if removing at the front of the queue.\n    // Previously rejected batches may have left tombstones in the queue, so\n    // expand the removal range to include any tombstones.\n    if (startIndex === 0) {\n      for (; queueIndex < queueCount; queueIndex++) {\n        const batch = this.mutationQueue[queueIndex];\n        if (!batch.isTombstone()) {\n          break;\n        }\n      }\n      const length = queueIndex - startIndex;\n      this.mutationQueue.splice(startIndex, length);\n    } else {\n      // Mark the tombstones\n      for (let i = startIndex; i < queueIndex; i++) {\n        this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n      }\n    }\n\n    let references = this.batchesByDocumentKey;\n    for (const batch of batches) {\n      const batchId = batch.batchId;\n      for (const mutation of batch.mutations) {\n        const key = mutation.key;\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(key);\n        }\n\n        const ref = new DocReference(key, batchId);\n        references = references.delete(ref);\n      }\n    }\n    this.batchesByDocumentKey = references;\n    return PersistencePromise.resolve();\n  }\n\n  setGarbageCollector(garbageCollector: GarbageCollector | null): void {\n    this.garbageCollector = garbageCollector;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    if (this.mutationQueue.length === 0) {\n      assert(\n        this.batchesByDocumentKey.isEmpty(),\n        'Document leak -- detected dangling mutation references when queue is empty.'\n      );\n    }\n    return PersistencePromise.resolve();\n  }\n\n  /**\n   * A private helper that collects all the mutations batches in the queue up to\n   * but not including the given endIndex. All tombstones in the queue are\n   * excluded.\n   */\n  private getAllLiveMutationBatchesBeforeIndex(\n    endIndex: number\n  ): MutationBatch[] {\n    const result: MutationBatch[] = [];\n\n    for (let i = 0; i < endIndex; i++) {\n      const batch = this.mutationQueue[i];\n      if (!batch.isTombstone()) {\n        result.push(batch);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue and asserts that\n   * the resulting index is within the bounds of the queue.\n   *\n   * @param batchId The batchId to search for\n   * @param action A description of what the caller is doing, phrased in passive\n   * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n   */\n  private indexOfExistingBatchId(batchId: BatchId, action: string): number {\n    const index = this.indexOfBatchId(batchId);\n    assert(\n      index >= 0 && index < this.mutationQueue.length,\n      'Batches must exist to be ' + action\n    );\n    return index;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue. This operation\n   * is O(1).\n   *\n   * @return The computed index of the batch with the given batchId, based on\n   * the state of the queue. Note this index can be negative if the requested\n   * batchId has already been remvoed from the queue or past the end of the\n   * queue if the batchId is larger than the last added batch.\n   */\n  private indexOfBatchId(batchId: BatchId): number {\n    if (this.mutationQueue.length === 0) {\n      // As an index this is past the end of the queue\n      return 0;\n    }\n\n    // Examine the front of the queue to figure out the difference between the\n    // batchId and indexes in the array. Note that since the queue is ordered\n    // by batchId, if the first batch has a larger batchId then the requested\n    // batchId doesn't exist in the queue.\n    const firstBatchId = this.mutationQueue[0].batchId;\n    return batchId - firstBatchId;\n  }\n\n  /**\n   * A version of lookupMutationBatch that doesn't return a promise, this makes\n   * other functions that uses this code easier to read and more efficent.\n   */\n  private findMutationBatch(batchId: BatchId): MutationBatch | null {\n    const index = this.indexOfBatchId(batchId);\n    if (index < 0 || index >= this.mutationQueue.length) {\n      return null;\n    }\n\n    const batch = this.mutationQueue[index];\n    assert(batch.batchId === batchId, 'If found batch must match');\n    return batch.isTombstone() ? null : batch;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}