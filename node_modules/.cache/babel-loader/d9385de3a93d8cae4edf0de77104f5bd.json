{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet, documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\n\nvar LocalDocumentsView =\n/** @class */\nfunction () {\n  function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n    this.remoteDocumentCache = remoteDocumentCache;\n    this.mutationQueue = mutationQueue;\n  }\n  /**\n   * Get the local view of the document identified by `key`.\n   *\n   * @return Local view of the document or null if we don't have any cached\n   * state for it.\n   */\n\n\n  LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n    var _this = this;\n\n    return this.remoteDocumentCache.getEntry(transaction, key).next(function (remoteDoc) {\n      return _this.computeLocalDocument(transaction, key, remoteDoc);\n    });\n  };\n  /**\n   * Gets the local view of the documents identified by `keys`.\n   *\n   * If we don't have cached state for a document in `keys`, a NoDocument will\n   * be stored for that key in the resulting set.\n   */\n\n\n  LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n    var _this = this;\n\n    var promises = [];\n    var results = maybeDocumentMap();\n    keys.forEach(function (key) {\n      promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n        // TODO(http://b/32275378): Don't conflate missing / deleted.\n        if (!maybeDoc) {\n          maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n        }\n\n        results = results.insert(key, maybeDoc);\n      }));\n    });\n    return PersistencePromise.waitFor(promises).next(function () {\n      return results;\n    });\n  };\n  /** Performs a query against the local view of all documents. */\n\n\n  LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n    if (DocumentKey.isDocumentKey(query.path)) {\n      return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n    } else {\n      return this.getDocumentsMatchingCollectionQuery(transaction, query);\n    }\n  };\n\n  LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n    // Just do a simple document lookup.\n    return this.getDocument(transaction, new DocumentKey(docPath)).next(function (maybeDoc) {\n      var result = documentMap();\n\n      if (maybeDoc instanceof Document) {\n        result = result.insert(maybeDoc.key, maybeDoc);\n      }\n\n      return result;\n    });\n  };\n\n  LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n    var _this = this; // Query the remote documents and overlay mutations.\n    // TODO(mikelehen): There may be significant overlap between the mutations\n    // affecting these remote documents and the\n    // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n\n\n    var results;\n    return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query).next(function (queryResults) {\n      return _this.computeLocalDocuments(transaction, queryResults);\n    }).next(function (promisedResults) {\n      results = promisedResults; // Now use the mutation queue to discover any other documents that may\n      // match the query after applying mutations.\n\n      return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n    }).next(function (matchingMutationBatches) {\n      var matchingKeys = documentKeySet();\n\n      for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n        var batch = matchingMutationBatches_1[_i];\n\n        for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n          var mutation = _b[_a]; // TODO(mikelehen): PERF: Check if this mutation actually\n          // affects the query to reduce work.\n\n          if (!results.get(mutation.key)) {\n            matchingKeys = matchingKeys.add(mutation.key);\n          }\n        }\n      } // Now add in the results for the matchingKeys.\n\n\n      var promises = [];\n      matchingKeys.forEach(function (key) {\n        promises.push(_this.getDocument(transaction, key).next(function (doc) {\n          if (doc instanceof Document) {\n            results = results.insert(doc.key, doc);\n          }\n        }));\n      });\n      return PersistencePromise.waitFor(promises);\n    }).next(function () {\n      // Finally, filter out any documents that don't actually match\n      // the query.\n      results.forEach(function (key, doc) {\n        if (!query.matches(doc)) {\n          results = results.remove(key);\n        }\n      });\n      return results;\n    });\n  };\n  /**\n   * Takes a remote document and applies local mutations to generate the local\n   * view of the document.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the document (necessary when remoteDocument\n   *     is null).\n   * @param document The base remote document to apply mutations to or null.\n   */\n\n\n  LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, documentKey).next(function (batches) {\n      for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n        var batch = batches_1[_i];\n        document = batch.applyToLocalView(documentKey, document);\n      }\n\n      return document;\n    });\n  };\n  /**\n   * Takes a set of remote documents and applies local mutations to generate the\n   * local view of the documents.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documents The base remote documents to apply mutations to.\n   * @return The local view of the documents.\n   */\n\n\n  LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n    var _this = this;\n\n    var promises = [];\n    documents.forEach(function (key, doc) {\n      promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n        if (mutatedDoc instanceof Document) {\n          documents = documents.insert(mutatedDoc.key, mutatedDoc);\n        } else if (mutatedDoc instanceof NoDocument) {\n          documents = documents.remove(mutatedDoc.key);\n        } else {\n          fail('Unknown MaybeDocument: ' + mutatedDoc);\n        }\n      }));\n    });\n    return PersistencePromise.waitFor(promises).next(function () {\n      return documents;\n    });\n  };\n\n  return LocalDocumentsView;\n}();\n\nexport { LocalDocumentsView };","map":{"version":3,"sources":["../src/local/local_documents_view.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  DocumentMap,\n  documentMap,\n  MaybeDocumentMap,\n  maybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ResourcePath } from '../model/path';\nimport { fail } from '../util/assert';\n\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nexport class LocalDocumentsView {\n  constructor(\n    private remoteDocumentCache: RemoteDocumentCache,\n    private mutationQueue: MutationQueue\n  ) {}\n\n  /**\n   * Get the local view of the document identified by `key`.\n   *\n   * @return Local view of the document or null if we don't have any cached\n   * state for it.\n   */\n  getDocument(\n    transaction: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.remoteDocumentCache\n      .getEntry(transaction, key)\n      .next(remoteDoc => {\n        return this.computeLocalDocument(transaction, key, remoteDoc);\n      });\n  }\n\n  /**\n   * Gets the local view of the documents identified by `keys`.\n   *\n   * If we don't have cached state for a document in `keys`, a NoDocument will\n   * be stored for that key in the resulting set.\n   */\n  getDocuments(\n    transaction: PersistenceTransaction,\n    keys: DocumentKeySet\n  ): PersistencePromise<MaybeDocumentMap> {\n    const promises = [] as Array<PersistencePromise<void>>;\n    let results = maybeDocumentMap();\n    keys.forEach(key => {\n      promises.push(\n        this.getDocument(transaction, key).next(maybeDoc => {\n          // TODO(http://b/32275378): Don't conflate missing / deleted.\n          if (!maybeDoc) {\n            maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n          }\n          results = results.insert(key, maybeDoc);\n        })\n      );\n    });\n    return PersistencePromise.waitFor(promises).next(() => results);\n  }\n\n  /** Performs a query against the local view of all documents. */\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    if (DocumentKey.isDocumentKey(query.path)) {\n      return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n    } else {\n      return this.getDocumentsMatchingCollectionQuery(transaction, query);\n    }\n  }\n\n  private getDocumentsMatchingDocumentQuery(\n    transaction: PersistenceTransaction,\n    docPath: ResourcePath\n  ): PersistencePromise<DocumentMap> {\n    // Just do a simple document lookup.\n    return this.getDocument(transaction, new DocumentKey(docPath)).next(\n      maybeDoc => {\n        let result = documentMap();\n        if (maybeDoc instanceof Document) {\n          result = result.insert(maybeDoc.key, maybeDoc);\n        }\n        return result;\n      }\n    );\n  }\n\n  private getDocumentsMatchingCollectionQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    // Query the remote documents and overlay mutations.\n    // TODO(mikelehen): There may be significant overlap between the mutations\n    // affecting these remote documents and the\n    // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n    let results: DocumentMap;\n    return this.remoteDocumentCache\n      .getDocumentsMatchingQuery(transaction, query)\n      .next(queryResults => {\n        return this.computeLocalDocuments(transaction, queryResults);\n      })\n      .next(promisedResults => {\n        results = promisedResults;\n        // Now use the mutation queue to discover any other documents that may\n        // match the query after applying mutations.\n        return this.mutationQueue.getAllMutationBatchesAffectingQuery(\n          transaction,\n          query\n        );\n      })\n      .next(matchingMutationBatches => {\n        let matchingKeys = documentKeySet();\n        for (const batch of matchingMutationBatches) {\n          for (const mutation of batch.mutations) {\n            // TODO(mikelehen): PERF: Check if this mutation actually\n            // affects the query to reduce work.\n            if (!results.get(mutation.key)) {\n              matchingKeys = matchingKeys.add(mutation.key);\n            }\n          }\n        }\n\n        // Now add in the results for the matchingKeys.\n        const promises = [] as Array<PersistencePromise<void>>;\n        matchingKeys.forEach(key => {\n          promises.push(\n            this.getDocument(transaction, key).next(doc => {\n              if (doc instanceof Document) {\n                results = results.insert(doc.key, doc);\n              }\n            })\n          );\n        });\n        return PersistencePromise.waitFor(promises);\n      })\n      .next(() => {\n        // Finally, filter out any documents that don't actually match\n        // the query.\n        results.forEach((key, doc) => {\n          if (!query.matches(doc)) {\n            results = results.remove(key);\n          }\n        });\n\n        return results;\n      });\n  }\n\n  /**\n   * Takes a remote document and applies local mutations to generate the local\n   * view of the document.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the document (necessary when remoteDocument\n   *     is null).\n   * @param document The base remote document to apply mutations to or null.\n   */\n  private computeLocalDocument(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey,\n    document: MaybeDocument | null\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.mutationQueue\n      .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n      .next(batches => {\n        for (const batch of batches) {\n          document = batch.applyToLocalView(documentKey, document);\n        }\n        return document;\n      });\n  }\n\n  /**\n   * Takes a set of remote documents and applies local mutations to generate the\n   * local view of the documents.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documents The base remote documents to apply mutations to.\n   * @return The local view of the documents.\n   */\n  private computeLocalDocuments(\n    transaction: PersistenceTransaction,\n    documents: DocumentMap\n  ): PersistencePromise<DocumentMap> {\n    const promises = [] as Array<PersistencePromise<void>>;\n    documents.forEach((key, doc) => {\n      promises.push(\n        this.computeLocalDocument(transaction, key, doc).next(mutatedDoc => {\n          if (mutatedDoc instanceof Document) {\n            documents = documents.insert(mutatedDoc.key, mutatedDoc);\n          } else if (mutatedDoc instanceof NoDocument) {\n            documents = documents.remove(mutatedDoc.key);\n          } else {\n            fail('Unknown MaybeDocument: ' + mutatedDoc);\n          }\n        })\n      );\n    });\n    return PersistencePromise.waitFor(promises).next(() => documents);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}