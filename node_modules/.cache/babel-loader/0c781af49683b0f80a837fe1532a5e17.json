{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert'; // An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\n\nvar SortedMap =\n/** @class */\nfunction () {\n  function SortedMap(comparator, root) {\n    this.comparator = comparator;\n    this.root = root ? root : LLRBNode.EMPTY;\n  } // Returns a copy of the map, with the specified key/value added or replaced.\n\n\n  SortedMap.prototype.insert = function (key, value) {\n    return new SortedMap(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));\n  }; // Returns a copy of the map, with the specified key removed.\n\n\n  SortedMap.prototype.remove = function (key) {\n    return new SortedMap(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));\n  }; // Returns the value of the node with the given key, or null.\n\n\n  SortedMap.prototype.get = function (key) {\n    var node = this.root;\n\n    while (!node.isEmpty()) {\n      var cmp = this.comparator(key, node.key);\n\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n\n    return null;\n  }; // Returns the key of the item *before* the specified key, or null if key is\n  // the first item.\n\n\n  SortedMap.prototype.getPredecessorKey = function (key) {\n    var node = this.root;\n    var rightParent = null;\n\n    while (!node.isEmpty()) {\n      var cmp = this.comparator(key, node.key);\n\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n\n          while (!node.right.isEmpty()) node = node.right;\n\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw fail('Attempted to find predecessor key for a nonexistent key.' + '  What gives?');\n  }; // Returns the index of the element in this sorted map, or -1 if it doesn't\n  // exist.\n\n\n  SortedMap.prototype.indexOf = function (key) {\n    // Number of nodes that were pruned when descending right\n    var prunedNodes = 0;\n    var node = this.root;\n\n    while (!node.isEmpty()) {\n      var cmp = this.comparator(key, node.key);\n\n      if (cmp === 0) {\n        return prunedNodes + node.left.size;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        // Count all nodes left of the node plus the node itself\n        prunedNodes += node.left.size + 1;\n        node = node.right;\n      }\n    } // Node not found\n\n\n    return -1;\n  };\n\n  SortedMap.prototype.isEmpty = function () {\n    return this.root.isEmpty();\n  };\n\n  Object.defineProperty(SortedMap.prototype, \"size\", {\n    // Returns the total number of nodes in the map.\n    get: function get() {\n      return this.root.size;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Returns the minimum key in the map.\n\n  SortedMap.prototype.minKey = function () {\n    return this.root.minKey();\n  }; // Returns the maximum key in the map.\n\n\n  SortedMap.prototype.maxKey = function () {\n    return this.root.maxKey();\n  }; // Traverses the map in key order and calls the specified action function\n  // for each key/value pair. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n\n\n  SortedMap.prototype.inorderTraversal = function (action) {\n    return this.root.inorderTraversal(action);\n  };\n\n  SortedMap.prototype.forEach = function (fn) {\n    this.inorderTraversal(function (k, v) {\n      fn(k, v);\n      return false;\n    });\n  }; // Traverses the map in reverse key order and calls the specified action\n  // function for each key/value pair. If action returns true, traversal is\n  // aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n\n\n  SortedMap.prototype.reverseTraversal = function (action) {\n    return this.root.reverseTraversal(action);\n  };\n\n  SortedMap.prototype.getIterator = function (resultGenerator) {\n    return new SortedMapIterator(this.root, null, this.comparator, false, resultGenerator);\n  };\n\n  SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\n    return new SortedMapIterator(this.root, key, this.comparator, false, resultGenerator);\n  };\n\n  SortedMap.prototype.getReverseIterator = function (resultGenerator) {\n    return new SortedMapIterator(this.root, null, this.comparator, true, resultGenerator);\n  };\n\n  SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\n    return new SortedMapIterator(this.root, key, this.comparator, true, resultGenerator);\n  };\n\n  return SortedMap;\n}(); // end SortedMap\n\n\nexport { SortedMap }; // An iterator over an LLRBNode.\n\nvar SortedMapIterator =\n/** @class */\nfunction () {\n  function SortedMapIterator(node, startKey, comparator, isReverse, resultGenerator) {\n    this.resultGenerator = resultGenerator || null;\n    this.isReverse = isReverse;\n    this.nodeStack = [];\n    var cmp = 1;\n\n    while (!node.isEmpty()) {\n      cmp = startKey ? comparator(node.key, startKey) : 1; // flip the comparison if we're going in reverse\n\n      if (isReverse) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack,\n        // but stop iterating;\n        this.nodeStack.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move\n        // to the next one\n        this.nodeStack.push(node);\n\n        if (this.isReverse) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  SortedMapIterator.prototype.getNext = function () {\n    assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');\n    var node = this.nodeStack.pop();\n    var result;\n    if (this.resultGenerator) result = this.resultGenerator(node.key, node.value);else result = {\n      key: node.key,\n      value: node.value\n    };\n\n    if (this.isReverse) {\n      node = node.left;\n\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  };\n\n  SortedMapIterator.prototype.hasNext = function () {\n    return this.nodeStack.length > 0;\n  };\n\n  SortedMapIterator.prototype.peek = function () {\n    if (this.nodeStack.length === 0) return null;\n    var node = this.nodeStack[this.nodeStack.length - 1];\n\n    if (this.resultGenerator) {\n      return this.resultGenerator(node.key, node.value);\n    } else {\n      return {\n        key: node.key,\n        value: node.value\n      };\n    }\n  };\n\n  return SortedMapIterator;\n}(); // end SortedMapIterator\n\n\nexport { SortedMapIterator }; // Represents a node in a Left-leaning Red-Black tree.\n\nvar LLRBNode =\n/** @class */\nfunction () {\n  function LLRBNode(key, value, color, left, right) {\n    this.key = key;\n    this.value = value;\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left = left != null ? left : LLRBNode.EMPTY;\n    this.right = right != null ? right : LLRBNode.EMPTY;\n    this.size = this.left.size + 1 + this.right.size;\n  } // Returns a copy of the current node, optionally replacing pieces of it.\n\n\n  LLRBNode.prototype.copy = function (key, value, color, left, right) {\n    return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n  };\n\n  LLRBNode.prototype.isEmpty = function () {\n    return false;\n  }; // Traverses the tree in key order and calls the specified action function\n  // for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n\n\n  LLRBNode.prototype.inorderTraversal = function (action) {\n    return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);\n  }; // Traverses the tree in reverse key order and calls the specified action\n  // function for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n\n\n  LLRBNode.prototype.reverseTraversal = function (action) {\n    return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);\n  }; // Returns the minimum node in the tree.\n\n\n  LLRBNode.prototype.min = function () {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return this.left.min();\n    }\n  }; // Returns the maximum key in the tree.\n\n\n  LLRBNode.prototype.minKey = function () {\n    return this.min().key;\n  }; // Returns the maximum key in the tree.\n\n\n  LLRBNode.prototype.maxKey = function () {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }; // Returns new tree, with the key/value added.\n\n\n  LLRBNode.prototype.insert = function (key, value, comparator) {\n    var n = this;\n    var cmp = comparator(key, n.key);\n\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n    }\n\n    return n.fixUp();\n  };\n\n  LLRBNode.prototype.removeMin = function () {\n    if (this.left.isEmpty()) {\n      return LLRBNode.EMPTY;\n    }\n\n    var n = this;\n    if (!n.left.isRed() && !n.left.left.isRed()) n = n.moveRedLeft();\n    n = n.copy(null, null, null, n.left.removeMin(), null);\n    return n.fixUp();\n  }; // Returns new tree, with the specified item removed.\n\n\n  LLRBNode.prototype.remove = function (key, comparator) {\n    var smallest;\n    var n = this;\n\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n        n = n.moveRedLeft();\n      }\n\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed()) n = n.rotateRight();\n\n      if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n        n = n.moveRedRight();\n      }\n\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return LLRBNode.EMPTY;\n        } else {\n          smallest = n.right.min();\n          n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n        }\n      }\n\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n\n    return n.fixUp();\n  };\n\n  LLRBNode.prototype.isRed = function () {\n    return this.color;\n  }; // Returns new tree after performing any needed rotations.\n\n\n  LLRBNode.prototype.fixUp = function () {\n    var n = this;\n    if (n.right.isRed() && !n.left.isRed()) n = n.rotateLeft();\n    if (n.left.isRed() && n.left.left.isRed()) n = n.rotateRight();\n    if (n.left.isRed() && n.right.isRed()) n = n.colorFlip();\n    return n;\n  };\n\n  LLRBNode.prototype.moveRedLeft = function () {\n    var n = this.colorFlip();\n\n    if (n.right.left.isRed()) {\n      n = n.copy(null, null, null, null, n.right.rotateRight());\n      n = n.rotateLeft();\n      n = n.colorFlip();\n    }\n\n    return n;\n  };\n\n  LLRBNode.prototype.moveRedRight = function () {\n    var n = this.colorFlip();\n\n    if (n.left.left.isRed()) {\n      n = n.rotateRight();\n      n = n.colorFlip();\n    }\n\n    return n;\n  };\n\n  LLRBNode.prototype.rotateLeft = function () {\n    var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null);\n  };\n\n  LLRBNode.prototype.rotateRight = function () {\n    var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr);\n  };\n\n  LLRBNode.prototype.colorFlip = function () {\n    var left = this.left.copy(null, null, !this.left.color, null, null);\n    var right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }; // For testing.\n\n\n  LLRBNode.prototype.checkMaxDepth = function () {\n    var blackDepth = this.check();\n\n    if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }; // In a balanced RB tree, the black-depth (number of black nodes) from root to\n  // leaves is equal on both sides.  This function verifies that or asserts.\n\n\n  LLRBNode.prototype.check = function () {\n    if (this.isRed() && this.left.isRed()) {\n      throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n    }\n\n    if (this.right.isRed()) {\n      throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n    }\n\n    var blackDepth = this.left.check();\n\n    if (blackDepth !== this.right.check()) {\n      throw fail('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed() ? 0 : 1);\n    }\n  };\n\n  LLRBNode.EMPTY = null;\n  LLRBNode.RED = true;\n  LLRBNode.BLACK = false;\n  return LLRBNode;\n}(); // end LLRBNode\n\n\nexport { LLRBNode }; // Represents an empty node (a leaf node in the Red-Black Tree).\n\nvar LLRBEmptyNode =\n/** @class */\nfunction () {\n  function LLRBEmptyNode() {\n    this.size = 0;\n  } // Returns a copy of the current node.\n\n\n  LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n    return this;\n  }; // Returns a copy of the tree, with the specified key/value added.\n\n\n  LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n    return new LLRBNode(key, value);\n  }; // Returns a copy of the tree, with the specified key removed.\n\n\n  LLRBEmptyNode.prototype.remove = function (key, comparator) {\n    return this;\n  };\n\n  LLRBEmptyNode.prototype.isEmpty = function () {\n    return true;\n  };\n\n  LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n    return false;\n  };\n\n  LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n    return false;\n  };\n\n  LLRBEmptyNode.prototype.minKey = function () {\n    return null;\n  };\n\n  LLRBEmptyNode.prototype.maxKey = function () {\n    return null;\n  };\n\n  LLRBEmptyNode.prototype.isRed = function () {\n    return false;\n  }; // For testing.\n\n\n  LLRBEmptyNode.prototype.checkMaxDepth = function () {\n    return true;\n  };\n\n  LLRBEmptyNode.prototype.check = function () {\n    return 0;\n  };\n\n  return LLRBEmptyNode;\n}(); // end LLRBEmptyNode\n\n\nexport { LLRBEmptyNode };\nLLRBNode.EMPTY = new LLRBEmptyNode();","map":{"version":3,"sources":["../src/util/sorted_map.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport { AnyJs } from './misc';\n\n/*\n * Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\nexport interface Entry<K, V> {\n  key: K;\n  value: V;\n}\n\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nexport class SortedMap<K, V> {\n  // visible for testing\n  root: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  constructor(public comparator: Comparator<K>, root?: LLRBNode<K, V>) {\n    this.root = root ? root : LLRBNode.EMPTY;\n  }\n\n  // Returns a copy of the map, with the specified key/value added or replaced.\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .insert(key, value, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns a copy of the map, with the specified key removed.\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .remove(key, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns the value of the node with the given key, or null.\n  get(key: K): V | null {\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  // Returns the key of the item *before* the specified key, or null if key is\n  // the first item.\n  getPredecessorKey(key: K): K | null {\n    let node = this.root;\n    let rightParent: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null = null;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) node = node.right;\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw fail(\n      'Attempted to find predecessor key for a nonexistent key.' +\n        '  What gives?'\n    );\n  }\n\n  // Returns the index of the element in this sorted map, or -1 if it doesn't\n  // exist.\n  indexOf(key: K): number {\n    // Number of nodes that were pruned when descending right\n    let prunedNodes = 0;\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return prunedNodes + node.left.size;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        // Count all nodes left of the node plus the node itself\n        prunedNodes += node.left.size + 1;\n        node = node.right;\n      }\n    }\n    // Node not found\n    return -1;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  // Returns the total number of nodes in the map.\n  get size(): number {\n    return this.root.size;\n  }\n\n  // Returns the minimum key in the map.\n  minKey(): K | null {\n    return this.root.minKey();\n  }\n\n  // Returns the maximum key in the map.\n  maxKey(): K | null {\n    return this.root.maxKey();\n  }\n\n  // Traverses the map in key order and calls the specified action function\n  // for each key/value pair. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).inorderTraversal(action);\n  }\n\n  forEach(fn: (k: K, v: V) => void) {\n    this.inorderTraversal((k, v) => {\n      fn(k, v);\n      return false;\n    });\n  }\n\n  // Traverses the map in reverse key order and calls the specified action\n  // function for each key/value pair. If action returns true, traversal is\n  // aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).reverseTraversal(action);\n  }\n\n  // Returns an iterator over the SortedMap.\n  getIterator(): SortedMapIterator<K, V, Entry<K, V>>;\n  getIterator<T>(\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      null,\n      this.comparator,\n      false,\n      resultGenerator\n    );\n  }\n\n  getIteratorFrom(key: K): SortedMapIterator<K, V, Entry<K, V>>;\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      key,\n      this.comparator,\n      false,\n      resultGenerator\n    );\n  }\n\n  getReverseIterator(): SortedMapIterator<K, V, Entry<K, V>>;\n  getReverseIterator<T>(\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getReverseIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      null,\n      this.comparator,\n      true,\n      resultGenerator\n    );\n  }\n\n  getReverseIteratorFrom(key: K): SortedMapIterator<K, V, Entry<K, V>>;\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      key,\n      this.comparator,\n      true,\n      resultGenerator\n    );\n  }\n} // end SortedMap\n\n// An iterator over an LLRBNode.\nexport class SortedMapIterator<K, V, T> {\n  private resultGenerator: ((k: K, v: V) => T) | null;\n  private isReverse: boolean;\n  private nodeStack: Array<LLRBNode<K, V> | LLRBEmptyNode<K, V>>;\n\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    isReverse: boolean,\n    resultGenerator?: (k: K, v: V) => T\n  ) {\n    this.resultGenerator = resultGenerator || null;\n    this.isReverse = isReverse;\n    this.nodeStack = [];\n\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack,\n        // but stop iterating;\n        this.nodeStack.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move\n        // to the next one\n        this.nodeStack.push(node);\n        if (this.isReverse) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): T {\n    assert(\n      this.nodeStack.length > 0,\n      'getNext() called on iterator when hasNext() is false.'\n    );\n\n    let node = this.nodeStack.pop()!;\n    let result: any;\n    if (this.resultGenerator)\n      result = this.resultGenerator(node.key, node.value);\n    else result = { key: node.key, value: node.value };\n\n    if (this.isReverse) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack.length > 0;\n  }\n\n  peek(): any {\n    if (this.nodeStack.length === 0) return null;\n\n    const node = this.nodeStack[this.nodeStack.length - 1];\n    if (this.resultGenerator) {\n      return this.resultGenerator(node.key, node.value);\n    } else {\n      return { key: node.key, value: node.value };\n    }\n  }\n} // end SortedMapIterator\n\n// Represents a node in a Left-leaning Red-Black tree.\nexport class LLRBNode<K, V> {\n  readonly color: boolean;\n  readonly left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly size: number;\n\n  static EMPTY: LLRBEmptyNode<any, any> = null as any;\n\n  static RED = true;\n  static BLACK = false;\n\n  constructor(\n    public key: K,\n    public value: V,\n    color?: boolean,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V>\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left = left != null ? left : LLRBNode.EMPTY;\n    this.right = right != null ? right : LLRBNode.EMPTY;\n    this.size = this.left.size + 1 + this.right.size;\n  }\n\n  // Returns a copy of the current node, optionally replacing pieces of it.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): any {\n    return new LLRBNode<K, V>(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  // Traverses the tree in key order and calls the specified action function\n  // for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.left as LLRBNode<K, V>).inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.right as LLRBNode<K, V>).inorderTraversal(action)\n    );\n  }\n\n  // Traverses the tree in reverse key order and calls the specified action\n  // function for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.right as LLRBNode<K, V>).reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.left as LLRBNode<K, V>).reverseTraversal(action)\n    );\n  }\n\n  // Returns the minimum node in the tree.\n  private min(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min();\n    }\n  }\n\n  // Returns the maximum key in the tree.\n  minKey(): K | null {\n    return this.min().key;\n  }\n\n  // Returns the maximum key in the tree.\n  maxKey(): K | null {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  // Returns new tree, with the key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let n = this;\n    const cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp();\n  }\n\n  private removeMin(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return LLRBNode.EMPTY;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed() && !n.left.left.isRed()) n = n.moveRedLeft();\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin(), null);\n    return n.fixUp();\n  }\n\n  // Returns new tree, with the specified item removed.\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let smallest: LLRBNode<K, V>;\n    let n: LLRBNode<K, V> = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n        n = n.moveRedLeft();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed()) n = n.rotateRight();\n      if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n        n = n.moveRedRight();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return LLRBNode.EMPTY;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp();\n  }\n\n  isRed(): boolean {\n    return this.color;\n  }\n\n  // Returns new tree after performing any needed rotations.\n  private fixUp(): LLRBNode<K, V> {\n    let n: LLRBNode<K, V> = this;\n    if (n.right.isRed() && !n.left.isRed()) n = n.rotateLeft();\n    if (n.left.isRed() && n.left.left.isRed()) n = n.rotateRight();\n    if (n.left.isRed() && n.right.isRed()) n = n.colorFlip();\n    return n;\n  }\n\n  private moveRedLeft(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.right.left.isRed()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight()\n      );\n      n = n.rotateLeft();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private moveRedRight(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.left.left.isRed()) {\n      n = n.rotateRight();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private rotateLeft(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null);\n  }\n\n  private rotateRight(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr);\n  }\n\n  private colorFlip(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    const blackDepth = this.check();\n    if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // In a balanced RB tree, the black-depth (number of black nodes) from root to\n  // leaves is equal on both sides.  This function verifies that or asserts.\n  private check(): number {\n    if (this.isRed() && this.left.isRed()) {\n      throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n    }\n    if (this.right.isRed()) {\n      throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n    }\n    const blackDepth = (this.left as LLRBNode<K, V>).check();\n    if (blackDepth !== (this.right as LLRBNode<K, V>).check()) {\n      throw fail('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed() ? 0 : 1);\n    }\n  }\n} // end LLRBNode\n\n// Represents an empty node (a leaf node in the Red-Black Tree).\nexport class LLRBEmptyNode<K, V> {\n  key: K;\n  value: V;\n  color: boolean;\n  left: LLRBNode<K, V>;\n  right: LLRBNode<K, V>;\n  size = 0;\n\n  constructor() {}\n\n  // Returns a copy of the current node.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  // Returns a copy of the tree, with the specified key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode<K, V>(key, value);\n  }\n\n  // Returns a copy of the tree, with the specified key removed.\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  inorderTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  reverseTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  minKey(): K | null {\n    return null;\n  }\n\n  maxKey(): K | null {\n    return null;\n  }\n\n  isRed(): boolean {\n    return false;\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    return true;\n  }\n\n  private check() {\n    return 0;\n  }\n} // end LLRBEmptyNode\n\nLLRBNode.EMPTY = new LLRBEmptyNode<AnyJs, AnyJs>();\n"]},"metadata":{},"sourceType":"module"}