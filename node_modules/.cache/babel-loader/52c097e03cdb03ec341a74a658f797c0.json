{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { FieldPath as ExternalFieldPath } from './field_path';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { FirestoreClient } from '../core/firestore_client';\nimport { Bound, Direction, fieldFilter, OrderBy, Query as InternalQuery, RelationFilter, RelationOp } from '../core/query';\nimport { ChangeType } from '../core/view_snapshot';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ArrayValue, ObjectValue, RefValue } from '../model/field_value';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { ResourcePath } from '../model/path';\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { assert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateAtLeastNumberOfArgs, validateBetweenNumberOfArgs, validateDefined, validateExactNumberOfArgs, validateNamedOptionalType, validateNamedType, validateOptionalArgType, validateOptionNames, valueDescription } from '../util/input_validation';\nimport * as log from '../util/log';\nimport { LogLevel } from '../util/log';\nimport { AutoId } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { EmptyCredentialsProvider, FirebaseCredentialsProvider, makeCredentialsProvider } from './credentials';\nimport { isPartialObserver } from './observer';\nimport { DocumentKeyReference, fieldPathFromArgument, UserDataConverter } from './user_data_converter'; // The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n\nvar DEFAULT_HOST = 'firestore.googleapis.com';\nvar DEFAULT_SSL = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\n\nvar FirestoreSettings =\n/** @class */\nfunction () {\n  function FirestoreSettings(settings) {\n    if (settings.host === undefined) {\n      if (settings.ssl !== undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n      }\n\n      this.host = DEFAULT_HOST;\n      this.ssl = DEFAULT_SSL;\n    } else {\n      validateNamedType('settings', 'string', 'host', settings.host);\n      this.host = settings.host;\n      validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n      this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);\n    }\n\n    validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n    validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);\n    this.credentials = settings.credentials;\n  }\n\n  FirestoreSettings.prototype.equals = function (other) {\n    return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials;\n  };\n\n  return FirestoreSettings;\n}();\n\nvar FirestoreConfig =\n/** @class */\nfunction () {\n  function FirestoreConfig() {}\n\n  return FirestoreConfig;\n}();\n/**\n * The root reference to the database.\n */\n\n\nvar Firestore =\n/** @class */\nfunction () {\n  function Firestore(databaseIdOrApp) {\n    var _this = this;\n\n    this._queue = new AsyncQueue();\n    this.INTERNAL = {\n      delete: function _delete() {\n        if (_this._firestoreClient) {\n          return _this._firestoreClient.shutdown();\n        } else {\n          return Promise.resolve();\n        }\n      },\n      // Exposed via INTERNAL for use in tests.\n      disableNetwork: function disableNetwork() {\n        return _this._firestoreClient.disableNetwork();\n      },\n      enableNetwork: function enableNetwork() {\n        return _this._firestoreClient.enableNetwork();\n      },\n      drainAsyncQueue: function drainAsyncQueue(executeDelayedTasks) {\n        return _this._queue.drain(executeDelayedTasks);\n      }\n    };\n    var config = new FirestoreConfig();\n\n    if (typeof databaseIdOrApp.options === 'object') {\n      // This is very likely a Firebase app object\n      // TODO(b/34177605): Can we somehow use instanceof?\n      var app = databaseIdOrApp;\n      config.firebaseApp = app;\n      config.databaseId = Firestore.databaseIdFromApp(app);\n      config.persistenceKey = config.firebaseApp.name;\n      config.credentials = new FirebaseCredentialsProvider(app);\n    } else {\n      var external_1 = databaseIdOrApp;\n\n      if (!external_1.projectId) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');\n      }\n\n      config.databaseId = new DatabaseId(external_1.projectId, external_1.database); // Use a default persistenceKey that lines up with FirebaseApp.\n\n      config.persistenceKey = '[DEFAULT]';\n      config.credentials = new EmptyCredentialsProvider();\n    }\n\n    config.settings = new FirestoreSettings({});\n    this._config = config;\n    this._databaseId = config.databaseId;\n  }\n\n  Firestore.prototype.settings = function (settingsLiteral) {\n    validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n    validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n\n    if (objUtils.contains(settingsLiteral, 'persistence')) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to ' + 'firestore.enablePersistence().');\n    }\n\n    var newSettings = new FirestoreSettings(settingsLiteral);\n\n    if (this._firestoreClient && !this._config.settings.equals(newSettings)) {\n      throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' + 'be changed. You can only call settings() before calling any other ' + 'methods on a Firestore object.');\n    }\n\n    this._config.settings = newSettings;\n\n    if (newSettings.credentials !== undefined) {\n      this._config.credentials = makeCredentialsProvider(newSettings.credentials);\n    }\n  };\n\n  Firestore.prototype.enablePersistence = function () {\n    if (this._firestoreClient) {\n      throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' + 'be enabled. You can only call enablePersistence() before calling ' + 'any other methods on a Firestore object.');\n    }\n\n    return this.configureClient(\n    /* persistence= */\n    true);\n  };\n\n  Firestore.prototype.ensureClientConfigured = function () {\n    if (!this._firestoreClient) {\n      this.configureClient(\n      /* persistence= */\n      false);\n    }\n\n    return this._firestoreClient;\n  };\n\n  Firestore.prototype.configureClient = function (persistence) {\n    var _this = this;\n\n    assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');\n    assert(!this._firestoreClient, 'configureClient() called multiple times');\n    var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n\n    var preConverter = function preConverter(value) {\n      if (value instanceof DocumentReference) {\n        var thisDb = _this._config.databaseId;\n        var otherDb = value.firestore._config.databaseId;\n\n        if (!otherDb.equals(thisDb)) {\n          throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' + (otherDb.projectId + \"/\" + otherDb.database + \" but should be \") + (\"for database \" + thisDb.projectId + \"/\" + thisDb.database));\n        }\n\n        return new DocumentKeyReference(_this._config.databaseId, value._key);\n      } else {\n        return value;\n      }\n    };\n\n    this._dataConverter = new UserDataConverter(preConverter);\n    this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);\n    return this._firestoreClient.start(persistence);\n  };\n\n  Firestore.databaseIdFromApp = function (app) {\n    var options = app.options;\n\n    if (!objUtils.contains(options, 'projectId')) {\n      // TODO(b/62673263): We can safely remove the special handling of\n      // 'firestoreId' once alpha testers have upgraded.\n      if (objUtils.contains(options, 'firestoreId')) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreId\" is now specified as \"projectId\" in ' + 'firebase.initializeApp.');\n      }\n\n      throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n    }\n\n    if (objUtils.contains(options, 'firestoreOptions')) {\n      // TODO(b/62673263): We can safely remove the special handling of\n      // 'firestoreOptions' once alpha testers have upgraded.\n      throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreOptions\" values are now specified with ' + 'Firestore.settings()');\n    }\n\n    var projectId = options['projectId'];\n\n    if (!projectId || typeof projectId !== 'string') {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');\n    }\n\n    return new DatabaseId(projectId);\n  };\n\n  Object.defineProperty(Firestore.prototype, \"app\", {\n    get: function get() {\n      if (!this._config.firebaseApp) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" + 'not available');\n      }\n\n      return this._config.firebaseApp;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Firestore.prototype.collection = function (pathString) {\n    validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n    validateArgType('Firestore.collection', 'string', 1, pathString);\n\n    if (!pathString) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');\n    }\n\n    this.ensureClientConfigured();\n    return new CollectionReference(ResourcePath.fromString(pathString), this);\n  };\n\n  Firestore.prototype.doc = function (pathString) {\n    validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n    validateArgType('Firestore.doc', 'string', 1, pathString);\n\n    if (!pathString) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');\n    }\n\n    this.ensureClientConfigured();\n    return DocumentReference.forPath(ResourcePath.fromString(pathString), this);\n  };\n\n  Firestore.prototype.runTransaction = function (updateFunction) {\n    var _this = this;\n\n    validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n    validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n    return this.ensureClientConfigured().transaction(function (transaction) {\n      return updateFunction(new Transaction(_this, transaction));\n    });\n  };\n\n  Firestore.prototype.batch = function () {\n    this.ensureClientConfigured();\n    return new WriteBatch(this);\n  };\n\n  Object.defineProperty(Firestore, \"logLevel\", {\n    get: function get() {\n      switch (log.getLogLevel()) {\n        case LogLevel.DEBUG:\n          return 'debug';\n\n        case LogLevel.ERROR:\n          return 'error';\n\n        case LogLevel.SILENT:\n          return 'silent';\n\n        default:\n          return fail('Unknown log level: ' + log.getLogLevel());\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Firestore.setLogLevel = function (level) {\n    validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n    validateArgType('Firestore.setLogLevel', 'string', 1, level);\n\n    switch (level) {\n      case 'debug':\n        log.setLogLevel(log.LogLevel.DEBUG);\n        break;\n\n      case 'error':\n        log.setLogLevel(log.LogLevel.ERROR);\n        break;\n\n      case 'silent':\n        log.setLogLevel(log.LogLevel.SILENT);\n        break;\n\n      default:\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);\n    }\n  };\n\n  return Firestore;\n}();\n\nexport { Firestore };\n/**\n * A reference to a transaction.\n */\n\nvar Transaction =\n/** @class */\nfunction () {\n  function Transaction(_firestore, _transaction) {\n    this._firestore = _firestore;\n    this._transaction = _transaction;\n  }\n\n  Transaction.prototype.get = function (documentRef) {\n    var _this = this;\n\n    validateExactNumberOfArgs('Transaction.get', arguments, 1);\n    var ref = validateReference('Transaction.get', documentRef, this._firestore);\n    return this._transaction.lookup([ref._key]).then(function (docs) {\n      if (!docs || docs.length !== 1) {\n        return fail('Mismatch in docs returned from document lookup.');\n      }\n\n      var doc = docs[0];\n\n      if (doc instanceof NoDocument) {\n        return new DocumentSnapshot(_this._firestore, ref._key, null, false);\n      }\n\n      return new DocumentSnapshot(_this._firestore, ref._key, doc, false);\n    });\n  };\n\n  Transaction.prototype.set = function (documentRef, value, options) {\n    validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n    var ref = validateReference('Transaction.set', documentRef, this._firestore);\n    options = validateSetOptions('Transaction.set', options);\n    var parsed = options.merge ? this._firestore._dataConverter.parseMergeData('Transaction.set', value) : this._firestore._dataConverter.parseSetData('Transaction.set', value);\n\n    this._transaction.set(ref._key, parsed);\n\n    return this;\n  };\n\n  Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n    var moreFieldsAndValues = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      moreFieldsAndValues[_i - 3] = arguments[_i];\n    }\n\n    var ref;\n    var parsed;\n\n    if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof ExternalFieldPath) {\n      validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n      ref = validateReference('Transaction.update', documentRef, this._firestore);\n      parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);\n    } else {\n      validateExactNumberOfArgs('Transaction.update', arguments, 2);\n      ref = validateReference('Transaction.update', documentRef, this._firestore);\n      parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);\n    }\n\n    this._transaction.update(ref._key, parsed);\n\n    return this;\n  };\n\n  Transaction.prototype.delete = function (documentRef) {\n    validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n    var ref = validateReference('Transaction.delete', documentRef, this._firestore);\n\n    this._transaction.delete(ref._key);\n\n    return this;\n  };\n\n  return Transaction;\n}();\n\nexport { Transaction };\n\nvar WriteBatch =\n/** @class */\nfunction () {\n  function WriteBatch(_firestore) {\n    this._firestore = _firestore;\n    this._mutations = [];\n    this._committed = false;\n  }\n\n  WriteBatch.prototype.set = function (documentRef, value, options) {\n    validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n    this.verifyNotCommitted();\n    var ref = validateReference('WriteBatch.set', documentRef, this._firestore);\n    options = validateSetOptions('WriteBatch.set', options);\n    var parsed = options.merge ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value) : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);\n    this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));\n    return this;\n  };\n\n  WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n    var moreFieldsAndValues = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      moreFieldsAndValues[_i - 3] = arguments[_i];\n    }\n\n    this.verifyNotCommitted();\n    var ref;\n    var parsed;\n\n    if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof ExternalFieldPath) {\n      validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n      ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n      parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);\n    } else {\n      validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n      ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n      parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);\n    }\n\n    this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));\n    return this;\n  };\n\n  WriteBatch.prototype.delete = function (documentRef) {\n    validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n    this.verifyNotCommitted();\n    var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);\n    this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));\n    return this;\n  };\n\n  WriteBatch.prototype.commit = function () {\n    this.verifyNotCommitted();\n    this._committed = true;\n\n    if (this._mutations.length > 0) {\n      return this._firestore.ensureClientConfigured().write(this._mutations);\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  WriteBatch.prototype.verifyNotCommitted = function () {\n    if (this._committed) {\n      throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' + 'has been called.');\n    }\n  };\n\n  return WriteBatch;\n}();\n\nexport { WriteBatch };\n/**\n * A reference to a particular document in a collection in the database.\n */\n\nvar DocumentReference =\n/** @class */\nfunction () {\n  function DocumentReference(_key, firestore) {\n    this._key = _key;\n    this.firestore = firestore;\n    this._firestoreClient = this.firestore.ensureClientConfigured();\n  }\n\n  DocumentReference.forPath = function (path, firestore) {\n    if (path.length % 2 !== 0) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' + 'references must have an even number of segments, but ' + (path.canonicalString() + \" has \" + path.length));\n    }\n\n    return new DocumentReference(new DocumentKey(path), firestore);\n  };\n\n  Object.defineProperty(DocumentReference.prototype, \"id\", {\n    get: function get() {\n      return this._key.path.lastSegment();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DocumentReference.prototype, \"parent\", {\n    get: function get() {\n      return new CollectionReference(this._key.path.popLast(), this.firestore);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DocumentReference.prototype, \"path\", {\n    get: function get() {\n      return this._key.path.canonicalString();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DocumentReference.prototype.collection = function (pathString) {\n    validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n    validateArgType('DocumentReference.collection', 'string', 1, pathString);\n\n    if (!pathString) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');\n    }\n\n    var path = ResourcePath.fromString(pathString);\n    return new CollectionReference(this._key.path.child(path), this.firestore);\n  };\n\n  DocumentReference.prototype.isEqual = function (other) {\n    if (!(other instanceof DocumentReference)) {\n      throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n    }\n\n    return this.firestore === other.firestore && this._key.equals(other._key);\n  };\n\n  DocumentReference.prototype.set = function (value, options) {\n    validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n    options = validateSetOptions('DocumentReference.set', options);\n    var parsed = options.merge ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value) : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);\n    return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));\n  };\n\n  DocumentReference.prototype.update = function (fieldOrUpdateData, value) {\n    var moreFieldsAndValues = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      moreFieldsAndValues[_i - 2] = arguments[_i];\n    }\n\n    var parsed;\n\n    if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof ExternalFieldPath) {\n      validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n      parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);\n    } else {\n      validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n      parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);\n    }\n\n    return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));\n  };\n\n  DocumentReference.prototype.delete = function () {\n    validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n    return this._firestoreClient.write([new DeleteMutation(this._key, Precondition.NONE)]);\n  };\n\n  DocumentReference.prototype.onSnapshot = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);\n    var options = {\n      includeMetadataChanges: false\n    };\n    var observer;\n    var currArg = 0;\n\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n      options = args[currArg];\n      validateOptionNames('DocumentReference.onSnapshot', options, ['includeMetadataChanges']);\n      validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);\n      currArg++;\n    }\n\n    var internalOptions = {\n      includeDocumentMetadataChanges: options.includeMetadataChanges,\n      includeQueryMetadataChanges: options.includeMetadataChanges\n    };\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg];\n    } else {\n      validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);\n      validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n      validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n      observer = {\n        next: args[currArg],\n        error: args[currArg + 1],\n        complete: args[currArg + 2]\n      };\n    }\n\n    return this.onSnapshotInternal(internalOptions, observer);\n  };\n\n  DocumentReference.prototype.onSnapshotInternal = function (options, observer) {\n    var _this = this;\n\n    var errHandler = function errHandler(err) {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    var asyncObserver = new AsyncObserver({\n      next: function next(snapshot) {\n        if (observer.next) {\n          assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');\n          var doc = snapshot.docs.get(_this._key);\n          observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));\n        }\n      },\n      error: errHandler\n    });\n\n    var internalListener = this._firestoreClient.listen(InternalQuery.atPath(this._key.path), asyncObserver, options);\n\n    return function () {\n      asyncObserver.mute();\n\n      _this._firestoreClient.unlisten(internalListener);\n    };\n  };\n\n  DocumentReference.prototype.get = function () {\n    var _this = this;\n\n    validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n    return new Promise(function (resolve, reject) {\n      var unlisten = _this.onSnapshotInternal({\n        includeQueryMetadataChanges: true,\n        includeDocumentMetadataChanges: true,\n        waitForSyncWhenOnline: true\n      }, {\n        next: function next(snap) {\n          // Remove query first before passing event to user to avoid\n          // user actions affecting the now stale query.\n          unlisten();\n\n          if (!snap.exists && snap.metadata.fromCache) {\n            // TODO(dimond): If we're online and the document doesn't\n            // exist then we resolve with a doc.exists set to false. If\n            // we're offline however, we reject the Promise in this\n            // case. Two options: 1) Cache the negative response from\n            // the server so we can deliver that even when you're\n            // offline 2) Actually reject the Promise in the online case\n            // if the document doesn't exist.\n            reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));\n          } else {\n            resolve(snap);\n          }\n        },\n        error: reject\n      });\n    });\n  };\n\n  return DocumentReference;\n}();\n\nexport { DocumentReference };\n\nvar DocumentSnapshot =\n/** @class */\nfunction () {\n  function DocumentSnapshot(_firestore, _key, _document, _fromCache) {\n    this._firestore = _firestore;\n    this._key = _key;\n    this._document = _document;\n    this._fromCache = _fromCache;\n  }\n\n  DocumentSnapshot.prototype.data = function () {\n    validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);\n\n    if (!this._document) {\n      throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" + 'the document exists before calling doc.data().');\n    }\n\n    return this.convertObject(this._document.data);\n  };\n\n  DocumentSnapshot.prototype.get = function (fieldPath) {\n    validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);\n\n    if (!this._document) {\n      throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" + 'the document exists before calling doc.get().');\n    }\n\n    var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n\n    return value === undefined ? undefined : this.convertValue(value);\n  };\n\n  Object.defineProperty(DocumentSnapshot.prototype, \"id\", {\n    get: function get() {\n      return this._key.path.lastSegment();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DocumentSnapshot.prototype, \"ref\", {\n    get: function get() {\n      return new DocumentReference(this._key, this._firestore);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DocumentSnapshot.prototype, \"exists\", {\n    get: function get() {\n      return this._document !== null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DocumentSnapshot.prototype, \"metadata\", {\n    get: function get() {\n      return {\n        hasPendingWrites: this._document !== null && this._document.hasLocalMutations,\n        fromCache: this._fromCache\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DocumentSnapshot.prototype.convertObject = function (data) {\n    var _this = this;\n\n    var result = {};\n    data.forEach(function (key, value) {\n      result[key] = _this.convertValue(value);\n    });\n    return result;\n  };\n\n  DocumentSnapshot.prototype.convertValue = function (value) {\n    if (value instanceof ObjectValue) {\n      return this.convertObject(value);\n    } else if (value instanceof ArrayValue) {\n      return this.convertArray(value);\n    } else if (value instanceof RefValue) {\n      var key = value.value();\n\n      var database = this._firestore.ensureClientConfigured().databaseId();\n\n      if (!value.databaseId.equals(database)) {\n        // TODO(b/64130202): Somehow support foreign references.\n        log.error(\"Document \" + this._key.path + \" contains a document \" + \"reference within a different database (\" + (value.databaseId.projectId + \"/\" + value.databaseId.database + \") which is not \") + \"supported. It will be treated as a reference in the current \" + (\"database (\" + database.projectId + \"/\" + database.database + \") \") + \"instead.\");\n      }\n\n      return new DocumentReference(key, this._firestore);\n    } else {\n      return value.value();\n    }\n  };\n\n  DocumentSnapshot.prototype.convertArray = function (data) {\n    var _this = this;\n\n    return data.internalValue.map(function (value) {\n      return _this.convertValue(value);\n    });\n  };\n\n  return DocumentSnapshot;\n}();\n\nexport { DocumentSnapshot };\n\nvar Query =\n/** @class */\nfunction () {\n  function Query(_query, firestore) {\n    this._query = _query;\n    this.firestore = firestore;\n  }\n\n  Query.prototype.where = function (field, opStr, value) {\n    validateExactNumberOfArgs('Query.where', arguments, 3);\n    validateArgType('Query.where', 'string', 2, opStr);\n    validateDefined('Query.where', 3, value);\n    var fieldValue;\n    var fieldPath = fieldPathFromArgument('Query.where', field);\n\n    if (fieldPath.isKeyField()) {\n      if (typeof value === 'string') {\n        if (value.indexOf('/') !== -1) {\n          // TODO(dimond): Allow slashes once ancestor queries are supported\n          throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' + 'valid document ID if the first parameter is ' + 'FieldPath.documentId(), but it contains a slash.');\n        }\n\n        if (value === '') {\n          throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' + 'valid document ID if the first parameter is ' + 'FieldPath.documentId(), but it was an empty string.');\n        }\n\n        var path = this._query.path.child(new ResourcePath([value]));\n\n        assert(path.length % 2 === 0, 'Path should be a document key');\n        fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));\n      } else if (value instanceof DocumentReference) {\n        var ref = value;\n        fieldValue = new RefValue(this.firestore._databaseId, ref._key);\n      } else {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a \" + \"string or a DocumentReference if the first parameter is \" + \"FieldPath.documentId(), but it was: \" + (valueDescription(value) + \".\"));\n      }\n    } else {\n      fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);\n    }\n\n    var filter = fieldFilter(fieldPath, RelationOp.fromString(opStr), fieldValue);\n    this.validateNewFilter(filter);\n    return new Query(this._query.addFilter(filter), this.firestore);\n  };\n\n  Query.prototype.orderBy = function (field, directionStr) {\n    validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n    validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n    var direction;\n\n    if (directionStr === undefined || directionStr === 'asc') {\n      direction = Direction.ASCENDING;\n    } else if (directionStr === 'desc') {\n      direction = Direction.DESCENDING;\n    } else {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + directionStr + \"', \" + \"expected 'asc' or 'desc'.\");\n    }\n\n    if (this._query.startAt !== null) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' + 'Query.startAfter() before calling Query.orderBy().');\n    }\n\n    if (this._query.endAt !== null) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' + 'Query.endBefore() before calling Query.orderBy().');\n    }\n\n    var fieldPath = fieldPathFromArgument('Query.orderBy', field);\n    var orderBy = new OrderBy(fieldPath, direction);\n    this.validateNewOrderBy(orderBy);\n    return new Query(this._query.addOrderBy(orderBy), this.firestore);\n  };\n\n  Query.prototype.limit = function (n) {\n    validateExactNumberOfArgs('Query.limit', arguments, 1);\n    validateArgType('Query.limit', 'number', 1, n);\n\n    if (n <= 0) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + n + \") is invalid. Limit must be \" + 'positive.');\n    }\n\n    return new Query(this._query.withLimit(n), this.firestore);\n  };\n\n  Query.prototype.startAt = function (docOrField) {\n    var fields = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      fields[_i - 1] = arguments[_i];\n    }\n\n    validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n    var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields,\n    /*before=*/\n    true);\n    return new Query(this._query.withStartAt(bound), this.firestore);\n  };\n\n  Query.prototype.startAfter = function (docOrField) {\n    var fields = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      fields[_i - 1] = arguments[_i];\n    }\n\n    validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n    var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields,\n    /*before=*/\n    false);\n    return new Query(this._query.withStartAt(bound), this.firestore);\n  };\n\n  Query.prototype.endBefore = function (docOrField) {\n    var fields = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      fields[_i - 1] = arguments[_i];\n    }\n\n    validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n    var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields,\n    /*before=*/\n    true);\n    return new Query(this._query.withEndAt(bound), this.firestore);\n  };\n\n  Query.prototype.endAt = function (docOrField) {\n    var fields = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      fields[_i - 1] = arguments[_i];\n    }\n\n    validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n    var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields,\n    /*before=*/\n    false);\n    return new Query(this._query.withEndAt(bound), this.firestore);\n  };\n\n  Query.prototype.isEqual = function (other) {\n    if (!(other instanceof Query)) {\n      throw invalidClassError('isEqual', 'Query', 1, other);\n    }\n\n    return this.firestore === other.firestore && this._query.equals(other._query);\n  };\n  /** Helper function to create a bound from a document or fields */\n\n\n  Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {\n    validateDefined(methodName, 1, docOrField);\n\n    if (docOrField instanceof DocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"().\");\n      }\n\n      var snap = docOrField;\n\n      if (!snap.exists) {\n        throw new FirestoreError(Code.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" + (methodName + \"().\"));\n      }\n\n      return this.boundFromDocument(methodName, snap._document, before);\n    } else {\n      var allFields = [docOrField].concat(fields);\n      return this.boundFromFields(methodName, allFields, before);\n    }\n  };\n  /**\n   * Create a Bound from a query and a document.\n   *\n   * Note that the Bound will always include the key of the document\n   * and so only the provided document will compare equal to the returned\n   * position.\n   *\n   * Will throw if the document does not contain all fields of the order by\n   * of the query.\n   */\n\n\n  Query.prototype.boundFromDocument = function (methodName, doc, before) {\n    var components = []; // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n\n    for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {\n      var orderBy = _a[_i];\n\n      if (orderBy.field.isKeyField()) {\n        components.push(new RefValue(this.firestore._databaseId, doc.key));\n      } else {\n        var value = doc.field(orderBy.field);\n\n        if (value !== undefined) {\n          components.push(value);\n        } else {\n          var field = orderBy.field.canonicalString();\n          throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" + (\"document for which the field '\" + field + \"' (used as the \") + \"orderBy) does not exist.\");\n        }\n      }\n    }\n\n    return new Bound(components, before);\n  };\n  /**\n   * Converts a list of field values to a Bound for the given query.\n   */\n\n\n  Query.prototype.boundFromFields = function (methodName, values, before) {\n    // Use explicit order by's because it has to match the query the user made\n    var orderBy = this._query.explicitOrderBy;\n\n    if (values.length > orderBy.length) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"(). \" + \"The number of arguments must be less than or equal to the \" + \"number of Query.orderBy() clauses\");\n    }\n\n    var components = [];\n\n    for (var i = 0; i < values.length; i++) {\n      var rawValue = values[i];\n      var orderByComponent = orderBy[i];\n\n      if (orderByComponent.field.isKeyField()) {\n        if (typeof rawValue !== 'string') {\n          throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" + (methodName + \"(), but got a \" + typeof rawValue));\n        }\n\n        if (rawValue.indexOf('/') !== -1) {\n          throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + rawValue + \"' contains a slash in \" + (methodName + \"()\"));\n        }\n\n        var key = new DocumentKey(this._query.path.child(rawValue));\n        components.push(new RefValue(this.firestore._databaseId, key));\n      } else {\n        var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);\n\n        components.push(wrapped);\n      }\n    }\n\n    return new Bound(components, before);\n  };\n\n  Query.prototype.onSnapshot = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n    var options = {};\n    var observer;\n    var currArg = 0;\n\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n      options = args[currArg];\n      validateOptionNames('Query.onSnapshot', options, ['includeQueryMetadataChanges', 'includeDocumentMetadataChanges']);\n      validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);\n      validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);\n      currArg++;\n    }\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg];\n    } else {\n      validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n      validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n      validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n      observer = {\n        next: args[currArg],\n        error: args[currArg + 1],\n        complete: args[currArg + 2]\n      };\n    }\n\n    return this.onSnapshotInternal(options, observer);\n  };\n\n  Query.prototype.onSnapshotInternal = function (options, observer) {\n    var _this = this;\n\n    var errHandler = function errHandler(err) {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    var asyncObserver = new AsyncObserver({\n      next: function next(result) {\n        if (observer.next) {\n          observer.next(new QuerySnapshot(_this.firestore, _this._query, result));\n        }\n      },\n      error: errHandler\n    });\n    var firestoreClient = this.firestore.ensureClientConfigured();\n    var internalListener = firestoreClient.listen(this._query, asyncObserver, options);\n    return function () {\n      asyncObserver.mute();\n      firestoreClient.unlisten(internalListener);\n    };\n  };\n\n  Query.prototype.get = function () {\n    var _this = this;\n\n    validateExactNumberOfArgs('Query.get', arguments, 0);\n    return new Promise(function (resolve, reject) {\n      var unlisten = _this.onSnapshotInternal({\n        includeDocumentMetadataChanges: false,\n        includeQueryMetadataChanges: true,\n        waitForSyncWhenOnline: true\n      }, {\n        next: function next(result) {\n          // Remove query first before passing event to user to avoid\n          // user actions affecting the now stale query.\n          unlisten();\n          resolve(result);\n        },\n        error: reject\n      });\n    });\n  };\n\n  Query.prototype.validateNewFilter = function (filter) {\n    if (filter instanceof RelationFilter && filter.isInequality()) {\n      var existingField = this._query.getInequalityFilterField();\n\n      if (existingField !== null && !existingField.equals(filter.field)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' + ' (<, <=, >, or >=) must be on the same field. But you have' + (\" inequality filters on '\" + existingField.toString() + \"'\") + (\" and '\" + filter.field.toString() + \"'\"));\n      }\n\n      var firstOrderByField = this._query.getFirstOrderByField();\n\n      if (firstOrderByField !== null) {\n        this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n      }\n    }\n  };\n\n  Query.prototype.validateNewOrderBy = function (orderBy) {\n    if (this._query.getFirstOrderByField() === null) {\n      // This is the first order by. It must match any inequality.\n      var inequalityField = this._query.getInequalityFilterField();\n\n      if (inequalityField !== null) {\n        this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n      }\n    }\n  };\n\n  Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {\n    if (!orderBy.equals(inequality)) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality \" + (\"(<, <=, >, or >=) on field '\" + inequality.toString() + \"' \") + (\"and so you must also use '\" + inequality.toString() + \"' \") + \"as your first Query.orderBy(), but your first Query.orderBy() \" + (\"is on field '\" + orderBy.toString() + \"' instead.\"));\n    }\n  };\n\n  return Query;\n}();\n\nexport { Query };\n\nvar QuerySnapshot =\n/** @class */\nfunction () {\n  function QuerySnapshot(_firestore, _originalQuery, _snapshot) {\n    this._firestore = _firestore;\n    this._originalQuery = _originalQuery;\n    this._snapshot = _snapshot;\n    this._cachedChanges = null;\n    this.metadata = {\n      fromCache: _snapshot.fromCache,\n      hasPendingWrites: _snapshot.hasPendingWrites\n    };\n  }\n\n  Object.defineProperty(QuerySnapshot.prototype, \"docs\", {\n    get: function get() {\n      var result = [];\n      this.forEach(function (doc) {\n        return result.push(doc);\n      });\n      return result;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(QuerySnapshot.prototype, \"empty\", {\n    get: function get() {\n      return this._snapshot.docs.isEmpty();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(QuerySnapshot.prototype, \"size\", {\n    get: function get() {\n      return this._snapshot.docs.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  QuerySnapshot.prototype.forEach = function (callback, thisArg) {\n    var _this = this;\n\n    validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n    validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n\n    this._snapshot.docs.forEach(function (doc) {\n      callback.call(thisArg, _this.convertToDocumentImpl(doc));\n    });\n  };\n\n  Object.defineProperty(QuerySnapshot.prototype, \"query\", {\n    get: function get() {\n      return new Query(this._originalQuery, this._firestore);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(QuerySnapshot.prototype, \"docChanges\", {\n    get: function get() {\n      if (!this._cachedChanges) {\n        this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);\n      }\n\n      return this._cachedChanges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {\n    return new DocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);\n  };\n\n  return QuerySnapshot;\n}();\n\nexport { QuerySnapshot };\n\nvar CollectionReference =\n/** @class */\nfunction (_super) {\n  __extends(CollectionReference, _super);\n\n  function CollectionReference(path, firestore) {\n    var _this = _super.call(this, InternalQuery.atPath(path), firestore) || this;\n\n    if (path.length % 2 !== 1) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' + 'references must have an odd number of segments, but ' + (path.canonicalString() + \" has \" + path.length));\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(CollectionReference.prototype, \"id\", {\n    get: function get() {\n      return this._query.path.lastSegment();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CollectionReference.prototype, \"parent\", {\n    get: function get() {\n      var parentPath = this._query.path.popLast();\n\n      if (parentPath.isEmpty()) {\n        return null;\n      } else {\n        return new DocumentReference(new DocumentKey(parentPath), this.firestore);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CollectionReference.prototype, \"path\", {\n    get: function get() {\n      return this._query.path.canonicalString();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CollectionReference.prototype.doc = function (pathString) {\n    validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1); // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n\n    if (arguments.length === 0) {\n      pathString = AutoId.newId();\n    }\n\n    validateArgType('CollectionReference.doc', 'string', 1, pathString);\n\n    if (pathString === '') {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');\n    }\n\n    var path = ResourcePath.fromString(pathString);\n    return DocumentReference.forPath(this._query.path.child(path), this.firestore);\n  };\n\n  CollectionReference.prototype.add = function (value) {\n    validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n    validateArgType('CollectionReference.add', 'object', 1, value);\n    var docRef = this.doc();\n    return docRef.set(value).then(function () {\n      return docRef;\n    });\n  };\n\n  return CollectionReference;\n}(Query);\n\nexport { CollectionReference };\n\nfunction validateSetOptions(methodName, options) {\n  if (options === undefined) {\n    return {\n      merge: false\n    };\n  }\n\n  validateOptionNames(methodName, options, ['merge']);\n  validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n  return options;\n}\n\nfunction validateReference(methodName, documentRef, firestore) {\n  if (!(documentRef instanceof DocumentReference)) {\n    throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n  } else if (documentRef.firestore !== firestore) {\n    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n  } else {\n    return documentRef;\n  }\n}\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\n\n\nexport function changesFromSnapshot(firestore, snapshot) {\n  if (snapshot.oldDocs.isEmpty()) {\n    // Special case the first snapshot because index calculation is easy and\n    // fast\n    var lastDoc_1;\n    var index_1 = 0;\n    return snapshot.docChanges.map(function (change) {\n      var doc = new DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n      assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');\n      assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');\n      lastDoc_1 = change.doc;\n      return {\n        type: 'added',\n        doc: doc,\n        oldIndex: -1,\n        newIndex: index_1++\n      };\n    });\n  } else {\n    // A DocumentSet that is updated incrementally as changes are applied to use\n    // to lookup the index of a document.\n    var indexTracker_1 = snapshot.oldDocs;\n    return snapshot.docChanges.map(function (change) {\n      var doc = new DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n      var oldIndex = -1;\n      var newIndex = -1;\n\n      if (change.type !== ChangeType.Added) {\n        oldIndex = indexTracker_1.indexOf(change.doc.key);\n        assert(oldIndex >= 0, 'Index for document not found');\n        indexTracker_1 = indexTracker_1.delete(change.doc.key);\n      }\n\n      if (change.type !== ChangeType.Removed) {\n        indexTracker_1 = indexTracker_1.add(change.doc);\n        newIndex = indexTracker_1.indexOf(change.doc.key);\n      }\n\n      return {\n        type: resultChangeType(change.type),\n        doc: doc,\n        oldIndex: oldIndex,\n        newIndex: newIndex\n      };\n    });\n  }\n}\n\nfunction resultChangeType(type) {\n  switch (type) {\n    case ChangeType.Added:\n      return 'added';\n\n    case ChangeType.Modified:\n    case ChangeType.Metadata:\n      return 'modified';\n\n    case ChangeType.Removed:\n      return 'removed';\n\n    default:\n      return fail('Unknown change type: ' + type);\n  }\n} // Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\n\n\nexport var PublicFirestore = makeConstructorPrivate(Firestore, 'Use firebase.firestore() instead.');\nexport var PublicTransaction = makeConstructorPrivate(Transaction, 'Use firebase.firestore().runTransaction() instead.');\nexport var PublicWriteBatch = makeConstructorPrivate(WriteBatch, 'Use firebase.firestore().batch() instead.');\nexport var PublicDocumentReference = makeConstructorPrivate(DocumentReference, 'Use firebase.firestore().doc() instead.');\nexport var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport var PublicQuery = makeConstructorPrivate(Query);\nexport var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport var PublicCollectionReference = makeConstructorPrivate(CollectionReference, 'Use firebase.firestore().collection() instead.'); // tslint:enable:variable-name","map":{"version":3,"sources":["../src/api/database.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from 'firestore';\n\nimport { FirebaseApp, FirebaseService } from '@firebase/app';\nimport { FieldPath as ExternalFieldPath } from './field_path';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { ListenOptions } from '../core/event_manager';\nimport { FirestoreClient } from '../core/firestore_client';\nimport {\n  Bound,\n  Direction,\n  fieldFilter,\n  Filter,\n  OrderBy,\n  Query as InternalQuery,\n  RelationFilter,\n  RelationOp\n} from '../core/query';\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport { ChangeType, ViewSnapshot } from '../core/view_snapshot';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  ArrayValue,\n  FieldValue,\n  ObjectValue,\n  RefValue\n} from '../model/field_value';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { assert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  invalidClassError,\n  validateArgType,\n  validateAtLeastNumberOfArgs,\n  validateBetweenNumberOfArgs,\n  validateDefined,\n  validateExactNumberOfArgs,\n  validateNamedOptionalType,\n  validateNamedType,\n  validateOptionalArgType,\n  validateOptionNames,\n  valueDescription\n} from '../util/input_validation';\nimport * as log from '../util/log';\nimport { LogLevel } from '../util/log';\nimport { AnyJs, AutoId } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { Rejecter, Resolver } from '../util/promise';\n\nimport {\n  CredentialsProvider,\n  CredentialsSettings,\n  EmptyCredentialsProvider,\n  FirebaseCredentialsProvider,\n  makeCredentialsProvider\n} from './credentials';\nimport {\n  CompleteFn,\n  ErrorFn,\n  isPartialObserver,\n  NextFn,\n  PartialObserver,\n  Unsubscribe\n} from './observer';\nimport {\n  DocumentKeyReference,\n  fieldPathFromArgument,\n  UserDataConverter\n} from './user_data_converter';\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\n\n/** Undocumented, private additional settings not exposed in our public API. */\ninterface PrivateSettings extends firestore.Settings {\n  // Can be a google-auth-library or gapi client.\n  credentials?: CredentialsSettings;\n}\n\n/**\n * Options that can be provided in the Firestore constructor when not using\n * Firebase (aka standalone mode).\n */\nexport interface FirestoreDatabase {\n  projectId: string;\n  database?: string;\n}\n\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettings {\n  /** The hostname to connect to. */\n  host: string;\n\n  /** Whether to use SSL when connecting. */\n  ssl: boolean;\n\n  // Can be a google-auth-library or gapi client.\n  // tslint:disable-next-line:no-any\n  credentials?: any;\n\n  constructor(settings: PrivateSettings) {\n    if (settings.host === undefined) {\n      if (settings.ssl !== undefined) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          \"Can't provide ssl option if host option is not set\"\n        );\n      }\n      this.host = DEFAULT_HOST;\n      this.ssl = DEFAULT_SSL;\n    } else {\n      validateNamedType('settings', 'string', 'host', settings.host);\n      this.host = settings.host;\n\n      validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n      this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);\n    }\n    validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n\n    validateNamedOptionalType(\n      'settings',\n      'object',\n      'credentials',\n      settings.credentials\n    );\n    this.credentials = settings.credentials;\n  }\n\n  equals(other: FirestoreSettings): boolean {\n    return (\n      this.host === other.host &&\n      this.ssl === other.ssl &&\n      this.credentials === other.credentials\n    );\n  }\n}\n\nclass FirestoreConfig {\n  databaseId: DatabaseId;\n  persistenceKey: string;\n  credentials: CredentialsProvider;\n  firebaseApp: FirebaseApp;\n  settings: FirestoreSettings;\n  persistence: boolean;\n}\n\n/**\n * The root reference to the database.\n */\nexport class Firestore implements firestore.Firestore, FirebaseService {\n  private readonly _config: FirestoreConfig;\n  public readonly _databaseId: DatabaseId;\n\n  // The firestore client instance. This will be available as soon as\n  // configureClient is called, but any calls against it will block until\n  // setup has completed.\n  //\n  // Operations on the _firestoreClient don't block on _firestoreReady. Those\n  // are already set to synchronize on the async queue.\n  private _firestoreClient: FirestoreClient | undefined;\n  private _queue = new AsyncQueue();\n  public _dataConverter: UserDataConverter;\n\n  constructor(databaseIdOrApp: FirestoreDatabase | FirebaseApp) {\n    const config = new FirestoreConfig();\n    if (typeof (databaseIdOrApp as FirebaseApp).options === 'object') {\n      // This is very likely a Firebase app object\n      // TODO(b/34177605): Can we somehow use instanceof?\n      const app = databaseIdOrApp as FirebaseApp;\n      config.firebaseApp = app;\n      config.databaseId = Firestore.databaseIdFromApp(app);\n      config.persistenceKey = config.firebaseApp.name;\n      config.credentials = new FirebaseCredentialsProvider(app);\n    } else {\n      const external = databaseIdOrApp as FirestoreDatabase;\n      if (!external.projectId) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Must provide projectId'\n        );\n      }\n\n      config.databaseId = new DatabaseId(external.projectId, external.database);\n      // Use a default persistenceKey that lines up with FirebaseApp.\n      config.persistenceKey = '[DEFAULT]';\n      config.credentials = new EmptyCredentialsProvider();\n    }\n\n    config.settings = new FirestoreSettings({});\n    this._config = config;\n    this._databaseId = config.databaseId;\n  }\n\n  settings(settingsLiteral: firestore.Settings): void {\n    validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n    validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n\n    if (\n      objUtils.contains(settingsLiteral as objUtils.Dict<{}>, 'persistence')\n    ) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"persistence\" is now specified with a separate call to ' +\n          'firestore.enablePersistence().'\n      );\n    }\n\n    const newSettings = new FirestoreSettings(settingsLiteral);\n    if (this._firestoreClient && !this._config.settings.equals(newSettings)) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Firestore has already been started and its settings can no longer ' +\n          'be changed. You can only call settings() before calling any other ' +\n          'methods on a Firestore object.'\n      );\n    }\n\n    this._config.settings = newSettings;\n    if (newSettings.credentials !== undefined) {\n      this._config.credentials = makeCredentialsProvider(\n        newSettings.credentials\n      );\n    }\n  }\n\n  enablePersistence(): Promise<void> {\n    if (this._firestoreClient) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Firestore has already been started and persistence can no longer ' +\n          'be enabled. You can only call enablePersistence() before calling ' +\n          'any other methods on a Firestore object.'\n      );\n    }\n\n    return this.configureClient(/* persistence= */ true);\n  }\n\n  ensureClientConfigured(): FirestoreClient {\n    if (!this._firestoreClient) {\n      this.configureClient(/* persistence= */ false);\n    }\n    return this._firestoreClient as FirestoreClient;\n  }\n\n  private configureClient(persistence: boolean): Promise<void> {\n    assert(\n      !!this._config.settings.host,\n      'FirestoreSettings.host cannot be falsey'\n    );\n\n    assert(!this._firestoreClient, 'configureClient() called multiple times');\n\n    const databaseInfo = new DatabaseInfo(\n      this._config.databaseId,\n      this._config.persistenceKey,\n      this._config.settings.host,\n      this._config.settings.ssl\n    );\n\n    const preConverter = (value: AnyJs) => {\n      if (value instanceof DocumentReference) {\n        const thisDb = this._config.databaseId;\n        const otherDb = value.firestore._config.databaseId;\n        if (!otherDb.equals(thisDb)) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Document reference is for database ' +\n              `${otherDb.projectId}/${otherDb.database} but should be ` +\n              `for database ${thisDb.projectId}/${thisDb.database}`\n          );\n        }\n        return new DocumentKeyReference(this._config.databaseId, value._key);\n      } else {\n        return value;\n      }\n    };\n    this._dataConverter = new UserDataConverter(preConverter);\n\n    this._firestoreClient = new FirestoreClient(\n      PlatformSupport.getPlatform(),\n      databaseInfo,\n      this._config.credentials,\n      this._queue\n    );\n    return this._firestoreClient.start(persistence);\n  }\n\n  private static databaseIdFromApp(app: FirebaseApp): DatabaseId {\n    const options = app.options as objUtils.Dict<{}>;\n    if (!objUtils.contains(options, 'projectId')) {\n      // TODO(b/62673263): We can safely remove the special handling of\n      // 'firestoreId' once alpha testers have upgraded.\n      if (objUtils.contains(options, 'firestoreId')) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          '\"firestoreId\" is now specified as \"projectId\" in ' +\n            'firebase.initializeApp.'\n        );\n      }\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"projectId\" not provided in firebase.initializeApp.'\n      );\n    }\n\n    if (objUtils.contains(options, 'firestoreOptions')) {\n      // TODO(b/62673263): We can safely remove the special handling of\n      // 'firestoreOptions' once alpha testers have upgraded.\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"firestoreOptions\" values are now specified with ' +\n          'Firestore.settings()'\n      );\n    }\n\n    const projectId = options['projectId'];\n    if (!projectId || typeof projectId !== 'string') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'projectId must be a string in FirebaseApp.options'\n      );\n    }\n    return new DatabaseId(projectId);\n  }\n\n  get app(): FirebaseApp {\n    if (!this._config.firebaseApp) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n          'not available'\n      );\n    }\n    return this._config.firebaseApp;\n  }\n\n  INTERNAL = {\n    delete: (): Promise<void> => {\n      if (this._firestoreClient) {\n        return this._firestoreClient.shutdown();\n      } else {\n        return Promise.resolve();\n      }\n    },\n    // Exposed via INTERNAL for use in tests.\n    disableNetwork: () => this._firestoreClient.disableNetwork(),\n    enableNetwork: () => this._firestoreClient.enableNetwork(),\n    drainAsyncQueue: (executeDelayedTasks: boolean) =>\n      this._queue.drain(executeDelayedTasks)\n  };\n\n  collection(pathString: string): firestore.CollectionReference {\n    validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n    validateArgType('Firestore.collection', 'string', 1, pathString);\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty collection path to collection()'\n      );\n    }\n\n    this.ensureClientConfigured();\n    return new CollectionReference(ResourcePath.fromString(pathString), this);\n  }\n\n  doc(pathString: string): firestore.DocumentReference {\n    validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n    validateArgType('Firestore.doc', 'string', 1, pathString);\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty document path to doc()'\n      );\n    }\n    this.ensureClientConfigured();\n    return DocumentReference.forPath(ResourcePath.fromString(pathString), this);\n  }\n\n  runTransaction<T>(\n    updateFunction: (transaction: firestore.Transaction) => Promise<T>\n  ): Promise<T> {\n    validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n    validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n    return this.ensureClientConfigured().transaction(\n      (transaction: InternalTransaction) => {\n        return updateFunction(new Transaction(this, transaction));\n      }\n    );\n  }\n\n  batch(): firestore.WriteBatch {\n    this.ensureClientConfigured();\n\n    return new WriteBatch(this);\n  }\n\n  static get logLevel(): firestore.LogLevel {\n    switch (log.getLogLevel()) {\n      case LogLevel.DEBUG:\n        return 'debug';\n      case LogLevel.ERROR:\n        return 'error';\n      case LogLevel.SILENT:\n        return 'silent';\n      default:\n        return fail('Unknown log level: ' + log.getLogLevel());\n    }\n  }\n\n  static setLogLevel(level: firestore.LogLevel) {\n    validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n    validateArgType('Firestore.setLogLevel', 'string', 1, level);\n    switch (level) {\n      case 'debug':\n        log.setLogLevel(log.LogLevel.DEBUG);\n        break;\n      case 'error':\n        log.setLogLevel(log.LogLevel.ERROR);\n        break;\n      case 'silent':\n        log.setLogLevel(log.LogLevel.SILENT);\n        break;\n      default:\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid log level: ' + level\n        );\n    }\n  }\n}\n\n/**\n * A reference to a transaction.\n */\nexport class Transaction implements firestore.Transaction {\n  constructor(\n    private _firestore: Firestore,\n    private _transaction: InternalTransaction\n  ) {}\n\n  get(\n    documentRef: firestore.DocumentReference\n  ): Promise<firestore.DocumentSnapshot> {\n    validateExactNumberOfArgs('Transaction.get', arguments, 1);\n    const ref = validateReference(\n      'Transaction.get',\n      documentRef,\n      this._firestore\n    );\n    return this._transaction\n      .lookup([ref._key])\n      .then((docs: MaybeDocument[]) => {\n        if (!docs || docs.length !== 1) {\n          return fail('Mismatch in docs returned from document lookup.');\n        }\n        const doc = docs[0];\n        if (doc instanceof NoDocument) {\n          return new DocumentSnapshot(this._firestore, ref._key, null, false);\n        }\n        return new DocumentSnapshot(this._firestore, ref._key, doc, false);\n      });\n  }\n\n  set(\n    documentRef: firestore.DocumentReference,\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): Transaction {\n    validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n    const ref = validateReference(\n      'Transaction.set',\n      documentRef,\n      this._firestore\n    );\n    options = validateSetOptions('Transaction.set', options);\n    const parsed = options.merge\n      ? this._firestore._dataConverter.parseMergeData('Transaction.set', value)\n      : this._firestore._dataConverter.parseSetData('Transaction.set', value);\n    this._transaction.set(ref._key, parsed);\n    return this;\n  }\n\n  update(\n    documentRef: firestore.DocumentReference,\n    value: firestore.UpdateData\n  ): Transaction;\n  update(\n    documentRef: firestore.DocumentReference,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Transaction;\n  update(\n    documentRef: firestore.DocumentReference,\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Transaction {\n    let ref;\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n      ref = validateReference(\n        'Transaction.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateVarargs(\n        'Transaction.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('Transaction.update', arguments, 2);\n      ref = validateReference(\n        'Transaction.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateData(\n        'Transaction.update',\n        fieldOrUpdateData\n      );\n    }\n\n    this._transaction.update(ref._key, parsed);\n    return this;\n  }\n\n  delete(documentRef: firestore.DocumentReference): Transaction {\n    validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n    const ref = validateReference(\n      'Transaction.delete',\n      documentRef,\n      this._firestore\n    );\n    this._transaction.delete(ref._key);\n    return this;\n  }\n}\n\nexport class WriteBatch implements firestore.WriteBatch {\n  private _mutations = [] as Mutation[];\n  private _committed = false;\n\n  constructor(private _firestore: Firestore) {}\n\n  set(\n    documentRef: firestore.DocumentReference,\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): WriteBatch {\n    validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n    this.verifyNotCommitted();\n    const ref = validateReference(\n      'WriteBatch.set',\n      documentRef,\n      this._firestore\n    );\n    options = validateSetOptions('WriteBatch.set', options);\n    const parsed = options.merge\n      ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value)\n      : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);\n    this._mutations = this._mutations.concat(\n      parsed.toMutations(ref._key, Precondition.NONE)\n    );\n    return this;\n  }\n\n  update(\n    documentRef: firestore.DocumentReference,\n    value: firestore.UpdateData\n  ): WriteBatch;\n  update(\n    documentRef: firestore.DocumentReference,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): WriteBatch;\n  update(\n    documentRef: firestore.DocumentReference,\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): WriteBatch {\n    this.verifyNotCommitted();\n\n    let ref;\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n      ref = validateReference(\n        'WriteBatch.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateVarargs(\n        'WriteBatch.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n      ref = validateReference(\n        'WriteBatch.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateData(\n        'WriteBatch.update',\n        fieldOrUpdateData\n      );\n    }\n\n    this._mutations = this._mutations.concat(\n      parsed.toMutations(ref._key, Precondition.exists(true))\n    );\n    return this;\n  }\n\n  delete(documentRef: firestore.DocumentReference): WriteBatch {\n    validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n    this.verifyNotCommitted();\n    const ref = validateReference(\n      'WriteBatch.delete',\n      documentRef,\n      this._firestore\n    );\n    this._mutations = this._mutations.concat(\n      new DeleteMutation(ref._key, Precondition.NONE)\n    );\n    return this;\n  }\n\n  commit(): Promise<void> {\n    this.verifyNotCommitted();\n    this._committed = true;\n    if (this._mutations.length > 0) {\n      return this._firestore.ensureClientConfigured().write(this._mutations);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  private verifyNotCommitted() {\n    if (this._committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'A write batch can no longer be used after commit() ' +\n          'has been called.'\n      );\n    }\n  }\n}\n\n/**\n * A reference to a particular document in a collection in the database.\n */\nexport class DocumentReference implements firestore.DocumentReference {\n  private _firestoreClient: FirestoreClient;\n\n  constructor(public _key: DocumentKey, readonly firestore: Firestore) {\n    this._firestoreClient = this.firestore.ensureClientConfigured();\n  }\n\n  static forPath(path: ResourcePath, firestore: Firestore) {\n    if (path.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid document reference. Document ' +\n          'references must have an even number of segments, but ' +\n          `${path.canonicalString()} has ${path.length}`\n      );\n    }\n    return new DocumentReference(new DocumentKey(path), firestore);\n  }\n\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  get parent(): firestore.CollectionReference {\n    return new CollectionReference(this._key.path.popLast(), this.firestore);\n  }\n\n  get path(): string {\n    return this._key.path.canonicalString();\n  }\n\n  collection(pathString: string): firestore.CollectionReference {\n    validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n    validateArgType('DocumentReference.collection', 'string', 1, pathString);\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty collection name to collection()'\n      );\n    }\n    const path = ResourcePath.fromString(pathString);\n    return new CollectionReference(this._key.path.child(path), this.firestore);\n  }\n\n  isEqual(other: firestore.DocumentReference): boolean {\n    if (!(other instanceof DocumentReference)) {\n      throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n    }\n    return this.firestore === other.firestore && this._key.equals(other._key);\n  }\n\n  set(\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): Promise<void> {\n    validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n    options = validateSetOptions('DocumentReference.set', options);\n\n    const parsed = options.merge\n      ? this.firestore._dataConverter.parseMergeData(\n          'DocumentReference.set',\n          value\n        )\n      : this.firestore._dataConverter.parseSetData(\n          'DocumentReference.set',\n          value\n        );\n    return this._firestoreClient.write(\n      parsed.toMutations(this._key, Precondition.NONE)\n    );\n  }\n\n  update(value: firestore.UpdateData): Promise<void>;\n  update(\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Promise<void>;\n  update(\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Promise<void> {\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n      parsed = this.firestore._dataConverter.parseUpdateVarargs(\n        'DocumentReference.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n      parsed = this.firestore._dataConverter.parseUpdateData(\n        'DocumentReference.update',\n        fieldOrUpdateData\n      );\n    }\n\n    return this._firestoreClient.write(\n      parsed.toMutations(this._key, Precondition.exists(true))\n    );\n  }\n\n  delete(): Promise<void> {\n    validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n    return this._firestoreClient.write([\n      new DeleteMutation(this._key, Precondition.NONE)\n    ]);\n  }\n\n  onSnapshot(\n    observer: PartialObserver<firestore.DocumentSnapshot>\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.DocumentListenOptions,\n    observer: PartialObserver<firestore.DocumentSnapshot>\n  ): Unsubscribe;\n  onSnapshot(\n    onNext: NextFn<firestore.DocumentSnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.DocumentListenOptions,\n    onNext: NextFn<firestore.DocumentSnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n\n  onSnapshot(...args: AnyJs[]): Unsubscribe {\n    validateBetweenNumberOfArgs(\n      'DocumentReference.onSnapshot',\n      arguments,\n      1,\n      4\n    );\n    let options: firestore.DocumentListenOptions = {\n      includeMetadataChanges: false\n    };\n    let observer: PartialObserver<firestore.DocumentSnapshot>;\n    let currArg = 0;\n    if (\n      typeof args[currArg] === 'object' &&\n      !isPartialObserver(args[currArg])\n    ) {\n      options = args[currArg] as firestore.DocumentListenOptions;\n      validateOptionNames('DocumentReference.onSnapshot', options, [\n        'includeMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'DocumentReference.onSnapshot',\n        'boolean',\n        'includeMetadataChanges',\n        options.includeMetadataChanges\n      );\n      currArg++;\n    }\n\n    const internalOptions = {\n      includeDocumentMetadataChanges: options.includeMetadataChanges,\n      includeQueryMetadataChanges: options.includeMetadataChanges\n    };\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg] as PartialObserver<firestore.DocumentSnapshot>;\n    } else {\n      validateArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg,\n        args[currArg]\n      );\n      validateOptionalArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg + 1,\n        args[currArg + 1]\n      );\n      validateOptionalArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg + 2,\n        args[currArg + 2]\n      );\n      observer = {\n        next: args[currArg] as NextFn<firestore.DocumentSnapshot>,\n        error: args[currArg + 1] as ErrorFn,\n        complete: args[currArg + 2] as CompleteFn\n      };\n    }\n    return this.onSnapshotInternal(internalOptions, observer);\n  }\n\n  private onSnapshotInternal(\n    options: ListenOptions,\n    observer: PartialObserver<firestore.DocumentSnapshot>\n  ): Unsubscribe {\n    let errHandler = (err: Error) => {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    const asyncObserver = new AsyncObserver<ViewSnapshot>({\n      next: snapshot => {\n        if (observer.next) {\n          assert(\n            snapshot.docs.size <= 1,\n            'Too many documents returned on a document query'\n          );\n          const doc = snapshot.docs.get(this._key);\n\n          observer.next(\n            new DocumentSnapshot(\n              this.firestore,\n              this._key,\n              doc,\n              snapshot.fromCache\n            )\n          );\n        }\n      },\n      error: errHandler\n    });\n    const internalListener = this._firestoreClient.listen(\n      InternalQuery.atPath(this._key.path),\n      asyncObserver,\n      options\n    );\n\n    return () => {\n      asyncObserver.mute();\n      this._firestoreClient.unlisten(internalListener);\n    };\n  }\n\n  get(): Promise<firestore.DocumentSnapshot> {\n    validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n    return new Promise(\n      (resolve: Resolver<firestore.DocumentSnapshot>, reject: Rejecter) => {\n        const unlisten = this.onSnapshotInternal(\n          {\n            includeQueryMetadataChanges: true,\n            includeDocumentMetadataChanges: true,\n            waitForSyncWhenOnline: true\n          },\n          {\n            next: (snap: firestore.DocumentSnapshot) => {\n              // Remove query first before passing event to user to avoid\n              // user actions affecting the now stale query.\n              unlisten();\n\n              if (!snap.exists && snap.metadata.fromCache) {\n                // TODO(dimond): If we're online and the document doesn't\n                // exist then we resolve with a doc.exists set to false. If\n                // we're offline however, we reject the Promise in this\n                // case. Two options: 1) Cache the negative response from\n                // the server so we can deliver that even when you're\n                // offline 2) Actually reject the Promise in the online case\n                // if the document doesn't exist.\n                reject(\n                  new FirestoreError(\n                    Code.ABORTED,\n                    'Failed to get document because the client is ' + 'offline.'\n                  )\n                );\n              } else {\n                resolve(snap);\n              }\n            },\n            error: reject\n          }\n        );\n      }\n    );\n  }\n}\n\nexport class DocumentSnapshot implements firestore.DocumentSnapshot {\n  constructor(\n    private _firestore: Firestore,\n    private _key: DocumentKey,\n    public _document: Document | null,\n    private _fromCache: boolean\n  ) {}\n\n  data(): firestore.DocumentData {\n    validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);\n    if (!this._document) {\n      throw new FirestoreError(\n        Code.NOT_FOUND,\n        \"This document doesn't exist. Check doc.exists to make sure \" +\n          'the document exists before calling doc.data().'\n      );\n    }\n    return this.convertObject(this._document.data);\n  }\n\n  get(fieldPath: string | ExternalFieldPath): AnyJs {\n    validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);\n    if (!this._document) {\n      throw new FirestoreError(\n        Code.NOT_FOUND,\n        \"This document doesn't exist. Check doc.exists to make sure \" +\n          'the document exists before calling doc.get().'\n      );\n    }\n    const value = this._document.data.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    return value === undefined ? undefined : this.convertValue(value);\n  }\n\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  get ref(): firestore.DocumentReference {\n    return new DocumentReference(this._key, this._firestore);\n  }\n\n  get exists(): boolean {\n    return this._document !== null;\n  }\n\n  get metadata(): firestore.SnapshotMetadata {\n    return {\n      hasPendingWrites:\n        this._document !== null && this._document.hasLocalMutations,\n      fromCache: this._fromCache\n    };\n  }\n\n  private convertObject(data: ObjectValue): firestore.DocumentData {\n    const result: firestore.DocumentData = {};\n    data.forEach((key, value) => {\n      result[key] = this.convertValue(value);\n    });\n    return result;\n  }\n\n  private convertValue(value: FieldValue): AnyJs {\n    if (value instanceof ObjectValue) {\n      return this.convertObject(value);\n    } else if (value instanceof ArrayValue) {\n      return this.convertArray(value);\n    } else if (value instanceof RefValue) {\n      const key = value.value();\n      const database = this._firestore.ensureClientConfigured().databaseId();\n      if (!value.databaseId.equals(database)) {\n        // TODO(b/64130202): Somehow support foreign references.\n        log.error(\n          `Document ${this._key.path} contains a document ` +\n            `reference within a different database (` +\n            `${value.databaseId.projectId}/${\n              value.databaseId.database\n            }) which is not ` +\n            `supported. It will be treated as a reference in the current ` +\n            `database (${database.projectId}/${database.database}) ` +\n            `instead.`\n        );\n      }\n      return new DocumentReference(key, this._firestore);\n    } else {\n      return value.value();\n    }\n  }\n\n  private convertArray(data: ArrayValue): AnyJs[] {\n    return data.internalValue.map(value => {\n      return this.convertValue(value);\n    });\n  }\n}\n\nexport class Query implements firestore.Query {\n  constructor(public _query: InternalQuery, readonly firestore: Firestore) {}\n\n  where(\n    field: string | ExternalFieldPath,\n    opStr: firestore.WhereFilterOp,\n    value: AnyJs\n  ): firestore.Query {\n    validateExactNumberOfArgs('Query.where', arguments, 3);\n    validateArgType('Query.where', 'string', 2, opStr);\n    validateDefined('Query.where', 3, value);\n    let fieldValue;\n    const fieldPath = fieldPathFromArgument('Query.where', field);\n    if (fieldPath.isKeyField()) {\n      if (typeof value === 'string') {\n        if (value.indexOf('/') !== -1) {\n          // TODO(dimond): Allow slashes once ancestor queries are supported\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Function Query.where() requires its third parameter to be a ' +\n              'valid document ID if the first parameter is ' +\n              'FieldPath.documentId(), but it contains a slash.'\n          );\n        }\n        if (value === '') {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Function Query.where() requires its third parameter to be a ' +\n              'valid document ID if the first parameter is ' +\n              'FieldPath.documentId(), but it was an empty string.'\n          );\n        }\n        const path = this._query.path.child(new ResourcePath([value]));\n        assert(path.length % 2 === 0, 'Path should be a document key');\n        fieldValue = new RefValue(\n          this.firestore._databaseId,\n          new DocumentKey(path)\n        );\n      } else if (value instanceof DocumentReference) {\n        const ref = value as DocumentReference;\n        fieldValue = new RefValue(this.firestore._databaseId, ref._key);\n      } else {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Function Query.where() requires its third parameter to be a ` +\n            `string or a DocumentReference if the first parameter is ` +\n            `FieldPath.documentId(), but it was: ` +\n            `${valueDescription(value)}.`\n        );\n      }\n    } else {\n      fieldValue = this.firestore._dataConverter.parseQueryValue(\n        'Query.where',\n        value\n      );\n    }\n    const filter = fieldFilter(\n      fieldPath,\n      RelationOp.fromString(opStr),\n      fieldValue\n    );\n    this.validateNewFilter(filter);\n    return new Query(this._query.addFilter(filter), this.firestore);\n  }\n\n  orderBy(\n    field: string | ExternalFieldPath,\n    directionStr?: firestore.OrderByDirection\n  ): firestore.Query {\n    validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n    validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n    let direction: Direction;\n    if (directionStr === undefined || directionStr === 'asc') {\n      direction = Direction.ASCENDING;\n    } else if (directionStr === 'desc') {\n      direction = Direction.DESCENDING;\n    } else {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function Query.orderBy() has unknown direction '${directionStr}', ` +\n          `expected 'asc' or 'desc'.`\n      );\n    }\n    if (this._query.startAt !== null) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You must not call Query.startAt() or ' +\n          'Query.startAfter() before calling Query.orderBy().'\n      );\n    }\n    if (this._query.endAt !== null) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You must not call Query.endAt() or ' +\n          'Query.endBefore() before calling Query.orderBy().'\n      );\n    }\n    const fieldPath = fieldPathFromArgument('Query.orderBy', field);\n    const orderBy = new OrderBy(fieldPath, direction);\n    this.validateNewOrderBy(orderBy);\n    return new Query(this._query.addOrderBy(orderBy), this.firestore);\n  }\n\n  limit(n: number): firestore.Query {\n    validateExactNumberOfArgs('Query.limit', arguments, 1);\n    validateArgType('Query.limit', 'number', 1, n);\n    if (n <= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. Query limit (${n}) is invalid. Limit must be ` +\n          'positive.'\n      );\n    }\n    return new Query(this._query.withLimit(n), this.firestore);\n  }\n\n  startAt(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.startAt',\n      docOrField,\n      fields,\n      /*before=*/ true\n    );\n    return new Query(this._query.withStartAt(bound), this.firestore);\n  }\n\n  startAfter(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.startAfter',\n      docOrField,\n      fields,\n      /*before=*/ false\n    );\n    return new Query(this._query.withStartAt(bound), this.firestore);\n  }\n\n  endBefore(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.endBefore',\n      docOrField,\n      fields,\n      /*before=*/ true\n    );\n    return new Query(this._query.withEndAt(bound), this.firestore);\n  }\n\n  endAt(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.endAt',\n      docOrField,\n      fields,\n      /*before=*/ false\n    );\n    return new Query(this._query.withEndAt(bound), this.firestore);\n  }\n\n  isEqual(other: firestore.Query): boolean {\n    if (!(other instanceof Query)) {\n      throw invalidClassError('isEqual', 'Query', 1, other);\n    }\n    return (\n      this.firestore === other.firestore && this._query.equals(other._query)\n    );\n  }\n\n  /** Helper function to create a bound from a document or fields */\n  private boundFromDocOrFields(\n    methodName: string,\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    fields: AnyJs[],\n    before: boolean\n  ): Bound {\n    validateDefined(methodName, 1, docOrField);\n    if (docOrField instanceof DocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Too many arguments provided to ${methodName}().`\n        );\n      }\n      const snap = docOrField;\n      if (!snap.exists) {\n        throw new FirestoreError(\n          Code.NOT_FOUND,\n          `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`\n        );\n      }\n      return this.boundFromDocument(methodName, snap._document!, before);\n    } else {\n      const allFields = [docOrField].concat(fields);\n      return this.boundFromFields(methodName, allFields, before);\n    }\n  }\n\n  /**\n   * Create a Bound from a query and a document.\n   *\n   * Note that the Bound will always include the key of the document\n   * and so only the provided document will compare equal to the returned\n   * position.\n   *\n   * Will throw if the document does not contain all fields of the order by\n   * of the query.\n   */\n  private boundFromDocument(\n    methodName: string,\n    doc: Document,\n    before: boolean\n  ): Bound {\n    const components: FieldValue[] = [];\n\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of this._query.orderBy) {\n      if (orderBy.field.isKeyField()) {\n        components.push(new RefValue(this.firestore._databaseId, doc.key));\n      } else {\n        const value = doc.field(orderBy.field);\n        if (value !== undefined) {\n          components.push(value);\n        } else {\n          const field = orderBy.field.canonicalString();\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. You are trying to start or end a query using a ` +\n              `document for which the field '${field}' (used as the ` +\n              `orderBy) does not exist.`\n          );\n        }\n      }\n    }\n    return new Bound(components, before);\n  }\n\n  /**\n   * Converts a list of field values to a Bound for the given query.\n   */\n  private boundFromFields(\n    methodName: string,\n    values: AnyJs[],\n    before: boolean\n  ): Bound {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = this._query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Too many arguments provided to ${methodName}(). ` +\n          `The number of arguments must be less than or equal to the ` +\n          `number of Query.orderBy() clauses`\n      );\n    }\n\n    const components: FieldValue[] = [];\n    for (let i = 0; i < values.length; i++) {\n      const rawValue = values[i];\n      const orderByComponent = orderBy[i];\n      if (orderByComponent.field.isKeyField()) {\n        if (typeof rawValue !== 'string') {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. Expected a string for document ID in ` +\n              `${methodName}(), but got a ${typeof rawValue}`\n          );\n        }\n        if (rawValue.indexOf('/') !== -1) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. Document ID '${rawValue}' contains a slash in ` +\n              `${methodName}()`\n          );\n        }\n        const key = new DocumentKey(this._query.path.child(rawValue));\n        components.push(new RefValue(this.firestore._databaseId, key));\n      } else {\n        const wrapped = this.firestore._dataConverter.parseQueryValue(\n          methodName,\n          rawValue\n        );\n        components.push(wrapped);\n      }\n    }\n\n    return new Bound(components, before);\n  }\n\n  onSnapshot(observer: PartialObserver<firestore.QuerySnapshot>): Unsubscribe;\n  onSnapshot(\n    options: firestore.QueryListenOptions,\n    observer: PartialObserver<firestore.QuerySnapshot>\n  ): Unsubscribe;\n  onSnapshot(\n    onNext: NextFn<firestore.QuerySnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.QueryListenOptions,\n    onNext: NextFn<firestore.QuerySnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n\n  onSnapshot(...args: AnyJs[]): Unsubscribe {\n    validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n    let options: firestore.QueryListenOptions = {};\n    let observer: PartialObserver<firestore.QuerySnapshot>;\n    let currArg = 0;\n    if (\n      typeof args[currArg] === 'object' &&\n      !isPartialObserver(args[currArg])\n    ) {\n      options = args[currArg] as firestore.QueryListenOptions;\n      validateOptionNames('Query.onSnapshot', options, [\n        'includeQueryMetadataChanges',\n        'includeDocumentMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'Query.onSnapshot',\n        'boolean',\n        'includeDocumentMetadataChanges',\n        options.includeDocumentMetadataChanges\n      );\n      validateNamedOptionalType(\n        'Query.onSnapshot',\n        'boolean',\n        'includeQueryMetadataChanges',\n        options.includeQueryMetadataChanges\n      );\n      currArg++;\n    }\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg] as PartialObserver<firestore.QuerySnapshot>;\n    } else {\n      validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n      validateOptionalArgType(\n        'Query.onSnapshot',\n        'function',\n        currArg + 1,\n        args[currArg + 1]\n      );\n      validateOptionalArgType(\n        'Query.onSnapshot',\n        'function',\n        currArg + 2,\n        args[currArg + 2]\n      );\n      observer = {\n        next: args[currArg] as NextFn<firestore.QuerySnapshot>,\n        error: args[currArg + 1] as ErrorFn,\n        complete: args[currArg + 2] as CompleteFn\n      };\n    }\n    return this.onSnapshotInternal(options, observer);\n  }\n\n  private onSnapshotInternal(\n    options: ListenOptions,\n    observer: PartialObserver<firestore.QuerySnapshot>\n  ): Unsubscribe {\n    let errHandler = (err: Error) => {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    const asyncObserver = new AsyncObserver<ViewSnapshot>({\n      next: (result: ViewSnapshot): void => {\n        if (observer.next) {\n          observer.next(new QuerySnapshot(this.firestore, this._query, result));\n        }\n      },\n      error: errHandler\n    });\n\n    const firestoreClient = this.firestore.ensureClientConfigured();\n    const internalListener = firestoreClient.listen(\n      this._query,\n      asyncObserver,\n      options\n    );\n    return () => {\n      asyncObserver.mute();\n      firestoreClient.unlisten(internalListener);\n    };\n  }\n\n  get(): Promise<firestore.QuerySnapshot> {\n    validateExactNumberOfArgs('Query.get', arguments, 0);\n    return new Promise(\n      (resolve: Resolver<firestore.QuerySnapshot>, reject: Rejecter) => {\n        const unlisten = this.onSnapshotInternal(\n          {\n            includeDocumentMetadataChanges: false,\n            includeQueryMetadataChanges: true,\n            waitForSyncWhenOnline: true\n          },\n          {\n            next: (result: firestore.QuerySnapshot) => {\n              // Remove query first before passing event to user to avoid\n              // user actions affecting the now stale query.\n              unlisten();\n\n              resolve(result);\n            },\n            error: reject\n          }\n        );\n      }\n    );\n  }\n\n  private validateNewFilter(filter: Filter): void {\n    if (filter instanceof RelationFilter && filter.isInequality()) {\n      const existingField = this._query.getInequalityFilterField();\n      if (existingField !== null && !existingField.equals(filter.field)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. All where filters with an inequality' +\n            ' (<, <=, >, or >=) must be on the same field. But you have' +\n            ` inequality filters on '${existingField.toString()}'` +\n            ` and '${filter.field.toString()}'`\n        );\n      }\n\n      const firstOrderByField = this._query.getFirstOrderByField();\n      if (firstOrderByField !== null) {\n        this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n      }\n    }\n  }\n\n  private validateNewOrderBy(orderBy: OrderBy): void {\n    if (this._query.getFirstOrderByField() === null) {\n      // This is the first order by. It must match any inequality.\n      const inequalityField = this._query.getInequalityFilterField();\n      if (inequalityField !== null) {\n        this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n      }\n    }\n  }\n\n  private validateOrderByAndInequalityMatch(\n    inequality: FieldPath,\n    orderBy: FieldPath\n  ): void {\n    if (!orderBy.equals(inequality)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. You have a where filter with an inequality ` +\n          `(<, <=, >, or >=) on field '${inequality.toString()}' ` +\n          `and so you must also use '${inequality.toString()}' ` +\n          `as your first Query.orderBy(), but your first Query.orderBy() ` +\n          `is on field '${orderBy.toString()}' instead.`\n      );\n    }\n  }\n}\n\nexport class QuerySnapshot implements firestore.QuerySnapshot {\n  private _cachedChanges: firestore.DocumentChange[] | null = null;\n\n  readonly metadata: firestore.SnapshotMetadata;\n\n  constructor(\n    private _firestore: Firestore,\n    private _originalQuery: InternalQuery,\n    private _snapshot: ViewSnapshot\n  ) {\n    this.metadata = {\n      fromCache: _snapshot.fromCache,\n      hasPendingWrites: _snapshot.hasPendingWrites\n    };\n  }\n\n  get docs(): firestore.DocumentSnapshot[] {\n    const result: firestore.DocumentSnapshot[] = [];\n    this.forEach(doc => result.push(doc));\n    return result;\n  }\n\n  get empty(): boolean {\n    return this._snapshot.docs.isEmpty();\n  }\n\n  get size(): number {\n    return this._snapshot.docs.size;\n  }\n\n  forEach(\n    callback: (result: firestore.DocumentSnapshot) => void,\n    thisArg?: AnyJs\n  ): void {\n    validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n    validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n    this._snapshot.docs.forEach(doc => {\n      callback.call(thisArg, this.convertToDocumentImpl(doc));\n    });\n  }\n\n  get query(): firestore.Query {\n    return new Query(this._originalQuery, this._firestore);\n  }\n\n  get docChanges(): firestore.DocumentChange[] {\n    if (!this._cachedChanges) {\n      this._cachedChanges = changesFromSnapshot(\n        this._firestore,\n        this._snapshot\n      );\n    }\n    return this._cachedChanges;\n  }\n\n  private convertToDocumentImpl(doc: Document): DocumentSnapshot {\n    return new DocumentSnapshot(\n      this._firestore,\n      doc.key,\n      doc,\n      this.metadata.fromCache\n    );\n  }\n}\n\nexport class CollectionReference extends Query\n  implements firestore.CollectionReference {\n  constructor(path: ResourcePath, firestore: Firestore) {\n    super(InternalQuery.atPath(path), firestore);\n    if (path.length % 2 !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid collection reference. Collection ' +\n          'references must have an odd number of segments, but ' +\n          `${path.canonicalString()} has ${path.length}`\n      );\n    }\n  }\n\n  get id(): string {\n    return this._query.path.lastSegment();\n  }\n\n  get parent(): firestore.DocumentReference | null {\n    const parentPath = this._query.path.popLast();\n    if (parentPath.isEmpty()) {\n      return null;\n    } else {\n      return new DocumentReference(new DocumentKey(parentPath), this.firestore);\n    }\n  }\n\n  get path(): string {\n    return this._query.path.canonicalString();\n  }\n\n  doc(pathString?: string): firestore.DocumentReference {\n    validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 0) {\n      pathString = AutoId.newId();\n    }\n    validateArgType('CollectionReference.doc', 'string', 1, pathString);\n    if (pathString === '') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Document path must be a non-empty string'\n      );\n    }\n    const path = ResourcePath.fromString(pathString);\n    return DocumentReference.forPath(\n      this._query.path.child(path),\n      this.firestore\n    );\n  }\n\n  add(value: firestore.DocumentData): Promise<firestore.DocumentReference> {\n    validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n    validateArgType('CollectionReference.add', 'object', 1, value);\n    const docRef = this.doc();\n    return docRef.set(value).then(() => docRef);\n  }\n}\n\nfunction validateSetOptions(\n  methodName: string,\n  options: firestore.SetOptions | undefined\n): firestore.SetOptions {\n  if (options === undefined) {\n    return {\n      merge: false\n    };\n  }\n\n  validateOptionNames(methodName, options, ['merge']);\n  validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n  return options;\n}\n\nfunction validateReference(\n  methodName: string,\n  documentRef: firestore.DocumentReference,\n  firestore: Firestore\n): DocumentReference {\n  if (!(documentRef instanceof DocumentReference)) {\n    throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n  } else if (documentRef.firestore !== firestore) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Provided document reference is from a different Firestore instance.'\n    );\n  } else {\n    return documentRef;\n  }\n}\n\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nexport function changesFromSnapshot(\n  firestore: Firestore,\n  snapshot: ViewSnapshot\n): firestore.DocumentChange[] {\n  if (snapshot.oldDocs.isEmpty()) {\n    // Special case the first snapshot because index calculation is easy and\n    // fast\n    let lastDoc: Document;\n    let index = 0;\n    return snapshot.docChanges.map(change => {\n      const doc = new DocumentSnapshot(\n        firestore,\n        change.doc.key,\n        change.doc,\n        snapshot.fromCache\n      );\n      assert(\n        change.type === ChangeType.Added,\n        'Invalid event type for first snapshot'\n      );\n      assert(\n        !lastDoc || snapshot.query.docComparator(lastDoc, change.doc) < 0,\n        'Got added events in wrong order'\n      );\n      lastDoc = change.doc;\n      return {\n        type: 'added' as firestore.DocumentChangeType,\n        doc,\n        oldIndex: -1,\n        newIndex: index++\n      };\n    });\n  } else {\n    // A DocumentSet that is updated incrementally as changes are applied to use\n    // to lookup the index of a document.\n    let indexTracker = snapshot.oldDocs;\n    return snapshot.docChanges.map(change => {\n      const doc = new DocumentSnapshot(\n        firestore,\n        change.doc.key,\n        change.doc,\n        snapshot.fromCache\n      );\n      let oldIndex = -1;\n      let newIndex = -1;\n      if (change.type !== ChangeType.Added) {\n        oldIndex = indexTracker.indexOf(change.doc.key);\n        assert(oldIndex >= 0, 'Index for document not found');\n        indexTracker = indexTracker.delete(change.doc.key);\n      }\n      if (change.type !== ChangeType.Removed) {\n        indexTracker = indexTracker.add(change.doc);\n        newIndex = indexTracker.indexOf(change.doc.key);\n      }\n      return { type: resultChangeType(change.type), doc, oldIndex, newIndex };\n    });\n  }\n}\n\nfunction resultChangeType(type: ChangeType): firestore.DocumentChangeType {\n  switch (type) {\n    case ChangeType.Added:\n      return 'added';\n    case ChangeType.Modified:\n    case ChangeType.Metadata:\n      return 'modified';\n    case ChangeType.Removed:\n      return 'removed';\n    default:\n      return fail('Unknown change type: ' + type);\n  }\n}\n\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nexport const PublicFirestore = makeConstructorPrivate(\n  Firestore,\n  'Use firebase.firestore() instead.'\n);\nexport const PublicTransaction = makeConstructorPrivate(\n  Transaction,\n  'Use firebase.firestore().runTransaction() instead.'\n);\nexport const PublicWriteBatch = makeConstructorPrivate(\n  WriteBatch,\n  'Use firebase.firestore().batch() instead.'\n);\nexport const PublicDocumentReference = makeConstructorPrivate(\n  DocumentReference,\n  'Use firebase.firestore().doc() instead.'\n);\nexport const PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport const PublicQuery = makeConstructorPrivate(Query);\nexport const PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport const PublicCollectionReference = makeConstructorPrivate(\n  CollectionReference,\n  'Use firebase.firestore().collection() instead.'\n);\n// tslint:enable:variable-name\n"]},"metadata":{},"sourceType":"module"}