{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet, documentVersionMap } from './collections';\nimport { assert } from '../util/assert';\nimport * as misc from '../util/misc';\nexport var BATCHID_UNKNOWN = -1;\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\n\nvar MutationBatch =\n/** @class */\nfunction () {\n  function MutationBatch(batchId, localWriteTime, mutations) {\n    this.batchId = batchId;\n    this.localWriteTime = localWriteTime;\n    this.mutations = mutations;\n  }\n  /**\n   * Applies all the mutations in this MutationBatch to the specified document\n   * to create a new remote document\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   * @param batchResult The result of applying the MutationBatch to the\n   * backend.\n   */\n\n\n  MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {\n    if (maybeDoc) {\n      assert(maybeDoc.key.equals(docKey), \"applyToRemoteDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n    }\n\n    var mutationResults = batchResult.mutationResults;\n    assert(mutationResults.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + mutationResults.length + \").\");\n\n    for (var i = 0; i < this.mutations.length; i++) {\n      var mutation = this.mutations[i];\n\n      if (mutation.key.equals(docKey)) {\n        var mutationResult = mutationResults[i];\n        maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n      }\n    }\n\n    return maybeDoc;\n  };\n  /**\n   * Computes the local view of a document given all the mutations in this\n   * batch.\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   */\n\n\n  MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {\n    if (maybeDoc) {\n      assert(maybeDoc.key.equals(docKey), \"applyToLocalDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n    }\n\n    for (var i = 0; i < this.mutations.length; i++) {\n      var mutation = this.mutations[i];\n\n      if (mutation.key.equals(docKey)) {\n        maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);\n      }\n    }\n\n    return maybeDoc;\n  };\n\n  MutationBatch.prototype.keys = function () {\n    var keySet = documentKeySet();\n\n    for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {\n      var mutation = _a[_i];\n      keySet = keySet.add(mutation.key);\n    }\n\n    return keySet;\n  };\n\n  MutationBatch.prototype.equals = function (other) {\n    return this.batchId === other.batchId && misc.arrayEquals(this.mutations, other.mutations);\n  };\n  /**\n   * Returns true if this mutation batch has already been removed from the\n   * mutation queue.\n   *\n   * Note that not all implementations of the MutationQueue necessarily use\n   * tombstones as part of their implementation and generally speaking no code\n   * outside the mutation queues should really care about this.\n   */\n\n\n  MutationBatch.prototype.isTombstone = function () {\n    return this.mutations.length === 0;\n  };\n  /** Converts this batch into a tombstone */\n\n\n  MutationBatch.prototype.toTombstone = function () {\n    return new MutationBatch(this.batchId, this.localWriteTime, []);\n  };\n\n  return MutationBatch;\n}();\n\nexport { MutationBatch };\n/** The result of applying a mutation batch to the backend. */\n\nvar MutationBatchResult =\n/** @class */\nfunction () {\n  function MutationBatchResult(batch, commitVersion, mutationResults, streamToken,\n  /**\n   * A pre-computed mapping from each mutated document to the resulting\n   * version.\n   */\n  docVersions) {\n    this.batch = batch;\n    this.commitVersion = commitVersion;\n    this.mutationResults = mutationResults;\n    this.streamToken = streamToken;\n    this.docVersions = docVersions;\n  }\n  /**\n   * Creates a new MutationBatchResult for the given batch and results. There\n   * must be one result for each mutation in the batch. This static factory\n   * caches a document=>version mapping (docVersions).\n   */\n\n\n  MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {\n    assert(batch.mutations.length === results.length, 'Mutations sent ' + batch.mutations.length + ' must equal results received ' + results.length);\n    var versionMap = documentVersionMap();\n    var mutations = batch.mutations;\n\n    for (var i = 0; i < mutations.length; i++) {\n      var version = results[i].version;\n\n      if (version === null) {\n        // deletes don't have a version, so we substitute the commitVersion\n        // of the entire batch.\n        version = commitVersion;\n      }\n\n      versionMap = versionMap.insert(mutations[i].key, version);\n    }\n\n    return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);\n  };\n\n  return MutationBatchResult;\n}();\n\nexport { MutationBatchResult };","map":{"version":3,"sources":["../src/model/mutation_batch.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAKH,SACE,cADF,EAIE,kBAJF,QAKO,eALP;AASA,SAAS,MAAT,QAAuB,gBAAvB;AACA,OAAO,KAAK,IAAZ,MAAsB,cAAtB;AAEA,OAAO,IAAM,eAAe,GAAG,CAAC,CAAzB;AAEP;;AAEG;;AACH,IAAA,aAAA;AAAA;AAAA,YAAA;AACE,WAAA,aAAA,CACS,OADT,EAES,cAFT,EAGS,SAHT,EAG8B;AAFrB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACL;AAEJ;;;;;;;;AAQG;;;AACH,EAAA,aAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UACE,MADF,EAEE,QAFF,EAGE,WAHF,EAGkC;AAEhC,QAAI,QAAJ,EAAc;AACZ,MAAA,MAAM,CACJ,QAAQ,CAAC,GAAT,CAAa,MAAb,CAAoB,MAApB,CADI,EAEJ,gCAA8B,MAA9B,GAAoC,sCAApC,GACE,QAAQ,CAAC,GAHP,CAAN;AAKD;;AAED,QAAM,eAAe,GAAG,WAAW,CAAC,eAApC;AACA,IAAA,MAAM,CACJ,eAAe,CAAC,MAAhB,KAA2B,KAAK,SAAL,CAAe,MADtC,EAEJ,+CACG,KAAK,SAAL,CAAe,MADlB,GACwB,wCADxB,GAEG,eAAe,CAAC,MAFnB,GAEyB,IAJrB,CAAN;;AAOA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,SAAL,CAAe,MAAnC,EAA2C,CAAC,EAA5C,EAAgD;AAC9C,UAAM,QAAQ,GAAG,KAAK,SAAL,CAAe,CAAf,CAAjB;;AACA,UAAI,QAAQ,CAAC,GAAT,CAAa,MAAb,CAAoB,MAApB,CAAJ,EAAiC;AAC/B,YAAM,cAAc,GAAG,eAAe,CAAC,CAAD,CAAtC;AACA,QAAA,QAAQ,GAAG,QAAQ,CAAC,qBAAT,CAA+B,QAA/B,EAAyC,cAAzC,CAAX;AACD;AACF;;AACD,WAAO,QAAP;AACD,GA7BD;AA+BA;;;;;;AAMG;;;AACH,EAAA,aAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UACE,MADF,EAEE,QAFF,EAEgC;AAE9B,QAAI,QAAJ,EAAc;AACZ,MAAA,MAAM,CACJ,QAAQ,CAAC,GAAT,CAAa,MAAb,CAAoB,MAApB,CADI,EAEJ,+BAA6B,MAA7B,GAAmC,sCAAnC,GACE,QAAQ,CAAC,GAHP,CAAN;AAKD;;AAED,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,SAAL,CAAe,MAAnC,EAA2C,CAAC,EAA5C,EAAgD;AAC9C,UAAM,QAAQ,GAAG,KAAK,SAAL,CAAe,CAAf,CAAjB;;AACA,UAAI,QAAQ,CAAC,GAAT,CAAa,MAAb,CAAoB,MAApB,CAAJ,EAAiC;AAC/B,QAAA,QAAQ,GAAG,QAAQ,CAAC,gBAAT,CAA0B,QAA1B,EAAoC,KAAK,cAAzC,CAAX;AACD;AACF;;AACD,WAAO,QAAP;AACD,GAnBD;;AAqBA,EAAA,aAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,QAAI,MAAM,GAAG,cAAc,EAA3B;;AAEA,SAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,SAA5B,EAAuB,EAAA,GAAA,EAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAAqC;AAAhC,UAAM,QAAQ,GAAA,EAAA,CAAA,EAAA,CAAd;AACH,MAAA,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,QAAQ,CAAC,GAApB,CAAT;AACD;;AACD,WAAO,MAAP;AACD,GAPD;;AASA,EAAA,aAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAA2B;AACzB,WACE,KAAK,OAAL,KAAiB,KAAK,CAAC,OAAvB,IACA,IAAI,CAAC,WAAL,CAAiB,KAAK,SAAtB,EAAiC,KAAK,CAAC,SAAvC,CAFF;AAID,GALD;AAOA;;;;;;;AAOG;;;AACH,EAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,WAAO,KAAK,SAAL,CAAe,MAAf,KAA0B,CAAjC;AACD,GAFD;AAIA;;;AACA,EAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,WAAO,IAAI,aAAJ,CAAkB,KAAK,OAAvB,EAAgC,KAAK,cAArC,EAAqD,EAArD,CAAP;AACD,GAFD;;AAGF,SAAA,aAAA;AAAC,CA3GD,EAAA;;;AA6GA;;AACA,IAAA,mBAAA;AAAA;AAAA,YAAA;AACE,WAAA,mBAAA,CACW,KADX,EAEW,aAFX,EAGW,eAHX,EAIW,WAJX;AAKE;;;AAGG;AACM,EAAA,WATX,EAS0C;AAR/B,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,aAAA,GAAA,aAAA;AACA,SAAA,eAAA,GAAA,eAAA;AACA,SAAA,WAAA,GAAA,WAAA;AAKA,SAAA,WAAA,GAAA,WAAA;AACP;AAEJ;;;;AAIG;;;AACI,EAAA,mBAAA,CAAA,IAAA,GAAP,UACE,KADF,EAEE,aAFF,EAGE,OAHF,EAIE,WAJF,EAI8B;AAE5B,IAAA,MAAM,CACJ,KAAK,CAAC,SAAN,CAAgB,MAAhB,KAA2B,OAAO,CAAC,MAD/B,EAEJ,oBACE,KAAK,CAAC,SAAN,CAAgB,MADlB,GAEE,+BAFF,GAGE,OAAO,CAAC,MALN,CAAN;AAQA,QAAI,UAAU,GAAG,kBAAkB,EAAnC;AACA,QAAM,SAAS,GAAG,KAAK,CAAC,SAAxB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,UAAI,OAAO,GAAG,OAAO,CAAC,CAAD,CAAP,CAAW,OAAzB;;AACA,UAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA;AACA,QAAA,OAAO,GAAG,aAAV;AACD;;AAED,MAAA,UAAU,GAAG,UAAU,CAAC,MAAX,CAAkB,SAAS,CAAC,CAAD,CAAT,CAAa,GAA/B,EAAoC,OAApC,CAAb;AACD;;AAED,WAAO,IAAI,mBAAJ,CACL,KADK,EAEL,aAFK,EAGL,OAHK,EAIL,WAJK,EAKL,UALK,CAAP;AAOD,GAlCM;;AAmCT,SAAA,mBAAA;AAAC,CArDD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  DocumentVersionMap,\n  documentVersionMap\n} from './collections';\nimport { MaybeDocument } from './document';\nimport { DocumentKey } from './document_key';\nimport { Mutation, MutationResult } from './mutation';\nimport { assert } from '../util/assert';\nimport * as misc from '../util/misc';\n\nexport const BATCHID_UNKNOWN = -1;\n\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nexport class MutationBatch {\n  constructor(\n    public batchId: BatchId,\n    public localWriteTime: Timestamp,\n    public mutations: Mutation[]\n  ) {}\n\n  /**\n   * Applies all the mutations in this MutationBatch to the specified document\n   * to create a new remote document\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   * @param batchResult The result of applying the MutationBatch to the\n   * backend.\n   */\n  applyToRemoteDocument(\n    docKey: DocumentKey,\n    maybeDoc: MaybeDocument | null,\n    batchResult: MutationBatchResult\n  ): MaybeDocument | null {\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(docKey),\n        `applyToRemoteDocument: key ${docKey} should match maybeDoc key\n        ${maybeDoc.key}`\n      );\n    }\n\n    const mutationResults = batchResult.mutationResults;\n    assert(\n      mutationResults.length === this.mutations.length,\n      `Mismatch between mutations length\n      (${this.mutations.length}) and mutation results length\n      (${mutationResults.length}).`\n    );\n\n    for (let i = 0; i < this.mutations.length; i++) {\n      const mutation = this.mutations[i];\n      if (mutation.key.equals(docKey)) {\n        const mutationResult = mutationResults[i];\n        maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n      }\n    }\n    return maybeDoc;\n  }\n\n  /**\n   * Computes the local view of a document given all the mutations in this\n   * batch.\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   */\n  applyToLocalView(\n    docKey: DocumentKey,\n    maybeDoc: MaybeDocument | null\n  ): MaybeDocument | null {\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(docKey),\n        `applyToLocalDocument: key ${docKey} should match maybeDoc key\n        ${maybeDoc.key}`\n      );\n    }\n\n    for (let i = 0; i < this.mutations.length; i++) {\n      const mutation = this.mutations[i];\n      if (mutation.key.equals(docKey)) {\n        maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);\n      }\n    }\n    return maybeDoc;\n  }\n\n  keys(): DocumentKeySet {\n    let keySet = documentKeySet();\n\n    for (const mutation of this.mutations) {\n      keySet = keySet.add(mutation.key);\n    }\n    return keySet;\n  }\n\n  equals(other: MutationBatch): boolean {\n    return (\n      this.batchId === other.batchId &&\n      misc.arrayEquals(this.mutations, other.mutations)\n    );\n  }\n\n  /**\n   * Returns true if this mutation batch has already been removed from the\n   * mutation queue.\n   *\n   * Note that not all implementations of the MutationQueue necessarily use\n   * tombstones as part of their implementation and generally speaking no code\n   * outside the mutation queues should really care about this.\n   */\n  isTombstone(): boolean {\n    return this.mutations.length === 0;\n  }\n\n  /** Converts this batch into a tombstone */\n  toTombstone(): MutationBatch {\n    return new MutationBatch(this.batchId, this.localWriteTime, []);\n  }\n}\n\n/** The result of applying a mutation batch to the backend. */\nexport class MutationBatchResult {\n  private constructor(\n    readonly batch: MutationBatch,\n    readonly commitVersion: SnapshotVersion,\n    readonly mutationResults: MutationResult[],\n    readonly streamToken: ProtoByteString,\n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    readonly docVersions: DocumentVersionMap\n  ) {}\n\n  /**\n   * Creates a new MutationBatchResult for the given batch and results. There\n   * must be one result for each mutation in the batch. This static factory\n   * caches a document=>version mapping (docVersions).\n   */\n  static from(\n    batch: MutationBatch,\n    commitVersion: SnapshotVersion,\n    results: MutationResult[],\n    streamToken: ProtoByteString\n  ) {\n    assert(\n      batch.mutations.length === results.length,\n      'Mutations sent ' +\n        batch.mutations.length +\n        ' must equal results received ' +\n        results.length\n    );\n\n    let versionMap = documentVersionMap();\n    const mutations = batch.mutations;\n    for (let i = 0; i < mutations.length; i++) {\n      let version = results[i].version;\n      if (version === null) {\n        // deletes don't have a version, so we substitute the commitVersion\n        // of the entire batch.\n        version = commitVersion;\n      }\n\n      versionMap = versionMap.insert(mutations[i].key, version);\n    }\n\n    return new MutationBatchResult(\n      batch,\n      commitVersion,\n      results,\n      streamToken,\n      versionMap\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}