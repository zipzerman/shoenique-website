{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\n\nfunction createSubscribe(executor, onNoObservers) {\n  var proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\nexports.createSubscribe = createSubscribe;\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\n\nvar ObserverProxy =\n/** @class */\nfunction () {\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  function ObserverProxy(executor, onNoObservers) {\n    var _this = this;\n\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0; // Micro-task scheduling by calling task.then().\n\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers; // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n\n    this.task.then(function () {\n      executor(_this);\n    }).catch(function (e) {\n      _this.error(e);\n    });\n  }\n\n  ObserverProxy.prototype.next = function (value) {\n    this.forEachObserver(function (observer) {\n      observer.next(value);\n    });\n  };\n\n  ObserverProxy.prototype.error = function (error) {\n    this.forEachObserver(function (observer) {\n      observer.error(error);\n    });\n    this.close(error);\n  };\n\n  ObserverProxy.prototype.complete = function () {\n    this.forEachObserver(function (observer) {\n      observer.complete();\n    });\n    this.close();\n  };\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n\n\n  ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\n    var _this = this;\n\n    var observer;\n\n    if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n      throw new Error('Missing Observer.');\n    } // Assemble an Observer object when passed as callback functions.\n\n\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver;\n    } else {\n      observer = {\n        next: nextOrObserver,\n        error: error,\n        complete: complete\n      };\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop;\n    }\n\n    if (observer.error === undefined) {\n      observer.error = noop;\n    }\n\n    if (observer.complete === undefined) {\n      observer.complete = noop;\n    }\n\n    var unsub = this.unsubscribeOne.bind(this, this.observers.length); // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n\n    if (this.finalized) {\n      this.task.then(function () {\n        try {\n          if (_this.finalError) {\n            observer.error(_this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {// nothing\n        }\n\n        return;\n      });\n    }\n\n    this.observers.push(observer);\n    return unsub;\n  }; // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n\n\n  ObserverProxy.prototype.unsubscribeOne = function (i) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n    this.observerCount -= 1;\n\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  };\n\n  ObserverProxy.prototype.forEachObserver = function (fn) {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    } // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n\n\n    for (var i = 0; i < this.observers.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }; // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n\n\n  ObserverProxy.prototype.sendOne = function (i, fn) {\n    var _this = this; // Execute the callback asynchronously\n\n\n    this.task.then(function () {\n      if (_this.observers !== undefined && _this.observers[i] !== undefined) {\n        try {\n          fn(_this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  };\n\n  ObserverProxy.prototype.close = function (err) {\n    var _this = this;\n\n    if (this.finalized) {\n      return;\n    }\n\n    this.finalized = true;\n\n    if (err !== undefined) {\n      this.finalError = err;\n    } // Proxy is no longer needed - garbage collect references\n\n\n    this.task.then(function () {\n      _this.observers = undefined;\n      _this.onNoObservers = undefined;\n    });\n  };\n\n  return ObserverProxy;\n}();\n/** Turn synchronous function into one called asynchronously. */\n\n\nfunction async(fn, onError) {\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    Promise.resolve(true).then(function () {\n      fn.apply(void 0, args);\n    }).catch(function (error) {\n      if (onError) {\n        onError(error);\n      }\n    });\n  };\n}\n\nexports.async = async;\n/**\n * Return true if the object passed in implements any of the named methods.\n */\n\nfunction implementsAnyMethods(obj, methods) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n    var method = methods_1[_i];\n\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop() {// do nothing\n}","map":{"version":3,"sources":["../src/subscribe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n"]},"metadata":{},"sourceType":"script"}