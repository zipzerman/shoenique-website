{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert'; // tslint:disable-next-line:class-as-namespace\n\nvar AutoId =\n/** @class */\nfunction () {\n  function AutoId() {}\n\n  AutoId.newId = function () {\n    // Alphanumeric characters\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var autoId = '';\n\n    for (var i = 0; i < 20; i++) {\n      autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n\n    assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n    return autoId;\n  };\n\n  return AutoId;\n}();\n\nexport { AutoId };\nexport function primitiveComparator(left, right) {\n  if (left < right) return -1;\n  if (left > right) return 1;\n  return 0;\n}\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\n\nexport function equals(left, right) {\n  if (left !== null && left !== undefined) {\n    return !!(right && left.equals(right));\n  } else {\n    // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n    // smart enough.\n    return left === right;\n  }\n}\n/** Helper to compare arrays using equals(). */\n\nexport function arrayEquals(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (var i = 0; i < left.length; i++) {\n    if (!left[i].equals(right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\n\nexport function immediatePredecessor(s) {\n  // We can decrement the last character in the string and be done\n  // unless that character is 0 (0x0000), in which case we have to erase the\n  // last character.\n  var lastIndex = s.length - 1;\n\n  if (s.length === 0) {\n    // Special case the empty string.\n    return '';\n  } else if (s.charAt(lastIndex) === '\\0') {\n    return s.substring(0, lastIndex);\n  } else {\n    return s.substring(0, lastIndex) + String.fromCharCode(s.charCodeAt(lastIndex) - 1);\n  }\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\n\nexport function immediateSuccessor(s) {\n  // Return the input string, with an additional NUL byte appended.\n  return s + '\\0';\n}","map":{"version":3,"sources":["../src/util/misc.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAAS,MAAT,QAAuB,UAAvB,C,CAiBA;;AACA,IAAA,MAAA;AAAA;AAAA,YAAA;AAAA,WAAA,MAAA,GAAA,CAYC;;AAXQ,EAAA,MAAA,CAAA,KAAA,GAAP,YAAA;AACE;AACA,QAAM,KAAK,GACT,gEADF;AAEA,QAAI,MAAM,GAAG,EAAb;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAApB,EAAwB,CAAC,EAAzB,EAA6B;AAC3B,MAAA,MAAM,IAAI,KAAK,CAAC,MAAN,CAAa,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,KAAgB,KAAK,CAAC,MAAjC,CAAb,CAAV;AACD;;AACD,IAAA,MAAM,CAAC,MAAM,CAAC,MAAP,KAAkB,EAAnB,EAAuB,sBAAsB,MAA7C,CAAN;AACA,WAAO,MAAP;AACD,GAVM;;AAWT,SAAA,MAAA;AAAC,CAZD,EAAA;;;AAcA,OAAM,SAAA,mBAAA,CAAiC,IAAjC,EAA0C,KAA1C,EAAkD;AACtD,MAAI,IAAI,GAAG,KAAX,EAAkB,OAAO,CAAC,CAAR;AAClB,MAAI,IAAI,GAAG,KAAX,EAAkB,OAAO,CAAP;AAClB,SAAO,CAAP;AACD;AAOD;;AACA,OAAM,SAAA,MAAA,CACJ,IADI,EAEJ,KAFI,EAEuB;AAE3B,MAAI,IAAI,KAAK,IAAT,IAAiB,IAAI,KAAK,SAA9B,EAAyC;AACvC,WAAO,CAAC,EAAE,KAAK,IAAI,IAAI,CAAC,MAAL,CAAY,KAAZ,CAAX,CAAR;AACD,GAFD,MAEO;AACL;AACA;AACA,WAAQ,IAAyB,KAAK,KAAtC;AACD;AACF;AAED;;AACA,OAAM,SAAA,WAAA,CAAyB,IAAzB,EAAoD,KAApD,EAA8D;AAClE,MAAI,IAAI,CAAC,MAAL,KAAgB,KAAK,CAAC,MAA1B,EAAkC;AAChC,WAAO,KAAP;AACD;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,QAAI,CAAC,IAAI,CAAC,CAAD,CAAJ,CAAQ,MAAR,CAAe,KAAK,CAAC,CAAD,CAApB,CAAL,EAA+B;AAC7B,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAA,oBAAA,CAA+B,CAA/B,EAAwC;AAC5C;AACA;AACA;AACA,MAAM,SAAS,GAAG,CAAC,CAAC,MAAF,GAAW,CAA7B;;AACA,MAAI,CAAC,CAAC,MAAF,KAAa,CAAjB,EAAoB;AAClB;AACA,WAAO,EAAP;AACD,GAHD,MAGO,IAAI,CAAC,CAAC,MAAF,CAAS,SAAT,MAAwB,IAA5B,EAAkC;AACvC,WAAO,CAAC,CAAC,SAAF,CAAY,CAAZ,EAAe,SAAf,CAAP;AACD,GAFM,MAEA;AACL,WACE,CAAC,CAAC,SAAF,CAAY,CAAZ,EAAe,SAAf,IACA,MAAM,CAAC,YAAP,CAAoB,CAAC,CAAC,UAAF,CAAa,SAAb,IAA0B,CAA9C,CAFF;AAID;AACF;AAED;;;AAGG;;AACH,OAAM,SAAA,kBAAA,CAA6B,CAA7B,EAAsC;AAC1C;AACA,SAAO,CAAC,GAAG,IAAX;AACD","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from './assert';\n\nexport type EventHandler<E> = (value: E) => void;\n\n/**\n * A union of all of the standard JS types, useful for cases where the type is\n * unknown. Unlike \"any\" this doesn't lose all type-safety, since the consuming\n * code must still cast to a particular type before using it.\n */\nexport type AnyJs = null | undefined | boolean | number | string | object;\n\n// TODO(b/66916745): AnyDuringMigration was used to suppress type check failures\n// that were found during the upgrade to TypeScript 2.4. They need to be audited\n// and fixed.\n// tslint:disable-next-line:no-any\nexport type AnyDuringMigration = any;\n\n// tslint:disable-next-line:class-as-namespace\nexport class AutoId {\n  static newId(): string {\n    // Alphanumeric characters\n    const chars =\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let autoId = '';\n    for (let i = 0; i < 20; i++) {\n      autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n    return autoId;\n  }\n}\n\nexport function primitiveComparator<T>(left: T, right: T): number {\n  if (left < right) return -1;\n  if (left > right) return 1;\n  return 0;\n}\n\n/** Duck-typed interface for objects that have an equals() method. */\nexport interface Equatable<T> {\n  equals(other: T): boolean;\n}\n\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\nexport function equals<T>(\n  left: Equatable<T> | null | undefined,\n  right: T | null | undefined\n): boolean {\n  if (left !== null && left !== undefined) {\n    return !!(right && left.equals(right));\n  } else {\n    // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n    // smart enough.\n    return (left as null | undefined) === right;\n  }\n}\n\n/** Helper to compare arrays using equals(). */\nexport function arrayEquals<T>(left: Array<Equatable<T>>, right: T[]): boolean {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    if (!left[i].equals(right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nexport function immediatePredecessor(s: string): string {\n  // We can decrement the last character in the string and be done\n  // unless that character is 0 (0x0000), in which case we have to erase the\n  // last character.\n  const lastIndex = s.length - 1;\n  if (s.length === 0) {\n    // Special case the empty string.\n    return '';\n  } else if (s.charAt(lastIndex) === '\\0') {\n    return s.substring(0, lastIndex);\n  } else {\n    return (\n      s.substring(0, lastIndex) +\n      String.fromCharCode(s.charCodeAt(lastIndex) - 1)\n    );\n  }\n}\n\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s: string): string {\n  // Return the input string, with an additional NUL byte appended.\n  return s + '\\0';\n}\n"]},"metadata":{},"sourceType":"module"}