{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventManager, QueryListener } from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport { LocalStore } from '../local/local_store';\nimport { MemoryPersistence } from '../local/memory_persistence';\nimport { NoOpGarbageCollector } from '../local/no_op_garbage_collector';\nimport { Datastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { Code } from '../util/error';\nimport { debug } from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'FirestoreClient';\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\n\nvar FirestoreClient =\n/** @class */\nfunction () {\n  function FirestoreClient(platform, databaseInfo, credentials,\n  /**\n   * Asynchronous queue responsible for all of our internal processing. When\n   * we get incoming work from the user (via public API) or the network\n   * (incoming GRPC messages), we should always schedule onto this queue.\n   * This ensures all of our work is properly serialized (e.g. we don't\n   * start processing a new operation while the previous one is waiting for\n   * an async I/O to complete).\n   */\n  asyncQueue) {\n    this.platform = platform;\n    this.databaseInfo = databaseInfo;\n    this.credentials = credentials;\n    this.asyncQueue = asyncQueue;\n  }\n  /**\n   * Starts up the FirestoreClient, returning only whether or not enabling\n   * persistence succeeded.\n   *\n   * The intent here is to \"do the right thing\" as far as users are concerned.\n   * Namely, in cases where offline persistence is requested and possible,\n   * enable it, but otherwise fall back to persistence disabled. For the most\n   * part we expect this to succeed one way or the other so we don't expect our\n   * users to actually wait on the firestore.enablePersistence Promise since\n   * they generally won't care.\n   *\n   * Of course some users actually do care about whether or not persistence\n   * was successfully enabled, so the Promise returned from this method\n   * indicates this outcome.\n   *\n   * This presents a problem though: even before enablePersistence resolves or\n   * rejects, users may have made calls to e.g. firestore.collection() which\n   * means that the FirestoreClient in there will be available and will be\n   * enqueuing actions on the async queue.\n   *\n   * Meanwhile any failure of an operation on the async queue causes it to\n   * panic and reject any further work, on the premise that unhandled errors\n   * are fatal.\n   *\n   * Consequently the fallback is handled internally here in start, and if the\n   * fallback succeeds we signal success to the async queue even though the\n   * start() itself signals failure.\n   *\n   * @param usePersistence Whether or not to attempt to enable persistence.\n   * @returns A deferred result indicating the user-visible result of enabling\n   *     offline persistence. This method will reject this if IndexedDB fails to\n   *     start for any reason. If usePersistence is false this is\n   *     unconditionally resolved.\n   */\n\n\n  FirestoreClient.prototype.start = function (usePersistence) {\n    var _this = this; // We defer our initialization until we get the current user from\n    // setUserChangeListener(). We block the async queue until we got the\n    // initial user and the initialization is completed. This will prevent\n    // any scheduled work from happening before initialization is completed.\n    //\n    // If initializationDone resolved then the FirestoreClient is in a usable\n    // state.\n\n\n    var initializationDone = new Deferred(); // If usePersistence is true, certain classes of errors while starting are\n    // recoverable but only by falling back to persistence disabled.\n    //\n    // If there's an error in the first case but not in recovery we cannot\n    // reject the promise blocking the async queue because this will cause the\n    // async queue to panic.\n\n    var persistenceResult = new Deferred();\n    var initialized = false;\n    this.credentials.setUserChangeListener(function (user) {\n      if (!initialized) {\n        initialized = true;\n\n        _this.initializePersistence(usePersistence, persistenceResult).then(function () {\n          return _this.initializeRest(user);\n        }).then(initializationDone.resolve, initializationDone.reject);\n      } else {\n        _this.asyncQueue.schedule(function () {\n          return _this.handleUserChange(user);\n        });\n      }\n    }); // Block the async queue until initialization is done\n\n    this.asyncQueue.schedule(function () {\n      return initializationDone.promise;\n    }); // Return only the result of enabling persistence. Note that this does not\n    // need to await the completion of initializationDone because the result of\n    // this method should not reflect any other kind of failure to start.\n\n    return persistenceResult.promise;\n  };\n  /** Enables the network connection and requeues all pending operations. */\n\n\n  FirestoreClient.prototype.enableNetwork = function () {\n    var _this = this;\n\n    return this.asyncQueue.schedule(function () {\n      return _this.remoteStore.enableNetwork();\n    });\n  };\n  /**\n   * Initializes persistent storage, attempting to use IndexedDB if\n   * usePersistence is true or memory-only if false.\n   *\n   * If IndexedDB fails because it's already open in another tab or because the\n   * platform can't possibly support our implementation then this method rejects\n   * the persistenceResult and falls back on memory-only persistence.\n   *\n   * @param usePersistence indicates whether or not to use offline persistence\n   * @param persistenceResult A deferred result indicating the user-visible\n   *     result of enabling offline persistence. This method will reject this if\n   *     IndexedDB fails to start for any reason. If usePersistence is false\n   *     this is unconditionally resolved.\n   * @returns a Promise indicating whether or not initialization should\n   *     continue, i.e. that one of the persistence implementations actually\n   *     succeeded.\n   */\n\n\n  FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {\n    var _this = this;\n\n    if (usePersistence) {\n      return this.startIndexedDbPersistence().then(persistenceResult.resolve).catch(function (error) {\n        // Regardless of whether or not the retry succeeds, from an user\n        // perspective, offline persistence has failed.\n        persistenceResult.reject(error); // An unknown failure on the first stage shuts everything down.\n\n        if (!_this.canFallback(error)) {\n          return Promise.reject(error);\n        }\n\n        console.warn('Error enabling offline storage. Falling back to' + ' storage disabled: ' + error);\n        return _this.startMemoryPersistence();\n      });\n    } else {\n      // When usePersistence == false, enabling offline persistence is defined\n      // to unconditionally succeed. This allows start() to have the same\n      // signature for both cases, despite the fact that the returned promise\n      // is only used in the enablePersistence call.\n      persistenceResult.resolve();\n      return this.startMemoryPersistence();\n    }\n  };\n\n  FirestoreClient.prototype.canFallback = function (error) {\n    return error.code === Code.FAILED_PRECONDITION || error.code === Code.UNIMPLEMENTED;\n  };\n  /**\n   * Starts IndexedDB-based persistence.\n   *\n   * @returns A promise indicating success or failure.\n   */\n\n\n  FirestoreClient.prototype.startIndexedDbPersistence = function () {\n    // TODO(http://b/33384523): For now we just disable garbage collection\n    // when persistence is enabled.\n    this.garbageCollector = new NoOpGarbageCollector();\n    var storagePrefix = IndexedDbPersistence.buildStoragePrefix(this.databaseInfo); // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n\n    var serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {\n      useProto3Json: true\n    });\n    this.persistence = new IndexedDbPersistence(storagePrefix, serializer);\n    return this.persistence.start();\n  };\n  /**\n   * Starts Memory-backed persistence. In practice this cannot fail.\n   *\n   * @returns A promise that will successfully resolve.\n   */\n\n\n  FirestoreClient.prototype.startMemoryPersistence = function () {\n    this.garbageCollector = new EagerGarbageCollector();\n    this.persistence = new MemoryPersistence();\n    return this.persistence.start();\n  };\n  /**\n   * Initializes the rest of the FirestoreClient, assuming the initial user\n   * has been obtained from the credential provider and some persistence\n   * implementation is available in this.persistence.\n   */\n\n\n  FirestoreClient.prototype.initializeRest = function (user) {\n    var _this = this;\n\n    return this.platform.loadConnection(this.databaseInfo).then(function (connection) {\n      _this.localStore = new LocalStore(_this.persistence, user, _this.garbageCollector);\n\n      var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);\n\n      var datastore = new Datastore(_this.databaseInfo, _this.asyncQueue, connection, _this.credentials, serializer);\n\n      var onlineStateChangedHandler = function onlineStateChangedHandler(onlineState) {\n        _this.eventMgr.onOnlineStateChanged(onlineState);\n      };\n\n      _this.remoteStore = new RemoteStore(_this.databaseInfo, _this.asyncQueue, _this.localStore, datastore, onlineStateChangedHandler);\n      _this.syncEngine = new SyncEngine(_this.localStore, _this.remoteStore, user); // Setup wiring between sync engine and remote store\n\n      _this.remoteStore.syncEngine = _this.syncEngine;\n      _this.eventMgr = new EventManager(_this.syncEngine); // NOTE: RemoteStore depends on LocalStore (for persisting stream\n      // tokens, refilling mutation queue, etc.) so must be started after\n      // LocalStore.\n\n      return _this.localStore.start();\n    }).then(function () {\n      return _this.remoteStore.start();\n    });\n  };\n\n  FirestoreClient.prototype.handleUserChange = function (user) {\n    this.asyncQueue.verifyOperationInProgress();\n    debug(LOG_TAG, 'User Changed: ' + user.uid);\n    return this.syncEngine.handleUserChange(user);\n  };\n  /** Disables the network connection. Pending operations will not complete. */\n\n\n  FirestoreClient.prototype.disableNetwork = function () {\n    var _this = this;\n\n    return this.asyncQueue.schedule(function () {\n      return _this.remoteStore.disableNetwork();\n    });\n  };\n\n  FirestoreClient.prototype.shutdown = function () {\n    var _this = this;\n\n    return this.asyncQueue.schedule(function () {\n      _this.credentials.removeUserChangeListener();\n\n      return _this.remoteStore.shutdown();\n    }).then(function () {\n      // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n      return _this.persistence.shutdown();\n    });\n  };\n\n  FirestoreClient.prototype.listen = function (query, observer, options) {\n    var _this = this;\n\n    var listener = new QueryListener(query, observer, options);\n    this.asyncQueue.schedule(function () {\n      return _this.eventMgr.listen(listener);\n    });\n    return listener;\n  };\n\n  FirestoreClient.prototype.unlisten = function (listener) {\n    var _this = this;\n\n    this.asyncQueue.schedule(function () {\n      return _this.eventMgr.unlisten(listener);\n    });\n  };\n\n  FirestoreClient.prototype.write = function (mutations) {\n    var _this = this;\n\n    var deferred = new Deferred();\n    this.asyncQueue.schedule(function () {\n      return _this.syncEngine.write(mutations, deferred);\n    });\n    return deferred.promise;\n  };\n\n  FirestoreClient.prototype.databaseId = function () {\n    return this.databaseInfo.databaseId;\n  };\n\n  FirestoreClient.prototype.transaction = function (updateFunction) {\n    var _this = this; // We have to wait for the async queue to be sure syncEngine is initialized.\n\n\n    return this.asyncQueue.schedule(function () {\n      return Promise.resolve();\n    }).then(function () {\n      return _this.syncEngine.runTransaction(updateFunction);\n    });\n  };\n\n  return FirestoreClient;\n}();\n\nexport { FirestoreClient };","map":{"version":3,"sources":["../src/core/firestore_client.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CredentialsProvider } from '../api/credentials';\nimport { User } from '../auth/user';\nimport {\n  EventManager,\n  ListenOptions,\n  Observer,\n  QueryListener\n} from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { GarbageCollector } from '../local/garbage_collector';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport { LocalStore } from '../local/local_store';\nimport { MemoryPersistence } from '../local/memory_persistence';\nimport { NoOpGarbageCollector } from '../local/no_op_garbage_collector';\nimport { Persistence } from '../local/persistence';\nimport { Mutation } from '../model/mutation';\nimport { Platform } from '../platform/platform';\nimport { Datastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { debug } from '../util/log';\nimport { Deferred } from '../util/promise';\n\nimport { DatabaseId, DatabaseInfo } from './database_info';\nimport { Query } from './query';\nimport { Transaction } from './transaction';\nimport { OnlineState } from './types';\nimport { ViewSnapshot } from './view_snapshot';\n\nconst LOG_TAG = 'FirestoreClient';\n\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nexport class FirestoreClient {\n  // NOTE: These should technically have '|undefined' in the types, since\n  // they're initialized asynchronously rather than in the constructor, but\n  // given that all work is done on the async queue and we assert that\n  // initialization completes before any other work is queued, we're cheating\n  // with the types rather than littering the code with '!' or unnecessary\n  // undefined checks.\n  private eventMgr: EventManager;\n  private garbageCollector: GarbageCollector;\n  private persistence: Persistence;\n  private localStore: LocalStore;\n  private remoteStore: RemoteStore;\n  private syncEngine: SyncEngine;\n\n  constructor(\n    private platform: Platform,\n    private databaseInfo: DatabaseInfo,\n    private credentials: CredentialsProvider,\n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    private asyncQueue: AsyncQueue\n  ) {}\n\n  /**\n   * Starts up the FirestoreClient, returning only whether or not enabling\n   * persistence succeeded.\n   *\n   * The intent here is to \"do the right thing\" as far as users are concerned.\n   * Namely, in cases where offline persistence is requested and possible,\n   * enable it, but otherwise fall back to persistence disabled. For the most\n   * part we expect this to succeed one way or the other so we don't expect our\n   * users to actually wait on the firestore.enablePersistence Promise since\n   * they generally won't care.\n   *\n   * Of course some users actually do care about whether or not persistence\n   * was successfully enabled, so the Promise returned from this method\n   * indicates this outcome.\n   *\n   * This presents a problem though: even before enablePersistence resolves or\n   * rejects, users may have made calls to e.g. firestore.collection() which\n   * means that the FirestoreClient in there will be available and will be\n   * enqueuing actions on the async queue.\n   *\n   * Meanwhile any failure of an operation on the async queue causes it to\n   * panic and reject any further work, on the premise that unhandled errors\n   * are fatal.\n   *\n   * Consequently the fallback is handled internally here in start, and if the\n   * fallback succeeds we signal success to the async queue even though the\n   * start() itself signals failure.\n   *\n   * @param usePersistence Whether or not to attempt to enable persistence.\n   * @returns A deferred result indicating the user-visible result of enabling\n   *     offline persistence. This method will reject this if IndexedDB fails to\n   *     start for any reason. If usePersistence is false this is\n   *     unconditionally resolved.\n   */\n  public start(usePersistence: boolean): Promise<void> {\n    // We defer our initialization until we get the current user from\n    // setUserChangeListener(). We block the async queue until we got the\n    // initial user and the initialization is completed. This will prevent\n    // any scheduled work from happening before initialization is completed.\n    //\n    // If initializationDone resolved then the FirestoreClient is in a usable\n    // state.\n    const initializationDone = new Deferred<void>();\n\n    // If usePersistence is true, certain classes of errors while starting are\n    // recoverable but only by falling back to persistence disabled.\n    //\n    // If there's an error in the first case but not in recovery we cannot\n    // reject the promise blocking the async queue because this will cause the\n    // async queue to panic.\n    const persistenceResult = new Deferred<void>();\n\n    let initialized = false;\n    this.credentials.setUserChangeListener(user => {\n      if (!initialized) {\n        initialized = true;\n\n        this.initializePersistence(usePersistence, persistenceResult)\n          .then(() => this.initializeRest(user))\n          .then(initializationDone.resolve, initializationDone.reject);\n      } else {\n        this.asyncQueue.schedule(() => {\n          return this.handleUserChange(user);\n        });\n      }\n    });\n\n    // Block the async queue until initialization is done\n    this.asyncQueue.schedule(() => {\n      return initializationDone.promise;\n    });\n\n    // Return only the result of enabling persistence. Note that this does not\n    // need to await the completion of initializationDone because the result of\n    // this method should not reflect any other kind of failure to start.\n    return persistenceResult.promise;\n  }\n\n  /** Enables the network connection and requeues all pending operations. */\n  public enableNetwork(): Promise<void> {\n    return this.asyncQueue.schedule(() => {\n      return this.remoteStore.enableNetwork();\n    });\n  }\n\n  /**\n   * Initializes persistent storage, attempting to use IndexedDB if\n   * usePersistence is true or memory-only if false.\n   *\n   * If IndexedDB fails because it's already open in another tab or because the\n   * platform can't possibly support our implementation then this method rejects\n   * the persistenceResult and falls back on memory-only persistence.\n   *\n   * @param usePersistence indicates whether or not to use offline persistence\n   * @param persistenceResult A deferred result indicating the user-visible\n   *     result of enabling offline persistence. This method will reject this if\n   *     IndexedDB fails to start for any reason. If usePersistence is false\n   *     this is unconditionally resolved.\n   * @returns a Promise indicating whether or not initialization should\n   *     continue, i.e. that one of the persistence implementations actually\n   *     succeeded.\n   */\n  private initializePersistence(\n    usePersistence: boolean,\n    persistenceResult: Deferred<void>\n  ): Promise<void> {\n    if (usePersistence) {\n      return this.startIndexedDbPersistence()\n        .then(persistenceResult.resolve)\n        .catch((error: FirestoreError) => {\n          // Regardless of whether or not the retry succeeds, from an user\n          // perspective, offline persistence has failed.\n          persistenceResult.reject(error);\n\n          // An unknown failure on the first stage shuts everything down.\n          if (!this.canFallback(error)) {\n            return Promise.reject(error);\n          }\n\n          console.warn(\n            'Error enabling offline storage. Falling back to' +\n              ' storage disabled: ' +\n              error\n          );\n          return this.startMemoryPersistence();\n        });\n    } else {\n      // When usePersistence == false, enabling offline persistence is defined\n      // to unconditionally succeed. This allows start() to have the same\n      // signature for both cases, despite the fact that the returned promise\n      // is only used in the enablePersistence call.\n      persistenceResult.resolve();\n      return this.startMemoryPersistence();\n    }\n  }\n\n  private canFallback(error: FirestoreError): boolean {\n    return (\n      error.code === Code.FAILED_PRECONDITION ||\n      error.code === Code.UNIMPLEMENTED\n    );\n  }\n\n  /**\n   * Starts IndexedDB-based persistence.\n   *\n   * @returns A promise indicating success or failure.\n   */\n  private startIndexedDbPersistence(): Promise<void> {\n    // TODO(http://b/33384523): For now we just disable garbage collection\n    // when persistence is enabled.\n    this.garbageCollector = new NoOpGarbageCollector();\n    const storagePrefix = IndexedDbPersistence.buildStoragePrefix(\n      this.databaseInfo\n    );\n    // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n    const serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {\n      useProto3Json: true\n    });\n    this.persistence = new IndexedDbPersistence(storagePrefix, serializer);\n    return this.persistence.start();\n  }\n\n  /**\n   * Starts Memory-backed persistence. In practice this cannot fail.\n   *\n   * @returns A promise that will successfully resolve.\n   */\n  private startMemoryPersistence(): Promise<void> {\n    this.garbageCollector = new EagerGarbageCollector();\n    this.persistence = new MemoryPersistence();\n    return this.persistence.start();\n  }\n\n  /**\n   * Initializes the rest of the FirestoreClient, assuming the initial user\n   * has been obtained from the credential provider and some persistence\n   * implementation is available in this.persistence.\n   */\n  private initializeRest(user: User): Promise<void> {\n    return this.platform\n      .loadConnection(this.databaseInfo)\n      .then(connection => {\n        this.localStore = new LocalStore(\n          this.persistence,\n          user,\n          this.garbageCollector\n        );\n        const serializer = this.platform.newSerializer(\n          this.databaseInfo.databaseId\n        );\n        const datastore = new Datastore(\n          this.databaseInfo,\n          this.asyncQueue,\n          connection,\n          this.credentials,\n          serializer\n        );\n\n        const onlineStateChangedHandler = (onlineState: OnlineState) => {\n          this.eventMgr.onOnlineStateChanged(onlineState);\n        };\n\n        this.remoteStore = new RemoteStore(\n          this.databaseInfo,\n          this.asyncQueue,\n          this.localStore,\n          datastore,\n          onlineStateChangedHandler\n        );\n\n        this.syncEngine = new SyncEngine(\n          this.localStore,\n          this.remoteStore,\n          user\n        );\n\n        // Setup wiring between sync engine and remote store\n        this.remoteStore.syncEngine = this.syncEngine;\n\n        this.eventMgr = new EventManager(this.syncEngine);\n\n        // NOTE: RemoteStore depends on LocalStore (for persisting stream\n        // tokens, refilling mutation queue, etc.) so must be started after\n        // LocalStore.\n        return this.localStore.start();\n      })\n      .then(() => {\n        return this.remoteStore.start();\n      });\n  }\n\n  private handleUserChange(user: User): Promise<void> {\n    this.asyncQueue.verifyOperationInProgress();\n\n    debug(LOG_TAG, 'User Changed: ' + user.uid);\n    return this.syncEngine.handleUserChange(user);\n  }\n\n  /** Disables the network connection. Pending operations will not complete. */\n  public disableNetwork(): Promise<void> {\n    return this.asyncQueue.schedule(() => {\n      return this.remoteStore.disableNetwork();\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this.asyncQueue\n      .schedule(() => {\n        this.credentials.removeUserChangeListener();\n        return this.remoteStore.shutdown();\n      })\n      .then(() => {\n        // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n        return this.persistence.shutdown();\n      });\n  }\n\n  listen(\n    query: Query,\n    observer: Observer<ViewSnapshot>,\n    options: ListenOptions\n  ): QueryListener {\n    const listener = new QueryListener(query, observer, options);\n    this.asyncQueue.schedule(() => {\n      return this.eventMgr.listen(listener);\n    });\n    return listener;\n  }\n\n  unlisten(listener: QueryListener): void {\n    this.asyncQueue.schedule(() => {\n      return this.eventMgr.unlisten(listener);\n    });\n  }\n\n  write(mutations: Mutation[]): Promise<void> {\n    const deferred = new Deferred<void>();\n    this.asyncQueue.schedule(() => this.syncEngine.write(mutations, deferred));\n    return deferred.promise;\n  }\n\n  databaseId(): DatabaseId {\n    return this.databaseInfo.databaseId;\n  }\n\n  transaction<T>(\n    updateFunction: (transaction: Transaction) => Promise<T>\n  ): Promise<T> {\n    // We have to wait for the async queue to be sure syncEngine is initialized.\n    return this.asyncQueue\n      .schedule(() => {\n        return Promise.resolve();\n      })\n      .then(() => {\n        return this.syncEngine.runTransaction(updateFunction);\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}