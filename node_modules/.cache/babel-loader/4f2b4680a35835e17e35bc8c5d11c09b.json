{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\n\nvar RemoteDocumentChangeBuffer =\n/** @class */\nfunction () {\n  function RemoteDocumentChangeBuffer(remoteDocumentCache) {\n    this.remoteDocumentCache = remoteDocumentCache;\n    this.changes = maybeDocumentMap();\n  }\n  /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n\n\n  RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {\n    var changes = this.assertChanges();\n    this.changes = changes.insert(maybeDocument.key, maybeDocument);\n  }; // NOTE: removeEntry() is not presently necessary and so is omitted.\n\n  /**\n   * Looks up an entry in the cache. The buffered changes will first be checked,\n   * and if no buffered change applies, this will forward to\n   * `RemoteDocumentCache.getEntry()`.\n   *\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the entry to look up.\n   * @return The cached Document or NoDocument entry, or null if we have nothing\n   * cached.\n   */\n\n\n  RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {\n    var changes = this.assertChanges();\n    var bufferedEntry = changes.get(documentKey);\n\n    if (bufferedEntry) {\n      return PersistencePromise.resolve(bufferedEntry);\n    } else {\n      return this.remoteDocumentCache.getEntry(transaction, documentKey);\n    }\n  };\n  /**\n   * Applies buffered changes to the underlying RemoteDocumentCache, using\n   * the provided transaction.\n   */\n\n\n  RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {\n    var _this = this;\n\n    var changes = this.assertChanges();\n    var promises = [];\n    changes.forEach(function (key, maybeDoc) {\n      promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n    }); // We should not be used to buffer any more changes.\n\n    this.changes = null;\n    return PersistencePromise.waitFor(promises);\n  };\n  /** Helper to assert this.changes is not null and return it. */\n\n\n  RemoteDocumentChangeBuffer.prototype.assertChanges = function () {\n    assert(this.changes !== null, 'Changes have already been applied.');\n    return this.changes;\n  };\n\n  return RemoteDocumentChangeBuffer;\n}();\n\nexport { RemoteDocumentChangeBuffer };","map":{"version":3,"sources":["../src/local/remote_document_change_buffer.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAA2B,gBAA3B,QAAmD,sBAAnD;AAGA,SAAS,MAAT,QAAuB,gBAAvB;AAGA,SAAS,kBAAT,QAAmC,uBAAnC;AAGA;;;;;;;;;;;AAWG;;AACH,IAAA,0BAAA;AAAA;AAAA,YAAA;AAGE,WAAA,0BAAA,CAAoB,mBAApB,EAA4D;AAAxC,SAAA,mBAAA,GAAA,mBAAA;AAFZ,SAAA,OAAA,GAAmC,gBAAgB,EAAnD;AAEwD;AAEhE;;;AACA,EAAA,0BAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,aAAT,EAAqC;AACnC,QAAM,OAAO,GAAG,KAAK,aAAL,EAAhB;AACA,SAAK,OAAL,GAAe,OAAO,CAAC,MAAR,CAAe,aAAa,CAAC,GAA7B,EAAkC,aAAlC,CAAf;AACD,GAHD,CANF,CAWE;;AAEA;;;;;;;;;;AAUG;;;AACH,EAAA,0BAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE0B;AAExB,QAAM,OAAO,GAAG,KAAK,aAAL,EAAhB;AAEA,QAAM,aAAa,GAAG,OAAO,CAAC,GAAR,CAAY,WAAZ,CAAtB;;AACA,QAAI,aAAJ,EAAmB;AACjB,aAAO,kBAAkB,CAAC,OAAnB,CAA2B,aAA3B,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAK,mBAAL,CAAyB,QAAzB,CAAkC,WAAlC,EAA+C,WAA/C,CAAP;AACD;AACF,GAZD;AAcA;;;AAGG;;;AACH,EAAA,0BAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,WAAN,EAAyC;AAAzC,QAAA,KAAA,GAAA,IAAA;;AACE,QAAM,OAAO,GAAG,KAAK,aAAL,EAAhB;AAEA,QAAM,QAAQ,GAAoC,EAAlD;AACA,IAAA,OAAO,CAAC,OAAR,CAAgB,UAAC,GAAD,EAAM,QAAN,EAAc;AAC5B,MAAA,QAAQ,CAAC,IAAT,CAAc,KAAI,CAAC,mBAAL,CAAyB,QAAzB,CAAkC,WAAlC,EAA+C,QAA/C,CAAd;AACD,KAFD,EAJuC,CAQvC;;AACA,SAAK,OAAL,GAAe,IAAf;AAEA,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,QAA3B,CAAP;AACD,GAZD;AAcA;;;AACQ,EAAA,0BAAA,CAAA,SAAA,CAAA,aAAA,GAAR,YAAA;AACE,IAAA,MAAM,CAAC,KAAK,OAAL,KAAiB,IAAlB,EAAwB,oCAAxB,CAAN;AACA,WAAO,KAAK,OAAZ;AACD,GAHO;;AAIV,SAAA,0BAAA;AAAC,CA7DD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MaybeDocumentMap, maybeDocumentMap } from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { assert } from '../util/assert';\n\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nexport class RemoteDocumentChangeBuffer {\n  private changes: MaybeDocumentMap | null = maybeDocumentMap();\n\n  constructor(private remoteDocumentCache: RemoteDocumentCache) {}\n\n  /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n  addEntry(maybeDocument: MaybeDocument): void {\n    const changes = this.assertChanges();\n    this.changes = changes.insert(maybeDocument.key, maybeDocument);\n  }\n\n  // NOTE: removeEntry() is not presently necessary and so is omitted.\n\n  /**\n   * Looks up an entry in the cache. The buffered changes will first be checked,\n   * and if no buffered change applies, this will forward to\n   * `RemoteDocumentCache.getEntry()`.\n   *\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the entry to look up.\n   * @return The cached Document or NoDocument entry, or null if we have nothing\n   * cached.\n   */\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    const changes = this.assertChanges();\n\n    const bufferedEntry = changes.get(documentKey);\n    if (bufferedEntry) {\n      return PersistencePromise.resolve(bufferedEntry);\n    } else {\n      return this.remoteDocumentCache.getEntry(transaction, documentKey);\n    }\n  }\n\n  /**\n   * Applies buffered changes to the underlying RemoteDocumentCache, using\n   * the provided transaction.\n   */\n  apply(transaction: PersistenceTransaction): PersistencePromise<void> {\n    const changes = this.assertChanges();\n\n    const promises: Array<PersistencePromise<void>> = [];\n    changes.forEach((key, maybeDoc) => {\n      promises.push(this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n    });\n\n    // We should not be used to buffer any more changes.\n    this.changes = null;\n\n    return PersistencePromise.waitFor(promises);\n  }\n\n  /** Helper to assert this.changes is not null and return it. */\n  private assertChanges(): MaybeDocumentMap {\n    assert(this.changes !== null, 'Changes have already been applied.');\n    return this.changes!;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}