{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { DbMutationBatch, DbNoDocument, DbRemoteDocument, DbTarget, DbTimestamp } from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n/** Serializer for values stored in the LocalStore. */\n\nvar LocalSerializer =\n/** @class */\nfunction () {\n  function LocalSerializer(remoteSerializer) {\n    this.remoteSerializer = remoteSerializer;\n  }\n  /** Decodes a remote document from storage locally to a Document. */\n\n\n  LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n    if (remoteDoc.document) {\n      return this.remoteSerializer.fromDocument(remoteDoc.document);\n    } else if (remoteDoc.noDocument) {\n      var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n      var readTime = remoteDoc.noDocument.readTime;\n      var timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n      return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n    } else {\n      return fail('Unexpected DbRemoteDocument');\n    }\n  };\n  /** Encodes a document for storage locally. */\n\n\n  LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n    if (maybeDoc instanceof Document) {\n      var doc = this.remoteSerializer.toDocument(maybeDoc);\n      return new DbRemoteDocument(null, doc);\n    } else {\n      var path = maybeDoc.key.path.toArray();\n      var timestamp = maybeDoc.version.toTimestamp();\n      var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n      return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n    }\n  };\n  /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n\n\n  LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n    var _this = this;\n\n    var serializedMutations = batch.mutations.map(function (m) {\n      return _this.remoteSerializer.toMutation(m);\n    });\n    return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n  };\n  /** Decodes a DbMutationBatch into a MutationBatch */\n\n\n  LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n    var _this = this;\n\n    var mutations = dbBatch.mutations.map(function (m) {\n      return _this.remoteSerializer.fromMutation(m);\n    });\n    var timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n  };\n  /** Decodes a DbTarget into QueryData */\n\n\n  LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n    var readTime = new Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n    var version = SnapshotVersion.fromTimestamp(readTime);\n    var query;\n\n    if (isDocumentQuery(dbTarget.query)) {\n      query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n    } else {\n      query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n    }\n\n    return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n  };\n  /** Encodes QueryData into a DbTarget for storage locally. */\n\n\n  LocalSerializer.prototype.toDbTarget = function (queryData) {\n    assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' + QueryPurpose.Listen + ' may be stored, got ' + queryData.purpose);\n    var timestamp = queryData.snapshotVersion.toTimestamp();\n    var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n    var queryProto;\n\n    if (queryData.query.isDocumentQuery()) {\n      queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n    } else {\n      queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n    }\n\n    assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n    var resumeToken = queryData.resumeToken; // lastListenSequenceNumber is always 0 until we do real GC.\n\n    return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n  };\n\n  return LocalSerializer;\n}();\n\nexport { LocalSerializer };\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\n\nfunction isDocumentQuery(dbQuery) {\n  return dbQuery.documents !== undefined;\n}","map":{"version":3,"sources":["../src/local/local_serializer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { assert, fail } from '../util/assert';\n\nimport {\n  DbMutationBatch,\n  DbNoDocument,\n  DbQuery,\n  DbRemoteDocument,\n  DbTarget,\n  DbTimestamp\n} from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n\n/** Serializer for values stored in the LocalStore. */\nexport class LocalSerializer {\n  constructor(private remoteSerializer: JsonProtoSerializer) {}\n\n  /** Decodes a remote document from storage locally to a Document. */\n  fromDbRemoteDocument(remoteDoc: DbRemoteDocument): MaybeDocument {\n    if (remoteDoc.document) {\n      return this.remoteSerializer.fromDocument(remoteDoc.document);\n    } else if (remoteDoc.noDocument) {\n      const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n      const readTime = remoteDoc.noDocument.readTime;\n      const timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n      return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n    } else {\n      return fail('Unexpected DbRemoteDocument');\n    }\n  }\n\n  /** Encodes a document for storage locally. */\n  toDbRemoteDocument(maybeDoc: MaybeDocument): DbRemoteDocument {\n    if (maybeDoc instanceof Document) {\n      const doc = this.remoteSerializer.toDocument(maybeDoc);\n      return new DbRemoteDocument(null, doc);\n    } else {\n      const path = maybeDoc.key.path.toArray();\n      const timestamp = maybeDoc.version.toTimestamp();\n      const readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n      return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n    }\n  }\n\n  /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n  toDbMutationBatch(userId: string, batch: MutationBatch): DbMutationBatch {\n    const serializedMutations = batch.mutations.map(m =>\n      this.remoteSerializer.toMutation(m)\n    );\n    return new DbMutationBatch(\n      userId,\n      batch.batchId,\n      batch.localWriteTime.toEpochMilliseconds(),\n      serializedMutations\n    );\n  }\n\n  /** Decodes a DbMutationBatch into a MutationBatch */\n  fromDbMutationBatch(dbBatch: DbMutationBatch): MutationBatch {\n    const mutations = dbBatch.mutations.map(m =>\n      this.remoteSerializer.fromMutation(m)\n    );\n    const timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n  }\n\n  /** Decodes a DbTarget into QueryData */\n  fromDbTarget(dbTarget: DbTarget): QueryData {\n    const readTime = new Timestamp(\n      dbTarget.readTime.seconds,\n      dbTarget.readTime.nanos\n    );\n    const version = SnapshotVersion.fromTimestamp(readTime);\n    let query: Query;\n    if (isDocumentQuery(dbTarget.query)) {\n      query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n    } else {\n      query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n    }\n    return new QueryData(\n      query,\n      dbTarget.targetId,\n      QueryPurpose.Listen,\n      version,\n      dbTarget.resumeToken\n    );\n  }\n\n  /** Encodes QueryData into a DbTarget for storage locally. */\n  toDbTarget(queryData: QueryData): DbTarget {\n    assert(\n      QueryPurpose.Listen === queryData.purpose,\n      'Only queries with purpose ' +\n        QueryPurpose.Listen +\n        ' may be stored, got ' +\n        queryData.purpose\n    );\n    const timestamp = queryData.snapshotVersion.toTimestamp();\n    const dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n    let queryProto: DbQuery;\n    if (queryData.query.isDocumentQuery()) {\n      queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n    } else {\n      queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n    }\n    assert(\n      typeof queryData.resumeToken === 'string',\n      'Persisting non-string resume token not supported.'\n    );\n    const resumeToken = queryData.resumeToken as string;\n\n    // lastListenSequenceNumber is always 0 until we do real GC.\n    return new DbTarget(\n      queryData.targetId,\n      queryData.query.canonicalId(),\n      dbTimestamp,\n      resumeToken,\n      0,\n      queryProto\n    );\n  }\n}\n\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery: DbQuery): dbQuery is api.DocumentsTarget {\n  return (dbQuery as api.DocumentsTarget).documents !== undefined;\n}\n"]},"metadata":{},"sourceType":"module"}