{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { MemoryMutationQueue } from './memory_mutation_queue';\nimport { MemoryQueryCache } from './memory_query_cache';\nimport { MemoryRemoteDocumentCache } from './memory_remote_document_cache';\nvar LOG_TAG = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\n\nvar MemoryPersistence =\n/** @class */\nfunction () {\n  function MemoryPersistence() {\n    /**\n     * Note that these are retained here to make it easier to write tests\n     * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n     * can create a new LocalStore wrapping this Persistence instance and this\n     * will make the in-memory persistence layer behave as if it were actually\n     * persisting values.\n     */\n    this.mutationQueues = {};\n    this.remoteDocumentCache = new MemoryRemoteDocumentCache();\n    this.queryCache = new MemoryQueryCache();\n    this.started = false;\n  }\n\n  MemoryPersistence.prototype.start = function () {\n    assert(!this.started, 'MemoryPersistence double-started!');\n    this.started = true; // No durable state to read on startup.\n\n    return Promise.resolve();\n  };\n\n  MemoryPersistence.prototype.shutdown = function () {\n    // No durable state to ensure is closed on shutdown.\n    assert(this.started, 'MemoryPersistence shutdown without start!');\n    this.started = false;\n    return Promise.resolve();\n  };\n\n  MemoryPersistence.prototype.getMutationQueue = function (user) {\n    var queue = this.mutationQueues[user.toKey()];\n\n    if (!queue) {\n      queue = new MemoryMutationQueue();\n      this.mutationQueues[user.toKey()] = queue;\n    }\n\n    return queue;\n  };\n\n  MemoryPersistence.prototype.getQueryCache = function () {\n    return this.queryCache;\n  };\n\n  MemoryPersistence.prototype.getRemoteDocumentCache = function () {\n    return this.remoteDocumentCache;\n  };\n\n  MemoryPersistence.prototype.runTransaction = function (action, operation) {\n    debug(LOG_TAG, 'Starting transaction:', action);\n    return operation(new MemoryPersistenceTransaction()).toPromise();\n  };\n\n  return MemoryPersistence;\n}();\n\nexport { MemoryPersistence };\n/** Dummy class since memory persistence doesn't actually use transactions. */\n\nvar MemoryPersistenceTransaction =\n/** @class */\nfunction () {\n  function MemoryPersistenceTransaction() {}\n\n  return MemoryPersistenceTransaction;\n}();","map":{"version":3,"sources":["../src/local/memory_persistence.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAGH,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,KAAT,QAAsB,aAAtB;AAEA,SAAS,mBAAT,QAAoC,yBAApC;AACA,SAAS,gBAAT,QAAiC,sBAAjC;AACA,SAAS,yBAAT,QAA0C,gCAA1C;AAOA,IAAM,OAAO,GAAG,mBAAhB;AAEA;;;AAGG;;AACH,IAAA,iBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,iBAAA,GAAA;AACE;;;;;;AAMG;AACK,SAAA,cAAA,GAAoD,EAApD;AACA,SAAA,mBAAA,GAAsB,IAAI,yBAAJ,EAAtB;AACA,SAAA,UAAA,GAAa,IAAI,gBAAJ,EAAb;AAEA,SAAA,OAAA,GAAU,KAAV;AAwCT;;AAtCC,EAAA,iBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,IAAA,MAAM,CAAC,CAAC,KAAK,OAAP,EAAgB,mCAAhB,CAAN;AACA,SAAK,OAAL,GAAe,IAAf,CAFF,CAGE;;AACA,WAAO,OAAO,CAAC,OAAR,EAAP;AACD,GALD;;AAOA,EAAA,iBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE;AACA,IAAA,MAAM,CAAC,KAAK,OAAN,EAAe,2CAAf,CAAN;AACA,SAAK,OAAL,GAAe,KAAf;AACA,WAAO,OAAO,CAAC,OAAR,EAAP;AACD,GALD;;AAOA,EAAA,iBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,IAAjB,EAA2B;AACzB,QAAI,KAAK,GAAG,KAAK,cAAL,CAAoB,IAAI,CAAC,KAAL,EAApB,CAAZ;;AACA,QAAI,CAAC,KAAL,EAAY;AACV,MAAA,KAAK,GAAG,IAAI,mBAAJ,EAAR;AACA,WAAK,cAAL,CAAoB,IAAI,CAAC,KAAL,EAApB,IAAoC,KAApC;AACD;;AACD,WAAO,KAAP;AACD,GAPD;;AASA,EAAA,iBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACE,WAAO,KAAK,UAAZ;AACD,GAFD;;AAIA,EAAA,iBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,YAAA;AACE,WAAO,KAAK,mBAAZ;AACD,GAFD;;AAIA,EAAA,iBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UACE,MADF,EAEE,SAFF,EAE2E;AAEzE,IAAA,KAAK,CAAC,OAAD,EAAU,uBAAV,EAAmC,MAAnC,CAAL;AACA,WAAO,SAAS,CAAC,IAAI,4BAAJ,EAAD,CAAT,CAA8C,SAA9C,EAAP;AACD,GAND;;AAOF,SAAA,iBAAA;AAAC,CApDD,EAAA;;;AAsDA;;AACA,IAAA,4BAAA;AAAA;AAAA,YAAA;AAAA,WAAA,4BAAA,GAAA,CAAuE;;AAAD,SAAA,4BAAA;AAAC,CAAvE,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\n\nimport { MemoryMutationQueue } from './memory_mutation_queue';\nimport { MemoryQueryCache } from './memory_query_cache';\nimport { MemoryRemoteDocumentCache } from './memory_remote_document_cache';\nimport { MutationQueue } from './mutation_queue';\nimport { Persistence, PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\nconst LOG_TAG = 'MemoryPersistence';\n\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nexport class MemoryPersistence implements Persistence {\n  /**\n   * Note that these are retained here to make it easier to write tests\n   * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n   * can create a new LocalStore wrapping this Persistence instance and this\n   * will make the in-memory persistence layer behave as if it were actually\n   * persisting values.\n   */\n  private mutationQueues: { [user: string]: MutationQueue } = {};\n  private remoteDocumentCache = new MemoryRemoteDocumentCache();\n  private queryCache = new MemoryQueryCache();\n\n  private started = false;\n\n  start(): Promise<void> {\n    assert(!this.started, 'MemoryPersistence double-started!');\n    this.started = true;\n    // No durable state to read on startup.\n    return Promise.resolve();\n  }\n\n  shutdown(): Promise<void> {\n    // No durable state to ensure is closed on shutdown.\n    assert(this.started, 'MemoryPersistence shutdown without start!');\n    this.started = false;\n    return Promise.resolve();\n  }\n\n  getMutationQueue(user: User): MutationQueue {\n    let queue = this.mutationQueues[user.toKey()];\n    if (!queue) {\n      queue = new MemoryMutationQueue();\n      this.mutationQueues[user.toKey()] = queue;\n    }\n    return queue;\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache;\n  }\n\n  getRemoteDocumentCache(): RemoteDocumentCache {\n    return this.remoteDocumentCache;\n  }\n\n  runTransaction<T>(\n    action: string,\n    operation: (transaction: PersistenceTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    debug(LOG_TAG, 'Starting transaction:', action);\n    return operation(new MemoryPersistenceTransaction()).toPromise();\n  }\n}\n\n/** Dummy class since memory persistence doesn't actually use transactions. */\nclass MemoryPersistenceTransaction implements PersistenceTransaction {}\n"]},"metadata":{},"sourceType":"module"}