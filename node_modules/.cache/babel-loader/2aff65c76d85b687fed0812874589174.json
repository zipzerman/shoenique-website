{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentSet } from '../model/document_set';\nimport { CurrentStatusUpdate, ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport { ChangeType, DocumentChangeSet, SyncState } from './view_snapshot';\n\nvar AddedLimboDocument =\n/** @class */\nfunction () {\n  function AddedLimboDocument(key) {\n    this.key = key;\n  }\n\n  return AddedLimboDocument;\n}();\n\nexport { AddedLimboDocument };\n\nvar RemovedLimboDocument =\n/** @class */\nfunction () {\n  function RemovedLimboDocument(key) {\n    this.key = key;\n  }\n\n  return RemovedLimboDocument;\n}();\n\nexport { RemovedLimboDocument };\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\n\nvar View =\n/** @class */\nfunction () {\n  function View(query,\n  /** Documents included in the remote target */\n  syncedDocuments) {\n    this.query = query;\n    this.syncedDocuments = syncedDocuments;\n    this.syncState = null;\n    /**\n     * A flag whether the view is current with the backend. A view is considered\n     * current after it has seen the current flag from the backend and did not\n     * lose consistency within the watch stream (e.g. because of an existence\n     * filter mismatch).\n     */\n\n    this.current = false;\n    /** Documents in the view but not in the remote target */\n\n    this.limboDocuments = documentKeySet();\n    /** Document Keys that have local changes */\n\n    this.mutatedKeys = documentKeySet();\n    this.documentSet = new DocumentSet(query.docComparator.bind(query));\n  }\n  /**\n   * Iterates over a set of doc changes, applies the query limit, and computes\n   * what the new results should be, what the changes were, and whether we may\n   * need to go back to the local cache for more results. Does not make any\n   * changes to the view.\n   * @param docChanges The doc changes to apply to this view.\n   * @param previousChanges If this is being called with a refill, then start\n   *        with this set of docs and changes instead of the current view.\n   * @return a new set of docs, changes, and refill flag.\n   */\n\n\n  View.prototype.computeDocChanges = function (docChanges, previousChanges) {\n    var _this = this;\n\n    var changeSet = previousChanges ? previousChanges.changeSet : new DocumentChangeSet();\n    var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;\n    var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;\n    var newDocumentSet = oldDocumentSet;\n    var needsRefill = false; // Track the last doc in a (full) limit. This is necessary, because some\n    // update (a delete, or an update moving a doc past the old limit) might\n    // mean there is some other document in the local cache that either should\n    // come (1) between the old last limit doc and the new last document, in the\n    // case of updates, or (2) after the new last document, in the case of\n    // deletes. So we keep this doc at the old limit to compare the updates to.\n    //\n    // Note that this should never get used in a refill (when previousChanges is\n    // set), because there will only be adds -- no deletes or updates.\n\n    var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;\n    docChanges.inorderTraversal(function (key, newMaybeDoc) {\n      var oldDoc = oldDocumentSet.get(key);\n      var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n\n      if (newDoc) {\n        assert(key.equals(newDoc.key), 'Mismatching keys found in document changes: ' + key + ' != ' + newDoc.key);\n        newDoc = _this.query.matches(newDoc) ? newDoc : null;\n      }\n\n      if (newDoc) {\n        newDocumentSet = newDocumentSet.add(newDoc);\n\n        if (newDoc.hasLocalMutations) {\n          newMutatedKeys = newMutatedKeys.add(key);\n        } else {\n          newMutatedKeys = newMutatedKeys.delete(key);\n        }\n      } else {\n        newDocumentSet = newDocumentSet.delete(key);\n        newMutatedKeys = newMutatedKeys.delete(key);\n      } // Calculate change\n\n\n      if (oldDoc && newDoc) {\n        var docsEqual = oldDoc.data.equals(newDoc.data);\n\n        if (!docsEqual || oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\n          // only report a change if document actually changed\n          if (docsEqual) {\n            changeSet.track({\n              type: ChangeType.Metadata,\n              doc: newDoc\n            });\n          } else {\n            changeSet.track({\n              type: ChangeType.Modified,\n              doc: newDoc\n            });\n          }\n\n          if (lastDocInLimit && _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\n            // This doc moved from inside the limit to after the limit.\n            // That means there may be some doc in the local cache that's\n            // actually less than this one.\n            needsRefill = true;\n          }\n        }\n      } else if (!oldDoc && newDoc) {\n        changeSet.track({\n          type: ChangeType.Added,\n          doc: newDoc\n        });\n      } else if (oldDoc && !newDoc) {\n        changeSet.track({\n          type: ChangeType.Removed,\n          doc: oldDoc\n        });\n\n        if (lastDocInLimit) {\n          // A doc was removed from a full limit query. We'll need to\n          // requery from the local cache to see if we know about some other\n          // doc that should be in the results.\n          needsRefill = true;\n        }\n      }\n    });\n\n    if (this.query.hasLimit()) {\n      // TODO(klimt): Make DocumentSet size be constant time.\n      while (newDocumentSet.size > this.query.limit) {\n        var oldDoc = newDocumentSet.last();\n        newDocumentSet = newDocumentSet.delete(oldDoc.key);\n        changeSet.track({\n          type: ChangeType.Removed,\n          doc: oldDoc\n        });\n      }\n    }\n\n    assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\n    return {\n      documentSet: newDocumentSet,\n      changeSet: changeSet,\n      needsRefill: needsRefill,\n      mutatedKeys: newMutatedKeys\n    };\n  };\n  /**\n   * Updates the view with the given ViewDocumentChanges and updates limbo docs\n   * and sync state from the given (optional) target change.\n   * @param docChanges The set of changes to make to the view's docs.\n   * @param targetChange A target change to apply for computing limbo docs and\n   *        sync state.\n   * @return A new ViewChange with the given docs, changes, and sync state.\n   */\n\n\n  View.prototype.applyChanges = function (docChanges, targetChange) {\n    var _this = this;\n\n    assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n    var oldDocs = this.documentSet;\n    this.documentSet = docChanges.documentSet;\n    this.mutatedKeys = docChanges.mutatedKeys; // Sort changes based on type and query comparator\n\n    var changes = docChanges.changeSet.getChanges();\n    changes.sort(function (c1, c2) {\n      return compareChangeType(c1.type, c2.type) || _this.query.docComparator(c1.doc, c2.doc);\n    });\n    var limboChanges = this.applyTargetChange(targetChange);\n    var synced = this.limboDocuments.size === 0 && this.current;\n    var newSyncState = synced ? SyncState.Synced : SyncState.Local;\n    var syncStateChanged = newSyncState !== this.syncState;\n    this.syncState = newSyncState;\n\n    if (changes.length === 0 && !syncStateChanged) {\n      // no changes\n      return {\n        limboChanges: limboChanges\n      };\n    } else {\n      return {\n        snapshot: {\n          query: this.query,\n          docs: docChanges.documentSet,\n          oldDocs: oldDocs,\n          docChanges: changes,\n          fromCache: newSyncState === SyncState.Local,\n          syncStateChanged: syncStateChanged,\n          hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n        },\n        limboChanges: limboChanges\n      };\n    }\n  };\n  /**\n   * Returns whether the doc for the given key should be in limbo.\n   */\n\n\n  View.prototype.shouldBeInLimbo = function (key) {\n    // If the remote end says it's part of this query, it's not in limbo.\n    if (this.syncedDocuments.has(key)) {\n      return false;\n    } // The local store doesn't think it's a result, so it shouldn't be in limbo.\n\n\n    if (!this.documentSet.has(key)) {\n      return false;\n    } // If there are local changes to the doc, they might explain why the server\n    // doesn't know that it's part of the query. So don't put it in limbo.\n    // TODO(klimt): Ideally, we would only consider changes that might actually\n    // affect this specific query.\n\n\n    if (this.documentSet.get(key).hasLocalMutations) {\n      return false;\n    } // Everything else is in limbo.\n\n\n    return true;\n  };\n  /**\n   * Updates syncedDocuments, current, and limbo docs based on the given change.\n   * Returns the list of changes to which docs are in limbo.\n   */\n\n\n  View.prototype.applyTargetChange = function (targetChange) {\n    var _this = this;\n\n    if (targetChange) {\n      var targetMapping = targetChange.mapping;\n\n      if (targetMapping instanceof ResetMapping) {\n        this.syncedDocuments = targetMapping.documents;\n      } else if (targetMapping instanceof UpdateMapping) {\n        this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\n      }\n\n      switch (targetChange.currentStatusUpdate) {\n        case CurrentStatusUpdate.MarkCurrent:\n          this.current = true;\n          break;\n\n        case CurrentStatusUpdate.MarkNotCurrent:\n          this.current = false;\n          break;\n\n        case CurrentStatusUpdate.None:\n          break;\n\n        default:\n          fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\n      }\n    } // Recompute the set of limbo docs.\n    // TODO(klimt): Do this incrementally so that it's not quadratic when\n    // updating many documents.\n\n\n    var oldLimboDocuments = this.limboDocuments;\n    this.limboDocuments = documentKeySet();\n\n    if (this.current) {\n      this.documentSet.forEach(function (doc) {\n        if (_this.shouldBeInLimbo(doc.key)) {\n          _this.limboDocuments = _this.limboDocuments.add(doc.key);\n        }\n      });\n    } // Diff the new limbo docs with the old limbo docs.\n\n\n    var changes = [];\n    oldLimboDocuments.forEach(function (key) {\n      if (!_this.limboDocuments.has(key)) {\n        changes.push(new RemovedLimboDocument(key));\n      }\n    });\n    this.limboDocuments.forEach(function (key) {\n      if (!oldLimboDocuments.has(key)) {\n        changes.push(new AddedLimboDocument(key));\n      }\n    });\n    return changes;\n  };\n\n  return View;\n}();\n\nexport { View };\n\nfunction compareChangeType(c1, c2) {\n  var order = function order(change) {\n    switch (change) {\n      case ChangeType.Added:\n        return 1;\n\n      case ChangeType.Modified:\n        return 2;\n\n      case ChangeType.Metadata:\n        // A metadata change is converted to a modified change at the public\n        // api layer.  Since we sort by document key and then change type,\n        // metadata and modified changes must be sorted equivalently.\n        return 2;\n\n      case ChangeType.Removed:\n        return 0;\n\n      default:\n        return fail('Unknown ChangeType: ' + change);\n    }\n  };\n\n  return order(c1) - order(c2);\n}","map":{"version":3,"sources":["../src/core/view.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport {\n  CurrentStatusUpdate,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\n\nimport { Query } from './query';\nimport {\n  ChangeType,\n  DocumentChangeSet,\n  SyncState,\n  ViewSnapshot\n} from './view_snapshot';\n\nexport type LimboDocumentChange = AddedLimboDocument | RemovedLimboDocument;\nexport class AddedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\nexport class RemovedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\n\n/** The result of applying a set of doc changes to a view. */\nexport interface ViewDocumentChanges {\n  /** The new set of docs that should be in the view. */\n  documentSet: DocumentSet;\n  /** The diff of this these docs with the previous set of docs. */\n  changeSet: DocumentChangeSet;\n  /**\n   * Whether the set of documents passed in was not sufficient to calculate the\n   * new state of the view and there needs to be another pass based on the\n   * local cache.\n   */\n  needsRefill: boolean;\n\n  mutatedKeys: DocumentKeySet;\n}\n\nexport interface ViewChange {\n  snapshot?: ViewSnapshot;\n  limboChanges: LimboDocumentChange[];\n}\n\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nexport class View {\n  private syncState: SyncState | null = null;\n  /**\n   * A flag whether the view is current with the backend. A view is considered\n   * current after it has seen the current flag from the backend and did not\n   * lose consistency within the watch stream (e.g. because of an existence\n   * filter mismatch).\n   */\n  private current = false;\n  private documentSet: DocumentSet;\n  /** Documents in the view but not in the remote target */\n  private limboDocuments = documentKeySet();\n  /** Document Keys that have local changes */\n  private mutatedKeys = documentKeySet();\n\n  constructor(\n    private query: Query,\n    /** Documents included in the remote target */\n    private syncedDocuments: DocumentKeySet\n  ) {\n    this.documentSet = new DocumentSet(query.docComparator.bind(query));\n  }\n\n  /**\n   * Iterates over a set of doc changes, applies the query limit, and computes\n   * what the new results should be, what the changes were, and whether we may\n   * need to go back to the local cache for more results. Does not make any\n   * changes to the view.\n   * @param docChanges The doc changes to apply to this view.\n   * @param previousChanges If this is being called with a refill, then start\n   *        with this set of docs and changes instead of the current view.\n   * @return a new set of docs, changes, and refill flag.\n   */\n  computeDocChanges(\n    docChanges: MaybeDocumentMap,\n    previousChanges?: ViewDocumentChanges\n  ): ViewDocumentChanges {\n    const changeSet = previousChanges\n      ? previousChanges.changeSet\n      : new DocumentChangeSet();\n    const oldDocumentSet = previousChanges\n      ? previousChanges.documentSet\n      : this.documentSet;\n    let newMutatedKeys = previousChanges\n      ? previousChanges.mutatedKeys\n      : this.mutatedKeys;\n    let newDocumentSet = oldDocumentSet;\n    let needsRefill = false;\n\n    // Track the last doc in a (full) limit. This is necessary, because some\n    // update (a delete, or an update moving a doc past the old limit) might\n    // mean there is some other document in the local cache that either should\n    // come (1) between the old last limit doc and the new last document, in the\n    // case of updates, or (2) after the new last document, in the case of\n    // deletes. So we keep this doc at the old limit to compare the updates to.\n    //\n    // Note that this should never get used in a refill (when previousChanges is\n    // set), because there will only be adds -- no deletes or updates.\n    const lastDocInLimit =\n      this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n        ? oldDocumentSet.last()\n        : null;\n\n    docChanges.inorderTraversal(\n      (key: DocumentKey, newMaybeDoc: MaybeDocument) => {\n        const oldDoc = oldDocumentSet.get(key);\n        let newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n        if (newDoc) {\n          assert(\n            key.equals(newDoc.key),\n            'Mismatching keys found in document changes: ' +\n              key +\n              ' != ' +\n              newDoc.key\n          );\n          newDoc = this.query.matches(newDoc) ? newDoc : null;\n        }\n        if (newDoc) {\n          newDocumentSet = newDocumentSet.add(newDoc);\n          if (newDoc.hasLocalMutations) {\n            newMutatedKeys = newMutatedKeys.add(key);\n          } else {\n            newMutatedKeys = newMutatedKeys.delete(key);\n          }\n        } else {\n          newDocumentSet = newDocumentSet.delete(key);\n          newMutatedKeys = newMutatedKeys.delete(key);\n        }\n\n        // Calculate change\n        if (oldDoc && newDoc) {\n          const docsEqual = oldDoc.data.equals(newDoc.data);\n          if (\n            !docsEqual ||\n            oldDoc.hasLocalMutations !== newDoc.hasLocalMutations\n          ) {\n            // only report a change if document actually changed\n            if (docsEqual) {\n              changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n            } else {\n              changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n            }\n\n            if (\n              lastDocInLimit &&\n              this.query.docComparator(newDoc, lastDocInLimit) > 0\n            ) {\n              // This doc moved from inside the limit to after the limit.\n              // That means there may be some doc in the local cache that's\n              // actually less than this one.\n              needsRefill = true;\n            }\n          }\n        } else if (!oldDoc && newDoc) {\n          changeSet.track({ type: ChangeType.Added, doc: newDoc });\n        } else if (oldDoc && !newDoc) {\n          changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n          if (lastDocInLimit) {\n            // A doc was removed from a full limit query. We'll need to\n            // requery from the local cache to see if we know about some other\n            // doc that should be in the results.\n            needsRefill = true;\n          }\n        }\n      }\n    );\n    if (this.query.hasLimit()) {\n      // TODO(klimt): Make DocumentSet size be constant time.\n      while (newDocumentSet.size > this.query.limit!) {\n        const oldDoc = newDocumentSet.last();\n        newDocumentSet = newDocumentSet.delete(oldDoc!.key);\n        changeSet.track({ type: ChangeType.Removed, doc: oldDoc! });\n      }\n    }\n    assert(\n      !needsRefill || !previousChanges,\n      'View was refilled using docs that themselves needed refilling.'\n    );\n    return {\n      documentSet: newDocumentSet,\n      changeSet,\n      needsRefill,\n      mutatedKeys: newMutatedKeys\n    };\n  }\n\n  /**\n   * Updates the view with the given ViewDocumentChanges and updates limbo docs\n   * and sync state from the given (optional) target change.\n   * @param docChanges The set of changes to make to the view's docs.\n   * @param targetChange A target change to apply for computing limbo docs and\n   *        sync state.\n   * @return A new ViewChange with the given docs, changes, and sync state.\n   */\n  applyChanges(\n    docChanges: ViewDocumentChanges,\n    targetChange?: TargetChange\n  ): ViewChange {\n    assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n    const oldDocs = this.documentSet;\n    this.documentSet = docChanges.documentSet;\n    this.mutatedKeys = docChanges.mutatedKeys;\n    // Sort changes based on type and query comparator\n    const changes = docChanges.changeSet.getChanges();\n    changes.sort((c1, c2) => {\n      return (\n        compareChangeType(c1.type, c2.type) ||\n        this.query.docComparator(c1.doc, c2.doc)\n      );\n    });\n\n    const limboChanges = this.applyTargetChange(targetChange);\n    const synced = this.limboDocuments.size === 0 && this.current;\n    const newSyncState = synced ? SyncState.Synced : SyncState.Local;\n    const syncStateChanged = newSyncState !== this.syncState;\n    this.syncState = newSyncState;\n\n    if (changes.length === 0 && !syncStateChanged) {\n      // no changes\n      return { limboChanges };\n    } else {\n      return {\n        snapshot: {\n          query: this.query,\n          docs: docChanges.documentSet,\n          oldDocs,\n          docChanges: changes,\n          fromCache: newSyncState === SyncState.Local,\n          syncStateChanged,\n          hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n        },\n        limboChanges\n      };\n    }\n  }\n\n  /**\n   * Returns whether the doc for the given key should be in limbo.\n   */\n  private shouldBeInLimbo(key: DocumentKey): boolean {\n    // If the remote end says it's part of this query, it's not in limbo.\n    if (this.syncedDocuments.has(key)) {\n      return false;\n    }\n    // The local store doesn't think it's a result, so it shouldn't be in limbo.\n    if (!this.documentSet.has(key)) {\n      return false;\n    }\n    // If there are local changes to the doc, they might explain why the server\n    // doesn't know that it's part of the query. So don't put it in limbo.\n    // TODO(klimt): Ideally, we would only consider changes that might actually\n    // affect this specific query.\n    if (this.documentSet.get(key)!.hasLocalMutations) {\n      return false;\n    }\n    // Everything else is in limbo.\n    return true;\n  }\n\n  /**\n   * Updates syncedDocuments, current, and limbo docs based on the given change.\n   * Returns the list of changes to which docs are in limbo.\n   */\n  private applyTargetChange(\n    targetChange?: TargetChange\n  ): LimboDocumentChange[] {\n    if (targetChange) {\n      const targetMapping = targetChange.mapping;\n      if (targetMapping instanceof ResetMapping) {\n        this.syncedDocuments = targetMapping.documents;\n      } else if (targetMapping instanceof UpdateMapping) {\n        this.syncedDocuments = targetMapping.applyToKeySet(\n          this.syncedDocuments\n        );\n      }\n\n      switch (targetChange.currentStatusUpdate) {\n        case CurrentStatusUpdate.MarkCurrent:\n          this.current = true;\n          break;\n        case CurrentStatusUpdate.MarkNotCurrent:\n          this.current = false;\n          break;\n        case CurrentStatusUpdate.None:\n          break;\n        default:\n          fail(\n            'Unknown current status update: ' + targetChange.currentStatusUpdate\n          );\n      }\n    }\n\n    // Recompute the set of limbo docs.\n    // TODO(klimt): Do this incrementally so that it's not quadratic when\n    // updating many documents.\n    const oldLimboDocuments = this.limboDocuments;\n    this.limboDocuments = documentKeySet();\n    if (this.current) {\n      this.documentSet.forEach(doc => {\n        if (this.shouldBeInLimbo(doc.key)) {\n          this.limboDocuments = this.limboDocuments.add(doc.key);\n        }\n      });\n    }\n\n    // Diff the new limbo docs with the old limbo docs.\n    const changes: LimboDocumentChange[] = [];\n    oldLimboDocuments.forEach(key => {\n      if (!this.limboDocuments.has(key)) {\n        changes.push(new RemovedLimboDocument(key));\n      }\n    });\n    this.limboDocuments.forEach(key => {\n      if (!oldLimboDocuments.has(key)) {\n        changes.push(new AddedLimboDocument(key));\n      }\n    });\n    return changes;\n  }\n}\n\nfunction compareChangeType(c1: ChangeType, c2: ChangeType): number {\n  const order = (change: ChangeType) => {\n    switch (change) {\n      case ChangeType.Added:\n        return 1;\n      case ChangeType.Modified:\n        return 2;\n      case ChangeType.Metadata:\n        // A metadata change is converted to a modified change at the public\n        // api layer.  Since we sort by document key and then change type,\n        // metadata and modified changes must be sorted equivalently.\n        return 2;\n      case ChangeType.Removed:\n        return 0;\n      default:\n        return fail('Unknown ChangeType: ' + change);\n    }\n  };\n\n  return order(c1) - order(c2);\n}\n"]},"metadata":{},"sourceType":"module"}