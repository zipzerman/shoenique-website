{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { OnlineState } from '../core/types';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatchResult } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { Code } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { isPermanentError } from './rpc_error';\nimport { WatchChangeAggregator, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nvar LOG_TAG = 'RemoteStore'; // TODO(b/35853402): Negotiate this with the stream.\n\nvar MAX_PENDING_WRITES = 10; // The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\n\nvar ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\n\nvar RemoteStore =\n/** @class */\nfunction () {\n  function RemoteStore(databaseInfo, asyncQueue,\n  /**\n   * The local store, used to fill the write pipeline with outbound\n   * mutations and resolve existence filter mismatches.\n   */\n  localStore,\n  /** The client-side proxy for interacting with the backend. */\n  datastore, onlineStateHandler) {\n    this.databaseInfo = databaseInfo;\n    this.asyncQueue = asyncQueue;\n    this.localStore = localStore;\n    this.datastore = datastore;\n    this.onlineStateHandler = onlineStateHandler;\n    this.pendingWrites = [];\n    this.lastBatchSeen = BATCHID_UNKNOWN;\n    /**\n     * A mapping of watched targets that the client cares about tracking and the\n     * user has explicitly called a 'listen' for this target.\n     *\n     * These targets may or may not have been sent to or acknowledged by the\n     * server. On re-establishing the listen stream, these targets should be sent\n     * to the server. The targets removed with unlistens are removed eagerly\n     * without waiting for confirmation from the listen stream.\n     */\n\n    this.listenTargets = {};\n    /**\n     * A mapping of targetId to pending acks needed.\n     *\n     * If a targetId is present in this map, then we're waiting for watch to\n     * acknowledge a removal or addition of the target. If a target is not in this\n     * mapping, and it's in the listenTargets map, then we consider the target to\n     * be active.\n     *\n     * We increment the count here every time we issue a request over the stream\n     * to watch or unwatch. We then decrement the count every time we get a target\n     * added or target removed message from the server. Once the count is equal to\n     * 0 we know that the client and server are in the same state (once this state\n     * is reached the targetId is removed from the map to free the memory).\n     */\n\n    this.pendingTargetResponses = {};\n    this.accumulatedWatchChanges = [];\n    this.watchStream = null;\n    this.writeStream = null;\n    /**\n     * The online state of the watch stream. The state is set to healthy if and\n     * only if there are messages received by the backend.\n     */\n\n    this.watchStreamOnlineState = OnlineState.Unknown;\n    /** A count of consecutive failures to open the stream. */\n\n    this.watchStreamFailures = 0;\n    /** Whether the client should fire offline warning. */\n\n    this.shouldWarnOffline = true;\n  }\n  /**\n   * Starts up the remote store, creating streams, restoring state from\n   * LocalStore, etc.\n   */\n\n\n  RemoteStore.prototype.start = function () {\n    return this.enableNetwork();\n  };\n\n  RemoteStore.prototype.setOnlineStateToHealthy = function () {\n    this.shouldWarnOffline = false;\n    this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n  };\n\n  RemoteStore.prototype.setOnlineStateToUnknown = function () {\n    // The state is set to unknown when a healthy stream is closed (e.g. due to\n    // a token timeout) or when we have no active listens and therefore there's\n    // no need to start the stream. Assuming there is (possibly in the future)\n    // an active listen, then we will eventually move to state Online or Failed,\n    // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n    // attempts before failing, so we reset the count here.\n    this.watchStreamFailures = 0;\n    this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n  };\n\n  RemoteStore.prototype.updateOnlineStateAfterFailure = function () {\n    // The first failure after we are successfully connected moves us to the\n    // 'Unknown' state. We then may make multiple attempts (based on\n    // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n    if (this.watchStreamOnlineState === OnlineState.Healthy) {\n      this.setOnlineStateToUnknown();\n    } else {\n      this.watchStreamFailures++;\n\n      if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n        if (this.shouldWarnOffline) {\n          log.debug(LOG_TAG, 'Could not reach Firestore backend.');\n          this.shouldWarnOffline = false;\n        }\n\n        this.updateAndBroadcastOnlineState(OnlineState.Failed);\n      }\n    }\n  };\n\n  RemoteStore.prototype.updateAndBroadcastOnlineState = function (onlineState) {\n    var didChange = this.watchStreamOnlineState !== onlineState;\n    this.watchStreamOnlineState = onlineState;\n\n    if (didChange) {\n      this.onlineStateHandler(onlineState);\n    }\n  };\n\n  RemoteStore.prototype.isNetworkEnabled = function () {\n    assert(this.watchStream == null == (this.writeStream == null), 'WatchStream and WriteStream should both be null or non-null');\n    return this.watchStream != null;\n  };\n  /** Re-enables the network. Only to be called as the counterpart to disableNetwork(). */\n\n\n  RemoteStore.prototype.enableNetwork = function () {\n    var _this = this;\n\n    assert(this.watchStream == null, 'enableNetwork() called with non-null watchStream.');\n    assert(this.writeStream == null, 'enableNetwork() called with non-null writeStream.'); // Create new streams (but note they're not started yet).\n\n    this.watchStream = this.datastore.newPersistentWatchStream();\n    this.writeStream = this.datastore.newPersistentWriteStream(); // Load any saved stream token from persistent storage\n\n    return this.localStore.getLastStreamToken().then(function (token) {\n      _this.writeStream.lastStreamToken = token;\n\n      if (_this.shouldStartWatchStream()) {\n        _this.startWatchStream();\n      }\n\n      _this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n\n      return _this.fillWritePipeline(); // This may start the writeStream.\n    });\n  };\n  /** Temporarily disables the network. The network can be re-enabled using enableNetwork(). */\n\n\n  RemoteStore.prototype.disableNetwork = function () {\n    this.updateAndBroadcastOnlineState(OnlineState.Failed); // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n    // event).\n\n    this.watchStream.stop();\n    this.writeStream.stop();\n    this.cleanUpWatchStreamState();\n    this.cleanUpWriteStreamState();\n    this.writeStream = null;\n    this.watchStream = null;\n    return Promise.resolve();\n  };\n\n  RemoteStore.prototype.shutdown = function () {\n    log.debug(LOG_TAG, 'RemoteStore shutting down.');\n    this.disableNetwork();\n    return Promise.resolve(undefined);\n  };\n  /** Starts new listen for the given query. Uses resume token if provided */\n\n\n  RemoteStore.prototype.listen = function (queryData) {\n    assert(!objUtils.contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!'); // Mark this as something the client is currently listening for.\n\n    this.listenTargets[queryData.targetId] = queryData;\n\n    if (this.shouldStartWatchStream()) {\n      // The listen will be sent in onWatchStreamOpen\n      this.startWatchStream();\n    } else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendWatchRequest(queryData);\n    }\n  };\n  /** Removes the listen from server */\n\n\n  RemoteStore.prototype.unlisten = function (targetId) {\n    assert(objUtils.contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');\n    var queryData = this.listenTargets[targetId];\n    delete this.listenTargets[targetId];\n\n    if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendUnwatchRequest(targetId);\n\n      if (objUtils.isEmpty(this.listenTargets)) {\n        this.watchStream.markIdle();\n      }\n    }\n  };\n  /**\n   * We need to increment the the expected number of pending responses we're due\n   * from watch so we wait for the ack to process any messages from this target.\n   */\n\n\n  RemoteStore.prototype.sendWatchRequest = function (queryData) {\n    this.recordPendingTargetRequest(queryData.targetId);\n    this.watchStream.watch(queryData);\n  };\n  /**\n   * We need to increment the expected number of pending responses we're due\n   * from watch so we wait for the removal on the server before we process any\n   * messages from this target.\n   */\n\n\n  RemoteStore.prototype.sendUnwatchRequest = function (targetId) {\n    this.recordPendingTargetRequest(targetId);\n    this.watchStream.unwatch(targetId);\n  };\n  /**\n   * Increment the mapping of how many acks are needed from watch before we can\n   * consider the server to be 'in-sync' with the client's active targets.\n   */\n\n\n  RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {\n    // For each request we get we need to record we need a response for it.\n    this.pendingTargetResponses[targetId] = (this.pendingTargetResponses[targetId] || 0) + 1;\n  };\n\n  RemoteStore.prototype.startWatchStream = function () {\n    assert(this.shouldStartWatchStream(), 'startWriteStream() called when shouldStartWatchStream() is false.');\n    this.watchStream.start({\n      onOpen: this.onWatchStreamOpen.bind(this),\n      onClose: this.onWatchStreamClose.bind(this),\n      onWatchChange: this.onWatchStreamChange.bind(this)\n    });\n  };\n  /**\n   * Returns whether the watch stream should be started because there are\n   * active targets trying to be listened too\n   */\n\n\n  RemoteStore.prototype.shouldStartWatchStream = function () {\n    return this.isNetworkEnabled() && !this.watchStream.isStarted() && !objUtils.isEmpty(this.listenTargets);\n  };\n\n  RemoteStore.prototype.cleanUpWatchStreamState = function () {\n    // If the connection is closed then we'll never get a snapshot version for\n    // the accumulated changes and so we'll never be able to complete the batch.\n    // When we start up again the server is going to resend these changes\n    // anyway, so just toss the accumulated state.\n    this.accumulatedWatchChanges = [];\n    this.pendingTargetResponses = {};\n  };\n\n  RemoteStore.prototype.onWatchStreamOpen = function () {\n    var _this = this; // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n    // targets are active\n\n\n    objUtils.forEachNumber(this.listenTargets, function (targetId, queryData) {\n      _this.sendWatchRequest(queryData);\n    });\n    return Promise.resolve();\n  };\n\n  RemoteStore.prototype.onWatchStreamClose = function (error) {\n    assert(this.isNetworkEnabled(), 'onWatchStreamClose() should only be called when the network is enabled');\n    this.cleanUpWatchStreamState(); // If there was an error, retry the connection.\n\n    if (this.shouldStartWatchStream()) {\n      this.updateOnlineStateAfterFailure();\n      this.startWatchStream();\n    } else {\n      // No need to restart watch stream because there are no active targets.\n      // The online state is set to unknown because there is no active attempt\n      // at establishing a connection\n      this.setOnlineStateToUnknown();\n    }\n\n    return Promise.resolve();\n  };\n\n  RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {\n    // Mark the connection as healthy because we got a message from the server\n    this.setOnlineStateToHealthy();\n\n    if (watchChange instanceof WatchTargetChange && watchChange.state === WatchTargetChangeState.Removed && watchChange.cause) {\n      // There was an error on a target, don't wait for a consistent snapshot\n      // to raise events\n      return this.handleTargetError(watchChange);\n    } // Accumulate watch changes but don't process them if there's no\n    // snapshotVersion or it's older than a previous snapshot we've processed\n    // (can happen after we resume a target using a resume token).\n\n\n    this.accumulatedWatchChanges.push(watchChange);\n\n    if (!snapshotVersion.equals(SnapshotVersion.MIN) && snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {\n      var changes = this.accumulatedWatchChanges;\n      this.accumulatedWatchChanges = [];\n      return this.handleWatchChangeBatch(snapshotVersion, changes);\n    } else {\n      return Promise.resolve();\n    }\n  };\n  /**\n   * Takes a batch of changes from the Datastore, repackages them as a\n   * RemoteEvent, and passes that on to the listener, which is typically the\n   * SyncEngine.\n   */\n\n\n  RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {\n    var _this = this;\n\n    var aggregator = new WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);\n    aggregator.addChanges(changes);\n    var remoteEvent = aggregator.createRemoteEvent(); // Get the new response counts from the aggregator\n\n    this.pendingTargetResponses = aggregator.pendingTargetResponses;\n    var promises = []; // Handle existence filters and existence filter mismatches.\n\n    objUtils.forEachNumber(aggregator.existenceFilters, function (targetId, filter) {\n      var queryData = _this.listenTargets[targetId];\n\n      if (!queryData) {\n        // A watched target might have been removed already.\n        return;\n      }\n\n      var query = queryData.query;\n\n      if (query.isDocumentQuery()) {\n        if (filter.count === 0) {\n          // The existence filter told us the document does not exist.\n          // We need to deduce that this document does not exist and apply\n          // a deleted document to our updates. Without applying a deleted\n          // document there might be another query that will raise this\n          // document as part of a snapshot until it is resolved,\n          // essentially exposing inconsistency between queries.\n          var key = new DocumentKey(query.path);\n          var deletedDoc = new NoDocument(key, snapshotVersion);\n          remoteEvent.addDocumentUpdate(deletedDoc);\n        } else {\n          assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);\n        }\n      } else {\n        // Not a document query.\n        var promise = _this.localStore.remoteDocumentKeys(targetId).then(function (trackedRemote) {\n          if (remoteEvent.targetChanges[targetId]) {\n            var mapping = remoteEvent.targetChanges[targetId].mapping;\n\n            if (mapping !== null) {\n              if (mapping instanceof UpdateMapping) {\n                trackedRemote = mapping.applyToKeySet(trackedRemote);\n              } else {\n                assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' + mapping);\n                trackedRemote = mapping.documents;\n              }\n            }\n          }\n\n          if (trackedRemote.size !== filter.count) {\n            // Existence filter mismatch, resetting mapping.\n            // Make sure the mismatch is exposed in the remote event.\n            remoteEvent.handleExistenceFilterMismatch(targetId); // Clear the resume token for the query, since we're in a\n            // known mismatch state.\n\n            var newQueryData = new QueryData(query, targetId, queryData.purpose);\n            _this.listenTargets[targetId] = newQueryData; // Cause a hard reset by unwatching and rewatching\n            // immediately, but deliberately don't send a resume token\n            // so that we get a full update.\n            // Make sure we expect that this acks are going to happen.\n\n            _this.sendUnwatchRequest(targetId); // Mark the query we send as being on behalf of an existence\n            // filter mismatch, but don't actually retain that in\n            // listenTargets. This ensures that we flag the first\n            // re-listen this way without impacting future listens of\n            // this target (that might happen e.g. on reconnect).\n\n\n            var requestQueryData = new QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);\n\n            _this.sendWatchRequest(requestQueryData);\n          }\n        });\n\n        promises.push(promise);\n      }\n    });\n    return Promise.all(promises).then(function () {\n      // Update in-memory resume tokens. LocalStore will update the\n      // persistent view of these when applying the completed RemoteEvent.\n      objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n        if (change.resumeToken.length > 0) {\n          var queryData = _this.listenTargets[targetId]; // A watched target might have been removed already.\n\n          if (queryData) {\n            _this.listenTargets[targetId] = queryData.update({\n              resumeToken: change.resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n          }\n        }\n      }); // Finally handle remote event\n\n      return _this.syncEngine.applyRemoteEvent(remoteEvent);\n    });\n  };\n  /** Handles an error on a target */\n\n\n  RemoteStore.prototype.handleTargetError = function (watchChange) {\n    var _this = this;\n\n    assert(!!watchChange.cause, 'Handling target error without a cause');\n    var error = watchChange.cause;\n    var promiseChain = Promise.resolve();\n    watchChange.targetIds.forEach(function (targetId) {\n      promiseChain = promiseChain.then(function () {\n        if (objUtils.contains(_this.listenTargets, targetId)) {\n          delete _this.listenTargets[targetId];\n          return _this.syncEngine.rejectListen(targetId, error);\n        } else {\n          // A watched target might have been removed already.\n          return Promise.resolve();\n        }\n      });\n    });\n    return promiseChain;\n  };\n\n  RemoteStore.prototype.cleanUpWriteStreamState = function () {\n    this.lastBatchSeen = BATCHID_UNKNOWN;\n    this.pendingWrites = [];\n  };\n  /**\n   * Notifies that there are new mutations to process in the queue. This is\n   * typically called by SyncEngine after it has sent mutations to LocalStore.\n   */\n\n\n  RemoteStore.prototype.fillWritePipeline = function () {\n    var _this = this;\n\n    if (!this.canWriteMutations()) {\n      return Promise.resolve();\n    } else {\n      return this.localStore.nextMutationBatch(this.lastBatchSeen).then(function (batch) {\n        if (batch === null) {\n          if (_this.pendingWrites.length == 0) {\n            _this.writeStream.markIdle();\n          }\n\n          return Promise.resolve();\n        } else {\n          _this.commit(batch);\n\n          return _this.fillWritePipeline();\n        }\n      });\n    }\n  };\n  /**\n   * Returns true if the backend can accept additional write requests.\n   *\n   * When sending mutations to the write stream (e.g. in fillWritePipeline),\n   * call this method first to check if more mutations can be sent.\n   *\n   * Currently the only thing that can prevent the backend from accepting\n   * write requests is if there are too many requests already outstanding. As\n   * writes complete the backend will be able to accept more.\n   */\n\n\n  RemoteStore.prototype.canWriteMutations = function () {\n    return this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES;\n  }; // For testing\n\n\n  RemoteStore.prototype.outstandingWrites = function () {\n    return this.pendingWrites.length;\n  };\n  /**\n   * Given mutations to commit, actually commits them to the Datastore. Note\n   * that this does *not* return a Promise specifically because the AsyncQueue\n   * should not block operations for this.\n   */\n\n\n  RemoteStore.prototype.commit = function (batch) {\n    assert(this.canWriteMutations(), \"commit called when batches can't be written\");\n    this.lastBatchSeen = batch.batchId;\n    this.pendingWrites.push(batch);\n\n    if (this.shouldStartWriteStream()) {\n      this.startWriteStream();\n    } else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  };\n\n  RemoteStore.prototype.shouldStartWriteStream = function () {\n    return this.isNetworkEnabled() && !this.writeStream.isStarted() && this.pendingWrites.length > 0;\n  };\n\n  RemoteStore.prototype.startWriteStream = function () {\n    assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');\n    this.writeStream.start({\n      onOpen: this.onWriteStreamOpen.bind(this),\n      onClose: this.onWriteStreamClose.bind(this),\n      onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n      onMutationResult: this.onMutationResult.bind(this)\n    });\n  };\n\n  RemoteStore.prototype.onWriteStreamOpen = function () {\n    this.writeStream.writeHandshake();\n    return Promise.resolve();\n  };\n\n  RemoteStore.prototype.onWriteHandshakeComplete = function () {\n    var _this = this; // Record the stream token.\n\n\n    return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {\n      // Drain any pending writes.\n      //\n      // Note that at this point pendingWrites contains mutations that\n      // have already been accepted by fillWritePipeline/commitBatch. If\n      // the pipeline is full, canWriteMutations will be false, despite\n      // the fact that we actually need to send mutations over.\n      //\n      // This also means that this method indirectly respects the limits\n      // imposed by canWriteMutations since writes can't be added to the\n      // pendingWrites array when canWriteMutations is false. If the\n      // limits imposed by canWriteMutations actually protect us from\n      // DOSing ourselves then those limits won't be exceeded here and\n      // we'll continue to make progress.\n      for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {\n        var batch = _a[_i];\n\n        _this.writeStream.writeMutations(batch.mutations);\n      }\n    });\n  };\n\n  RemoteStore.prototype.onMutationResult = function (commitVersion, results) {\n    var _this = this; // This is a response to a write containing mutations and should be\n    // correlated to the first pending write.\n\n\n    assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');\n    var batch = this.pendingWrites.shift();\n    var success = MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);\n    return this.syncEngine.applySuccessfulWrite(success).then(function () {\n      // It's possible that with the completion of this mutation another\n      // slot has freed up.\n      return _this.fillWritePipeline();\n    });\n  };\n\n  RemoteStore.prototype.onWriteStreamClose = function (error) {\n    var _this = this;\n\n    assert(this.isNetworkEnabled(), 'onWriteStreamClose() should only be called when the network is enabled'); // If the write stream closed due to an error, invoke the error callbacks if\n    // there are pending writes.\n\n    if (error && this.pendingWrites.length > 0) {\n      assert(!!error, 'We have pending writes, but the write stream closed without an error'); // A promise that is resolved after we processed the error\n\n      var errorHandling = void 0;\n\n      if (this.writeStream.handshakeComplete) {\n        // This error affects the actual write.\n        errorHandling = this.handleWriteError(error);\n      } else {\n        // If there was an error before the handshake has finished, it's\n        // possible that the server is unable to process the stream token\n        // we're sending. (Perhaps it's too old?)\n        errorHandling = this.handleHandshakeError(error);\n      }\n\n      return errorHandling.then(function () {\n        // The write stream might have been started by refilling the write\n        // pipeline for failed writes\n        if (_this.shouldStartWriteStream()) {\n          _this.startWriteStream();\n        }\n      });\n    } else {\n      // No pending writes, nothing to do\n      return Promise.resolve();\n    }\n  };\n\n  RemoteStore.prototype.handleHandshakeError = function (error) {\n    // Reset the token if it's a permanent error or the error code is\n    // ABORTED, signaling the write stream is no longer valid.\n    if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n      log.debug(LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);\n      this.writeStream.lastStreamToken = emptyByteString();\n      return this.localStore.setLastStreamToken(emptyByteString());\n    } else {\n      // Some other error, don't reset stream token. Our stream logic will\n      // just retry with exponential backoff.\n      return Promise.resolve();\n    }\n  };\n\n  RemoteStore.prototype.handleWriteError = function (error) {\n    var _this = this;\n\n    if (isPermanentError(error.code)) {\n      // This was a permanent error, the request itself was the problem\n      // so it's not going to succeed if we resend it.\n      var batch = this.pendingWrites.shift(); // In this case it's also unlikely that the server itself is melting\n      // down -- this was just a bad request so inhibit backoff on the next\n      // restart.\n\n      this.writeStream.inhibitBackoff();\n      return this.syncEngine.rejectFailedWrite(batch.batchId, error).then(function () {\n        // It's possible that with the completion of this mutation\n        // another slot has freed up.\n        return _this.fillWritePipeline();\n      });\n    } else {\n      // Transient error, just let the retry logic kick in.\n      return Promise.resolve();\n    }\n  };\n\n  RemoteStore.prototype.createTransaction = function () {\n    return new Transaction(this.datastore);\n  };\n\n  RemoteStore.prototype.handleUserChange = function (user) {\n    log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid); // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n    // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n    // (since mutations are per-user).\n\n    this.disableNetwork();\n    return this.enableNetwork();\n  };\n\n  return RemoteStore;\n}();\n\nexport { RemoteStore };","map":{"version":3,"sources":["../src/remote/remote_store.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { DatabaseInfo } from '../core/database_info';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { BatchId, OnlineState, TargetId } from '../core/types';\nimport { LocalStore } from '../local/local_store';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationResult } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\n\nimport { Datastore } from './datastore';\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream\n} from './persistent_stream';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { RemoteSyncer } from './remote_syncer';\nimport { isPermanentError } from './rpc_error';\nimport {\n  WatchChange,\n  WatchChangeAggregator,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\n\nconst LOG_TAG = 'RemoteStore';\n\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\n\n// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\nconst ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nexport class RemoteStore {\n  private pendingWrites: MutationBatch[] = [];\n  private lastBatchSeen: BatchId = BATCHID_UNKNOWN;\n\n  /**\n   * A mapping of watched targets that the client cares about tracking and the\n   * user has explicitly called a 'listen' for this target.\n   *\n   * These targets may or may not have been sent to or acknowledged by the\n   * server. On re-establishing the listen stream, these targets should be sent\n   * to the server. The targets removed with unlistens are removed eagerly\n   * without waiting for confirmation from the listen stream.\n   */\n  private listenTargets: { [targetId: number]: QueryData } = {};\n\n  /**\n   * A mapping of targetId to pending acks needed.\n   *\n   * If a targetId is present in this map, then we're waiting for watch to\n   * acknowledge a removal or addition of the target. If a target is not in this\n   * mapping, and it's in the listenTargets map, then we consider the target to\n   * be active.\n   *\n   * We increment the count here every time we issue a request over the stream\n   * to watch or unwatch. We then decrement the count every time we get a target\n   * added or target removed message from the server. Once the count is equal to\n   * 0 we know that the client and server are in the same state (once this state\n   * is reached the targetId is removed from the map to free the memory).\n   */\n  private pendingTargetResponses: { [targetId: number]: number } = {};\n\n  private accumulatedWatchChanges: WatchChange[] = [];\n\n  private watchStream: PersistentListenStream = null;\n  private writeStream: PersistentWriteStream = null;\n\n  /**\n   * The online state of the watch stream. The state is set to healthy if and\n   * only if there are messages received by the backend.\n   */\n  private watchStreamOnlineState = OnlineState.Unknown;\n\n  /** A count of consecutive failures to open the stream. */\n  private watchStreamFailures = 0;\n\n  /** Whether the client should fire offline warning. */\n  private shouldWarnOffline = true;\n\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    private asyncQueue: AsyncQueue,\n    /**\n     * The local store, used to fill the write pipeline with outbound\n     * mutations and resolve existence filter mismatches.\n     */\n    private localStore: LocalStore,\n    /** The client-side proxy for interacting with the backend. */\n    private datastore: Datastore,\n    private onlineStateHandler: (onlineState: OnlineState) => void\n  ) {}\n\n  /** SyncEngine to notify of watch and write events. */\n  public syncEngine: RemoteSyncer;\n\n  /**\n   * Starts up the remote store, creating streams, restoring state from\n   * LocalStore, etc.\n   */\n  start(): Promise<void> {\n    return this.enableNetwork();\n  }\n\n  private setOnlineStateToHealthy(): void {\n    this.shouldWarnOffline = false;\n    this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n  }\n\n  private setOnlineStateToUnknown(): void {\n    // The state is set to unknown when a healthy stream is closed (e.g. due to\n    // a token timeout) or when we have no active listens and therefore there's\n    // no need to start the stream. Assuming there is (possibly in the future)\n    // an active listen, then we will eventually move to state Online or Failed,\n    // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n    // attempts before failing, so we reset the count here.\n    this.watchStreamFailures = 0;\n    this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n  }\n\n  private updateOnlineStateAfterFailure(): void {\n    // The first failure after we are successfully connected moves us to the\n    // 'Unknown' state. We then may make multiple attempts (based on\n    // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n    if (this.watchStreamOnlineState === OnlineState.Healthy) {\n      this.setOnlineStateToUnknown();\n    } else {\n      this.watchStreamFailures++;\n      if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n        if (this.shouldWarnOffline) {\n          log.debug(LOG_TAG, 'Could not reach Firestore backend.');\n          this.shouldWarnOffline = false;\n        }\n        this.updateAndBroadcastOnlineState(OnlineState.Failed);\n      }\n    }\n  }\n\n  private updateAndBroadcastOnlineState(onlineState: OnlineState): void {\n    const didChange = this.watchStreamOnlineState !== onlineState;\n    this.watchStreamOnlineState = onlineState;\n    if (didChange) {\n      this.onlineStateHandler(onlineState);\n    }\n  }\n\n  private isNetworkEnabled(): boolean {\n    assert(\n      (this.watchStream == null) == (this.writeStream == null),\n      'WatchStream and WriteStream should both be null or non-null'\n    );\n    return this.watchStream != null;\n  }\n\n  /** Re-enables the network. Only to be called as the counterpart to disableNetwork(). */\n  enableNetwork(): Promise<void> {\n    assert(\n      this.watchStream == null,\n      'enableNetwork() called with non-null watchStream.'\n    );\n    assert(\n      this.writeStream == null,\n      'enableNetwork() called with non-null writeStream.'\n    );\n\n    // Create new streams (but note they're not started yet).\n    this.watchStream = this.datastore.newPersistentWatchStream();\n    this.writeStream = this.datastore.newPersistentWriteStream();\n\n    // Load any saved stream token from persistent storage\n    return this.localStore.getLastStreamToken().then(token => {\n      this.writeStream.lastStreamToken = token;\n\n      if (this.shouldStartWatchStream()) {\n        this.startWatchStream();\n      }\n\n      this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n\n      return this.fillWritePipeline(); // This may start the writeStream.\n    });\n  }\n\n  /** Temporarily disables the network. The network can be re-enabled using enableNetwork(). */\n  disableNetwork(): Promise<void> {\n    this.updateAndBroadcastOnlineState(OnlineState.Failed);\n\n    // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n    // event).\n    this.watchStream.stop();\n    this.writeStream.stop();\n\n    this.cleanUpWatchStreamState();\n    this.cleanUpWriteStreamState();\n\n    this.writeStream = null;\n    this.watchStream = null;\n\n    return Promise.resolve();\n  }\n\n  shutdown(): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore shutting down.');\n    this.disableNetwork();\n    return Promise.resolve(undefined);\n  }\n\n  /** Starts new listen for the given query. Uses resume token if provided */\n  listen(queryData: QueryData): void {\n    assert(\n      !objUtils.contains(this.listenTargets, queryData.targetId),\n      'listen called with duplicate targetId!'\n    );\n    // Mark this as something the client is currently listening for.\n    this.listenTargets[queryData.targetId] = queryData;\n\n    if (this.shouldStartWatchStream()) {\n      // The listen will be sent in onWatchStreamOpen\n      this.startWatchStream();\n    } else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendWatchRequest(queryData);\n    }\n  }\n\n  /** Removes the listen from server */\n  unlisten(targetId: TargetId): void {\n    assert(\n      objUtils.contains(this.listenTargets, targetId),\n      'unlisten called without assigned target ID!'\n    );\n    const queryData = this.listenTargets[targetId];\n    delete this.listenTargets[targetId];\n    if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendUnwatchRequest(targetId);\n      if (objUtils.isEmpty(this.listenTargets)) {\n        this.watchStream.markIdle();\n      }\n    }\n  }\n\n  /**\n   * We need to increment the the expected number of pending responses we're due\n   * from watch so we wait for the ack to process any messages from this target.\n   */\n  private sendWatchRequest(queryData: QueryData): void {\n    this.recordPendingTargetRequest(queryData.targetId);\n    this.watchStream.watch(queryData);\n  }\n\n  /**\n   * We need to increment the expected number of pending responses we're due\n   * from watch so we wait for the removal on the server before we process any\n   * messages from this target.\n   */\n  private sendUnwatchRequest(targetId: TargetId): void {\n    this.recordPendingTargetRequest(targetId);\n    this.watchStream.unwatch(targetId);\n  }\n\n  /**\n   * Increment the mapping of how many acks are needed from watch before we can\n   * consider the server to be 'in-sync' with the client's active targets.\n   */\n  private recordPendingTargetRequest(targetId: TargetId): void {\n    // For each request we get we need to record we need a response for it.\n    this.pendingTargetResponses[targetId] =\n      (this.pendingTargetResponses[targetId] || 0) + 1;\n  }\n\n  private startWatchStream(): void {\n    assert(\n      this.shouldStartWatchStream(),\n      'startWriteStream() called when shouldStartWatchStream() is false.'\n    );\n    this.watchStream.start({\n      onOpen: this.onWatchStreamOpen.bind(this),\n      onClose: this.onWatchStreamClose.bind(this),\n      onWatchChange: this.onWatchStreamChange.bind(this)\n    });\n  }\n\n  /**\n   * Returns whether the watch stream should be started because there are\n   * active targets trying to be listened too\n   */\n  private shouldStartWatchStream(): boolean {\n    return (\n      this.isNetworkEnabled() &&\n      !this.watchStream.isStarted() &&\n      !objUtils.isEmpty(this.listenTargets)\n    );\n  }\n\n  private cleanUpWatchStreamState(): void {\n    // If the connection is closed then we'll never get a snapshot version for\n    // the accumulated changes and so we'll never be able to complete the batch.\n    // When we start up again the server is going to resend these changes\n    // anyway, so just toss the accumulated state.\n    this.accumulatedWatchChanges = [];\n    this.pendingTargetResponses = {};\n  }\n\n  private onWatchStreamOpen(): Promise<void> {\n    // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n    // targets are active\n    objUtils.forEachNumber(this.listenTargets, (targetId, queryData) => {\n      this.sendWatchRequest(queryData);\n    });\n    return Promise.resolve();\n  }\n\n  private onWatchStreamClose(error: FirestoreError | null): Promise<void> {\n    assert(\n      this.isNetworkEnabled(),\n      'onWatchStreamClose() should only be called when the network is enabled'\n    );\n\n    this.cleanUpWatchStreamState();\n\n    // If there was an error, retry the connection.\n    if (this.shouldStartWatchStream()) {\n      this.updateOnlineStateAfterFailure();\n      this.startWatchStream();\n    } else {\n      // No need to restart watch stream because there are no active targets.\n      // The online state is set to unknown because there is no active attempt\n      // at establishing a connection\n      this.setOnlineStateToUnknown();\n    }\n    return Promise.resolve();\n  }\n\n  private onWatchStreamChange(\n    watchChange: WatchChange,\n    snapshotVersion: SnapshotVersion\n  ): Promise<void> {\n    // Mark the connection as healthy because we got a message from the server\n    this.setOnlineStateToHealthy();\n\n    if (\n      watchChange instanceof WatchTargetChange &&\n      watchChange.state === WatchTargetChangeState.Removed &&\n      watchChange.cause\n    ) {\n      // There was an error on a target, don't wait for a consistent snapshot\n      // to raise events\n      return this.handleTargetError(watchChange);\n    }\n    // Accumulate watch changes but don't process them if there's no\n    // snapshotVersion or it's older than a previous snapshot we've processed\n    // (can happen after we resume a target using a resume token).\n    this.accumulatedWatchChanges.push(watchChange);\n    if (\n      !snapshotVersion.equals(SnapshotVersion.MIN) &&\n      snapshotVersion.compareTo(\n        this.localStore.getLastRemoteSnapshotVersion()\n      ) >= 0\n    ) {\n      const changes = this.accumulatedWatchChanges;\n      this.accumulatedWatchChanges = [];\n      return this.handleWatchChangeBatch(snapshotVersion, changes);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Takes a batch of changes from the Datastore, repackages them as a\n   * RemoteEvent, and passes that on to the listener, which is typically the\n   * SyncEngine.\n   */\n  private handleWatchChangeBatch(\n    snapshotVersion: SnapshotVersion,\n    changes: WatchChange[]\n  ): Promise<void> {\n    const aggregator = new WatchChangeAggregator(\n      snapshotVersion,\n      this.listenTargets,\n      this.pendingTargetResponses\n    );\n    aggregator.addChanges(changes);\n    const remoteEvent = aggregator.createRemoteEvent();\n    // Get the new response counts from the aggregator\n    this.pendingTargetResponses = aggregator.pendingTargetResponses;\n\n    const promises: Array<Promise<void>> = [];\n    // Handle existence filters and existence filter mismatches.\n    objUtils.forEachNumber(\n      aggregator.existenceFilters,\n      (targetId: TargetId, filter: ExistenceFilter) => {\n        const queryData = this.listenTargets[targetId];\n        if (!queryData) {\n          // A watched target might have been removed already.\n          return;\n        }\n        const query = queryData.query;\n        if (query.isDocumentQuery()) {\n          if (filter.count === 0) {\n            // The existence filter told us the document does not exist.\n            // We need to deduce that this document does not exist and apply\n            // a deleted document to our updates. Without applying a deleted\n            // document there might be another query that will raise this\n            // document as part of a snapshot until it is resolved,\n            // essentially exposing inconsistency between queries.\n            const key = new DocumentKey(query.path);\n            const deletedDoc = new NoDocument(key, snapshotVersion);\n            remoteEvent.addDocumentUpdate(deletedDoc);\n          } else {\n            assert(\n              filter.count === 1,\n              'Single document existence filter with count: ' + filter.count\n            );\n          }\n        } else {\n          // Not a document query.\n          const promise = this.localStore\n            .remoteDocumentKeys(targetId)\n            .then(trackedRemote => {\n              if (remoteEvent.targetChanges[targetId]) {\n                const mapping = remoteEvent.targetChanges[targetId].mapping;\n                if (mapping !== null) {\n                  if (mapping instanceof UpdateMapping) {\n                    trackedRemote = mapping.applyToKeySet(trackedRemote);\n                  } else {\n                    assert(\n                      mapping instanceof ResetMapping,\n                      'Expected either reset or update mapping but got something else: ' +\n                        mapping\n                    );\n                    trackedRemote = mapping.documents;\n                  }\n                }\n              }\n\n              if (trackedRemote.size !== filter.count) {\n                // Existence filter mismatch, resetting mapping.\n\n                // Make sure the mismatch is exposed in the remote event.\n                remoteEvent.handleExistenceFilterMismatch(targetId);\n\n                // Clear the resume token for the query, since we're in a\n                // known mismatch state.\n                const newQueryData = new QueryData(\n                  query,\n                  targetId,\n                  queryData.purpose\n                );\n                this.listenTargets[targetId] = newQueryData;\n\n                // Cause a hard reset by unwatching and rewatching\n                // immediately, but deliberately don't send a resume token\n                // so that we get a full update.\n                // Make sure we expect that this acks are going to happen.\n                this.sendUnwatchRequest(targetId);\n\n                // Mark the query we send as being on behalf of an existence\n                // filter mismatch, but don't actually retain that in\n                // listenTargets. This ensures that we flag the first\n                // re-listen this way without impacting future listens of\n                // this target (that might happen e.g. on reconnect).\n                const requestQueryData = new QueryData(\n                  query,\n                  targetId,\n                  QueryPurpose.ExistenceFilterMismatch\n                );\n                this.sendWatchRequest(requestQueryData);\n              }\n            });\n          promises.push(promise);\n        }\n      }\n    );\n\n    return Promise.all(promises).then(() => {\n      // Update in-memory resume tokens. LocalStore will update the\n      // persistent view of these when applying the completed RemoteEvent.\n      objUtils.forEachNumber(remoteEvent.targetChanges, (targetId, change) => {\n        if (change.resumeToken.length > 0) {\n          const queryData = this.listenTargets[targetId];\n          // A watched target might have been removed already.\n          if (queryData) {\n            this.listenTargets[targetId] = queryData.update({\n              resumeToken: change.resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n          }\n        }\n      });\n\n      // Finally handle remote event\n      return this.syncEngine.applyRemoteEvent(remoteEvent);\n    });\n  }\n\n  /** Handles an error on a target */\n  private handleTargetError(watchChange: WatchTargetChange): Promise<void> {\n    assert(!!watchChange.cause, 'Handling target error without a cause');\n    const error = watchChange.cause!;\n    let promiseChain = Promise.resolve();\n    watchChange.targetIds.forEach(targetId => {\n      promiseChain = promiseChain.then(() => {\n        if (objUtils.contains(this.listenTargets, targetId)) {\n          delete this.listenTargets[targetId];\n          return this.syncEngine.rejectListen(targetId, error);\n        } else {\n          // A watched target might have been removed already.\n          return Promise.resolve();\n        }\n      });\n    });\n    return promiseChain;\n  }\n\n  cleanUpWriteStreamState() {\n    this.lastBatchSeen = BATCHID_UNKNOWN;\n    this.pendingWrites = [];\n  }\n\n  /**\n   * Notifies that there are new mutations to process in the queue. This is\n   * typically called by SyncEngine after it has sent mutations to LocalStore.\n   */\n  fillWritePipeline(): Promise<void> {\n    if (!this.canWriteMutations()) {\n      return Promise.resolve();\n    } else {\n      return this.localStore\n        .nextMutationBatch(this.lastBatchSeen)\n        .then(batch => {\n          if (batch === null) {\n            if (this.pendingWrites.length == 0) {\n              this.writeStream.markIdle();\n            }\n            return Promise.resolve();\n          } else {\n            this.commit(batch);\n            return this.fillWritePipeline();\n          }\n        });\n    }\n  }\n\n  /**\n   * Returns true if the backend can accept additional write requests.\n   *\n   * When sending mutations to the write stream (e.g. in fillWritePipeline),\n   * call this method first to check if more mutations can be sent.\n   *\n   * Currently the only thing that can prevent the backend from accepting\n   * write requests is if there are too many requests already outstanding. As\n   * writes complete the backend will be able to accept more.\n   */\n  canWriteMutations(): boolean {\n    return (\n      this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES\n    );\n  }\n\n  // For testing\n  outstandingWrites(): number {\n    return this.pendingWrites.length;\n  }\n\n  /**\n   * Given mutations to commit, actually commits them to the Datastore. Note\n   * that this does *not* return a Promise specifically because the AsyncQueue\n   * should not block operations for this.\n   */\n  private commit(batch: MutationBatch): void {\n    assert(\n      this.canWriteMutations(),\n      \"commit called when batches can't be written\"\n    );\n    this.lastBatchSeen = batch.batchId;\n\n    this.pendingWrites.push(batch);\n\n    if (this.shouldStartWriteStream()) {\n      this.startWriteStream();\n    } else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  }\n\n  private shouldStartWriteStream(): boolean {\n    return (\n      this.isNetworkEnabled() &&\n      !this.writeStream.isStarted() &&\n      this.pendingWrites.length > 0\n    );\n  }\n\n  private startWriteStream(): void {\n    assert(\n      this.shouldStartWriteStream(),\n      'startWriteStream() called when shouldStartWriteStream() is false.'\n    );\n    this.writeStream.start({\n      onOpen: this.onWriteStreamOpen.bind(this),\n      onClose: this.onWriteStreamClose.bind(this),\n      onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n      onMutationResult: this.onMutationResult.bind(this)\n    });\n  }\n\n  private onWriteStreamOpen(): Promise<void> {\n    this.writeStream.writeHandshake();\n\n    return Promise.resolve();\n  }\n\n  private onWriteHandshakeComplete(): Promise<void> {\n    // Record the stream token.\n    return this.localStore\n      .setLastStreamToken(this.writeStream.lastStreamToken)\n      .then(() => {\n        // Drain any pending writes.\n        //\n        // Note that at this point pendingWrites contains mutations that\n        // have already been accepted by fillWritePipeline/commitBatch. If\n        // the pipeline is full, canWriteMutations will be false, despite\n        // the fact that we actually need to send mutations over.\n        //\n        // This also means that this method indirectly respects the limits\n        // imposed by canWriteMutations since writes can't be added to the\n        // pendingWrites array when canWriteMutations is false. If the\n        // limits imposed by canWriteMutations actually protect us from\n        // DOSing ourselves then those limits won't be exceeded here and\n        // we'll continue to make progress.\n        for (const batch of this.pendingWrites) {\n          this.writeStream.writeMutations(batch.mutations);\n        }\n      });\n  }\n\n  private onMutationResult(\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ): Promise<void> {\n    // This is a response to a write containing mutations and should be\n    // correlated to the first pending write.\n    assert(\n      this.pendingWrites.length > 0,\n      'Got result for empty pending writes'\n    );\n    const batch = this.pendingWrites.shift()!;\n    const success = MutationBatchResult.from(\n      batch,\n      commitVersion,\n      results,\n      this.writeStream.lastStreamToken\n    );\n    return this.syncEngine.applySuccessfulWrite(success).then(() => {\n      // It's possible that with the completion of this mutation another\n      // slot has freed up.\n      return this.fillWritePipeline();\n    });\n  }\n\n  private onWriteStreamClose(error?: FirestoreError): Promise<void> {\n    assert(\n      this.isNetworkEnabled(),\n      'onWriteStreamClose() should only be called when the network is enabled'\n    );\n\n    // If the write stream closed due to an error, invoke the error callbacks if\n    // there are pending writes.\n    if (error && this.pendingWrites.length > 0) {\n      assert(\n        !!error,\n        'We have pending writes, but the write stream closed without an error'\n      );\n      // A promise that is resolved after we processed the error\n      let errorHandling: Promise<void>;\n      if (this.writeStream.handshakeComplete) {\n        // This error affects the actual write.\n        errorHandling = this.handleWriteError(error!);\n      } else {\n        // If there was an error before the handshake has finished, it's\n        // possible that the server is unable to process the stream token\n        // we're sending. (Perhaps it's too old?)\n        errorHandling = this.handleHandshakeError(error!);\n      }\n\n      return errorHandling.then(() => {\n        // The write stream might have been started by refilling the write\n        // pipeline for failed writes\n        if (this.shouldStartWriteStream()) {\n          this.startWriteStream();\n        }\n      });\n    } else {\n      // No pending writes, nothing to do\n      return Promise.resolve();\n    }\n  }\n\n  private handleHandshakeError(error: FirestoreError): Promise<void> {\n    // Reset the token if it's a permanent error or the error code is\n    // ABORTED, signaling the write stream is no longer valid.\n    if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n      log.debug(\n        LOG_TAG,\n        'RemoteStore error before completed handshake; resetting stream token: ',\n        this.writeStream.lastStreamToken\n      );\n      this.writeStream.lastStreamToken = emptyByteString();\n\n      return this.localStore.setLastStreamToken(emptyByteString());\n    } else {\n      // Some other error, don't reset stream token. Our stream logic will\n      // just retry with exponential backoff.\n      return Promise.resolve();\n    }\n  }\n\n  private handleWriteError(error: FirestoreError): Promise<void> {\n    if (isPermanentError(error.code)) {\n      // This was a permanent error, the request itself was the problem\n      // so it's not going to succeed if we resend it.\n      const batch = this.pendingWrites.shift()!;\n\n      // In this case it's also unlikely that the server itself is melting\n      // down -- this was just a bad request so inhibit backoff on the next\n      // restart.\n      this.writeStream.inhibitBackoff();\n\n      return this.syncEngine\n        .rejectFailedWrite(batch.batchId, error)\n        .then(() => {\n          // It's possible that with the completion of this mutation\n          // another slot has freed up.\n          return this.fillWritePipeline();\n        });\n    } else {\n      // Transient error, just let the retry logic kick in.\n      return Promise.resolve();\n    }\n  }\n\n  createTransaction(): Transaction {\n    return new Transaction(this.datastore);\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n\n    // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n    // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n    // (since mutations are per-user).\n    this.disableNetwork();\n    return this.enableNetwork();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}