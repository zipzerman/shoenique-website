{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport * as objUtils from '../util/obj';\nimport { CurrentStatusUpdate, RemoteEvent, ResetMapping, UpdateMapping } from './remote_event';\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\n\nvar DocumentWatchChange =\n/** @class */\nfunction () {\n  function DocumentWatchChange(\n  /** The new document applies to all of these targets. */\n  updatedTargetIds,\n  /** The new document is removed from all of these targets. */\n  removedTargetIds,\n  /** The key of the document for this change. */\n  key,\n  /**\n   * The new document or NoDocument if it was deleted. Is null if the\n   * document went out of view without the server sending a new document.\n   */\n  newDoc) {\n    this.updatedTargetIds = updatedTargetIds;\n    this.removedTargetIds = removedTargetIds;\n    this.key = key;\n    this.newDoc = newDoc;\n  }\n\n  return DocumentWatchChange;\n}();\n\nexport { DocumentWatchChange };\n\nvar ExistenceFilterChange =\n/** @class */\nfunction () {\n  function ExistenceFilterChange(targetId, existenceFilter) {\n    this.targetId = targetId;\n    this.existenceFilter = existenceFilter;\n  }\n\n  return ExistenceFilterChange;\n}();\n\nexport { ExistenceFilterChange };\nexport var WatchTargetChangeState;\n\n(function (WatchTargetChangeState) {\n  WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState || (WatchTargetChangeState = {}));\n\nvar WatchTargetChange =\n/** @class */\nfunction () {\n  function WatchTargetChange(\n  /** What kind of change occurred to the watch target. */\n  state,\n  /** The target IDs that were added/removed/set. */\n  targetIds,\n  /**\n   * An opaque, server-assigned token that allows watching a query to be\n   * resumed after disconnecting without retransmitting all the data that\n   * matches the query. The resume token essentially identifies a point in\n   * time from which the server should resume sending results.\n   */\n  resumeToken,\n  /** An RPC error indicating why the watch failed. */\n  cause) {\n    if (resumeToken === void 0) {\n      resumeToken = emptyByteString();\n    }\n\n    if (cause === void 0) {\n      cause = null;\n    }\n\n    this.state = state;\n    this.targetIds = targetIds;\n    this.resumeToken = resumeToken;\n    this.cause = cause;\n  }\n\n  return WatchTargetChange;\n}();\n\nexport { WatchTargetChange };\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\n\nvar WatchChangeAggregator =\n/** @class */\nfunction () {\n  function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n    this.snapshotVersion = snapshotVersion;\n    this.listenTargets = listenTargets;\n    /** The existence filter - if any - for the given target IDs. */\n\n    this.existenceFilters = {};\n    /** Keeps track of the current target mappings */\n\n    this.targetChanges = {};\n    /** Keeps track of document to update */\n\n    this.documentUpdates = maybeDocumentMap();\n    /** Whether this aggregator was frozen and can no longer be modified */\n\n    this.frozen = false;\n    this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n  }\n  /** Aggregates a watch change into the current state */\n\n\n  WatchChangeAggregator.prototype.add = function (watchChange) {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n\n    if (watchChange instanceof DocumentWatchChange) {\n      this.addDocumentChange(watchChange);\n    } else if (watchChange instanceof WatchTargetChange) {\n      this.addTargetChange(watchChange);\n    } else if (watchChange instanceof ExistenceFilterChange) {\n      this.addExistenceFilterChange(watchChange);\n    } else {\n      fail('Unknown watch change: ' + watchChange);\n    }\n  };\n  /** Aggregates all provided watch changes to the current state in order */\n\n\n  WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n    var _this = this;\n\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    watchChanges.forEach(function (change) {\n      return _this.add(change);\n    });\n  };\n  /**\n   * Converts the current state into a remote event with the snapshot version\n   * provided via the constructor.\n   */\n\n\n  WatchChangeAggregator.prototype.createRemoteEvent = function () {\n    var _this = this;\n\n    var targetChanges = this.targetChanges; // Remove all the non-active targets from the remote event.\n\n    objUtils.forEachNumber(this.targetChanges, function (targetId) {\n      if (!_this.isActiveTarget(targetId)) {\n        delete targetChanges[targetId];\n      }\n    }); // Mark this aggregator as frozen so no further modifications are made\n\n    this.frozen = true;\n    return new RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n  };\n\n  WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n    var change = this.targetChanges[targetId];\n\n    if (!change) {\n      // Create an UpdateMapping by default, since resets are always explicit.\n      change = {\n        currentStatusUpdate: CurrentStatusUpdate.None,\n        snapshotVersion: this.snapshotVersion,\n        mapping: new UpdateMapping(),\n        resumeToken: emptyByteString()\n      };\n      this.targetChanges[targetId] = change;\n    }\n\n    return change;\n  };\n  /**\n   * We need to wait for watch to ack targets before we process those events,\n   * so to know if a target is active, there must be no pending acks we're\n   * waiting for and it must be in the current list of targets that the client\n   * cares about.\n   *\n   * This method is visible for testing.\n   */\n\n\n  WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n    return !objUtils.contains(this.pendingTargetResponses, targetId) && objUtils.contains(this.listenTargets, targetId);\n  };\n\n  WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n    var relevant = false;\n\n    for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n      var targetId = _a[_i];\n\n      if (this.isActiveTarget(targetId)) {\n        var change = this.ensureTargetChange(targetId);\n        change.mapping.add(docChange.key);\n        relevant = true;\n      }\n    }\n\n    for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n      var targetId = _c[_b];\n\n      if (this.isActiveTarget(targetId)) {\n        var change = this.ensureTargetChange(targetId);\n        change.mapping.delete(docChange.key);\n        relevant = true;\n      }\n    } // Only update the document if there is a new document to replace to an\n    // active target that is being listened to, this might be just a target\n    // update instead.\n\n\n    if (docChange.newDoc && relevant) {\n      this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n    }\n  };\n\n  WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n    var _this = this;\n\n    targetChange.targetIds.forEach(function (targetId) {\n      var change = _this.ensureTargetChange(targetId);\n\n      switch (targetChange.state) {\n        case WatchTargetChangeState.NoChange:\n          if (_this.isActiveTarget(targetId)) {\n            // Creating the change above satisfies the semantics of no-change.\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n\n          break;\n\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          _this.recordTargetResponse(targetId);\n\n          if (!objUtils.contains(_this.pendingTargetResponses, targetId)) {\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            change.mapping = new UpdateMapping();\n            change.currentStatusUpdate = CurrentStatusUpdate.None;\n            delete _this.existenceFilters[targetId];\n          }\n\n          applyResumeToken(change, targetChange.resumeToken);\n          break;\n\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can\n          // post-filter and remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          _this.recordTargetResponse(targetId);\n\n          assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n          break;\n\n        case WatchTargetChangeState.Current:\n          if (_this.isActiveTarget(targetId)) {\n            change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n\n          break;\n\n        case WatchTargetChangeState.Reset:\n          if (_this.isActiveTarget(targetId)) {\n            // Overwrite any existing target mapping with a reset\n            // mapping. Every subsequent update will modify the reset\n            // mapping, not an update mapping.\n            change.mapping = new ResetMapping();\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n\n          break;\n\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      }\n    });\n  };\n  /**\n   * Record that we get a watch target add/remove by decrementing the number of\n   * pending target responses that we have.\n   */\n\n\n  WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n    var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n\n    if (newCount === 0) {\n      delete this.pendingTargetResponses[targetId];\n    } else {\n      this.pendingTargetResponses[targetId] = newCount;\n    }\n  };\n\n  WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n    if (this.isActiveTarget(change.targetId)) {\n      this.existenceFilters[change.targetId] = change.existenceFilter;\n    }\n  };\n\n  return WatchChangeAggregator;\n}();\n\nexport { WatchChangeAggregator };\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\n\nfunction applyResumeToken(change, resumeToken) {\n  if (resumeToken.length > 0) {\n    change.resumeToken = resumeToken;\n  }\n}","map":{"version":3,"sources":["../src/remote/watch_change.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as objUtils from '../util/obj';\n\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  CurrentStatusUpdate,\n  RemoteEvent,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from './remote_event';\n\n/**\n * Internal representation of the watcher API protocol buffers.\n */\nexport type WatchChange =\n  | DocumentWatchChange\n  | WatchTargetChange\n  | ExistenceFilterChange;\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nexport class DocumentWatchChange {\n  constructor(\n    /** The new document applies to all of these targets. */\n    public updatedTargetIds: TargetId[],\n    /** The new document is removed from all of these targets. */\n    public removedTargetIds: TargetId[],\n    /** The key of the document for this change. */\n    public key: DocumentKey,\n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    public newDoc: Document | NoDocument | null\n  ) {}\n}\n\nexport class ExistenceFilterChange {\n  constructor(\n    public targetId: TargetId,\n    public existenceFilter: ExistenceFilter\n  ) {}\n}\n\nexport enum WatchTargetChangeState {\n  NoChange,\n  Added,\n  Removed,\n  Current,\n  Reset\n}\n\nexport class WatchTargetChange {\n  constructor(\n    /** What kind of change occurred to the watch target. */\n    public state: WatchTargetChangeState,\n    /** The target IDs that were added/removed/set. */\n    public targetIds: TargetId[],\n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the query. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    public resumeToken: ProtoByteString = emptyByteString(),\n    /** An RPC error indicating why the watch failed. */\n    public cause: FirestoreError | null = null\n  ) {}\n}\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nexport class WatchChangeAggregator {\n  constructor(\n    private snapshotVersion: SnapshotVersion,\n    private readonly listenTargets: { [targetId: number]: QueryData },\n    pendingTargetResponses: { [targetId: number]: number }\n  ) {\n    this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n  }\n\n  /** The existence filter - if any - for the given target IDs. */\n  readonly existenceFilters: { [targetId: number]: ExistenceFilter } = {};\n\n  /** The number of pending responses that we are waiting on from watch. */\n  readonly pendingTargetResponses: { [targetId: number]: number };\n\n  /** Keeps track of the current target mappings */\n  private targetChanges: { [targetId: number]: TargetChange } = {};\n\n  /** Keeps track of document to update */\n  private documentUpdates = maybeDocumentMap();\n\n  /** Whether this aggregator was frozen and can no longer be modified */\n  private frozen = false;\n\n  /** Aggregates a watch change into the current state */\n  add(watchChange: WatchChange): void {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    if (watchChange instanceof DocumentWatchChange) {\n      this.addDocumentChange(watchChange);\n    } else if (watchChange instanceof WatchTargetChange) {\n      this.addTargetChange(watchChange);\n    } else if (watchChange instanceof ExistenceFilterChange) {\n      this.addExistenceFilterChange(watchChange);\n    } else {\n      fail('Unknown watch change: ' + watchChange);\n    }\n  }\n\n  /** Aggregates all provided watch changes to the current state in order */\n  addChanges(watchChanges: WatchChange[]): void {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    watchChanges.forEach(change => this.add(change));\n  }\n\n  /**\n   * Converts the current state into a remote event with the snapshot version\n   * provided via the constructor.\n   */\n  createRemoteEvent(): RemoteEvent {\n    const targetChanges = this.targetChanges;\n\n    // Remove all the non-active targets from the remote event.\n    objUtils.forEachNumber(this.targetChanges, targetId => {\n      if (!this.isActiveTarget(targetId)) {\n        delete targetChanges[targetId];\n      }\n    });\n\n    // Mark this aggregator as frozen so no further modifications are made\n    this.frozen = true;\n    return new RemoteEvent(\n      this.snapshotVersion,\n      targetChanges,\n      this.documentUpdates\n    );\n  }\n\n  private ensureTargetChange(targetId: TargetId): TargetChange {\n    let change = this.targetChanges[targetId];\n    if (!change) {\n      // Create an UpdateMapping by default, since resets are always explicit.\n      change = {\n        currentStatusUpdate: CurrentStatusUpdate.None,\n        snapshotVersion: this.snapshotVersion,\n        mapping: new UpdateMapping(),\n        resumeToken: emptyByteString()\n      };\n      this.targetChanges[targetId] = change;\n    }\n    return change;\n  }\n\n  /**\n   * We need to wait for watch to ack targets before we process those events,\n   * so to know if a target is active, there must be no pending acks we're\n   * waiting for and it must be in the current list of targets that the client\n   * cares about.\n   *\n   * This method is visible for testing.\n   */\n  protected isActiveTarget(targetId: TargetId): boolean {\n    return (\n      !objUtils.contains(this.pendingTargetResponses, targetId) &&\n      objUtils.contains(this.listenTargets, targetId)\n    );\n  }\n\n  private addDocumentChange(docChange: DocumentWatchChange) {\n    let relevant = false;\n\n    for (const targetId of docChange.updatedTargetIds) {\n      if (this.isActiveTarget(targetId)) {\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.add(docChange.key);\n        relevant = true;\n      }\n    }\n\n    for (const targetId of docChange.removedTargetIds) {\n      if (this.isActiveTarget(targetId)) {\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.delete(docChange.key);\n        relevant = true;\n      }\n    }\n\n    // Only update the document if there is a new document to replace to an\n    // active target that is being listened to, this might be just a target\n    // update instead.\n    if (docChange.newDoc && relevant) {\n      this.documentUpdates = this.documentUpdates.insert(\n        docChange.key,\n        docChange.newDoc\n      );\n    }\n  }\n\n  private addTargetChange(targetChange: WatchTargetChange) {\n    targetChange.targetIds.forEach(targetId => {\n      const change = this.ensureTargetChange(targetId);\n      switch (targetChange.state) {\n        case WatchTargetChangeState.NoChange:\n          if (this.isActiveTarget(targetId)) {\n            // Creating the change above satisfies the semantics of no-change.\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          if (!objUtils.contains(this.pendingTargetResponses, targetId)) {\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            change.mapping = new UpdateMapping();\n            change.currentStatusUpdate = CurrentStatusUpdate.None;\n            delete this.existenceFilters[targetId];\n          }\n          applyResumeToken(change, targetChange.resumeToken);\n          break;\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can\n          // post-filter and remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          assert(\n            !targetChange.cause,\n            'WatchChangeAggregator does not handle errored targets'\n          );\n          break;\n        case WatchTargetChangeState.Current:\n          if (this.isActiveTarget(targetId)) {\n            change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Reset:\n          if (this.isActiveTarget(targetId)) {\n            // Overwrite any existing target mapping with a reset\n            // mapping. Every subsequent update will modify the reset\n            // mapping, not an update mapping.\n            change.mapping = new ResetMapping();\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      }\n    });\n  }\n\n  /**\n   * Record that we get a watch target add/remove by decrementing the number of\n   * pending target responses that we have.\n   */\n  private recordTargetResponse(targetId: TargetId): void {\n    const newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n    if (newCount === 0) {\n      delete this.pendingTargetResponses[targetId];\n    } else {\n      this.pendingTargetResponses[targetId] = newCount;\n    }\n  }\n\n  private addExistenceFilterChange(change: ExistenceFilterChange): void {\n    if (this.isActiveTarget(change.targetId)) {\n      this.existenceFilters[change.targetId] = change.existenceFilter;\n    }\n  }\n}\n\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(\n  change: TargetChange,\n  resumeToken: ProtoByteString\n): void {\n  if (resumeToken.length > 0) {\n    change.resumeToken = resumeToken;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}