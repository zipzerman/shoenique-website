{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { fail } from '../util/assert';\nimport { DbRemoteDocument } from './indexeddb_schema';\nimport { SimpleDbTransaction } from './simple_db';\n\nvar IndexedDbRemoteDocumentCache =\n/** @class */\nfunction () {\n  function IndexedDbRemoteDocumentCache(serializer) {\n    this.serializer = serializer;\n  }\n\n  IndexedDbRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n    return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));\n  };\n\n  IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n    return remoteDocumentsStore(transaction).delete(dbKey(documentKey));\n  };\n\n  IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n    var _this = this;\n\n    return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function (dbRemoteDoc) {\n      return dbRemoteDoc ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc) : null;\n    });\n  };\n\n  IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n    var _this = this;\n\n    var results = documentMap(); // Documents are ordered by key, so we can use a prefix scan to narrow down\n    // the documents we need to match the query against.\n\n    var startKey = query.path.toArray();\n    var range = IDBKeyRange.lowerBound(startKey);\n    return remoteDocumentsStore(transaction).iterate({\n      range: range\n    }, function (key, dbRemoteDoc, control) {\n      var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);\n\n      if (!query.path.isPrefixOf(maybeDoc.key.path)) {\n        control.done();\n      } else if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n        results = results.insert(maybeDoc.key, maybeDoc);\n      }\n    }).next(function () {\n      return results;\n    });\n  };\n\n  return IndexedDbRemoteDocumentCache;\n}();\n\nexport { IndexedDbRemoteDocumentCache };\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\n\nfunction remoteDocumentsStore(txn) {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store(DbRemoteDocument.store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n\nfunction dbKey(docKey) {\n  return docKey.path.toArray();\n}","map":{"version":3,"sources":["../src/local/indexeddb_remote_document_cache.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAGH,SAAsB,WAAtB,QAAyC,sBAAzC;AACA,SAAS,QAAT,QAAwC,mBAAxC;AAEA,SAAS,IAAT,QAAqB,gBAArB;AAEA,SAAS,gBAAT,QAAsD,oBAAtD;AAKA,SAAwB,mBAAxB,QAAmD,aAAnD;;AAEA,IAAA,4BAAA;AAAA;AAAA,YAAA;AACE,WAAA,4BAAA,CAAoB,UAApB,EAA+C;AAA3B,SAAA,UAAA,GAAA,UAAA;AAA+B;;AAEnD,EAAA,4BAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UACE,WADF,EAEE,aAFF,EAE8B;AAE5B,WAAO,oBAAoB,CAAC,WAAD,CAApB,CAAkC,GAAlC,CACL,KAAK,CAAC,aAAa,CAAC,GAAf,CADA,EAEL,KAAK,UAAL,CAAgB,kBAAhB,CAAmC,aAAnC,CAFK,CAAP;AAID,GARD;;AAUA,EAAA,4BAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE0B;AAExB,WAAO,oBAAoB,CAAC,WAAD,CAApB,CAAkC,MAAlC,CAAyC,KAAK,CAAC,WAAD,CAA9C,CAAP;AACD,GALD;;AAOA,EAAA,4BAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE0B;AAF1B,QAAA,KAAA,GAAA,IAAA;;AAIE,WAAO,oBAAoB,CAAC,WAAD,CAApB,CACJ,GADI,CACA,KAAK,CAAC,WAAD,CADL,EAEJ,IAFI,CAEC,UAAA,WAAA,EAAW;AACf,aAAO,WAAW,GACd,KAAI,CAAC,UAAL,CAAgB,oBAAhB,CAAqC,WAArC,CADc,GAEd,IAFJ;AAGD,KANI,CAAP;AAOD,GAXD;;AAaA,EAAA,4BAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UACE,WADF,EAEE,KAFF,EAEc;AAFd,QAAA,KAAA,GAAA,IAAA;;AAIE,QAAI,OAAO,GAAG,WAAW,EAAzB,CAFY,CAIZ;AACA;;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,IAAN,CAAW,OAAX,EAAjB;AACA,QAAM,KAAK,GAAG,WAAW,CAAC,UAAZ,CAAuB,QAAvB,CAAd;AACA,WAAO,oBAAoB,CAAC,WAAD,CAApB,CACJ,OADI,CACI;AAAE,MAAA,KAAK,EAAA;AAAP,KADJ,EACe,UAAC,GAAD,EAAM,WAAN,EAAmB,OAAnB,EAA0B;AAC5C,UAAM,QAAQ,GAAG,KAAI,CAAC,UAAL,CAAgB,oBAAhB,CAAqC,WAArC,CAAjB;;AACA,UAAI,CAAC,KAAK,CAAC,IAAN,CAAW,UAAX,CAAsB,QAAQ,CAAC,GAAT,CAAa,IAAnC,CAAL,EAA+C;AAC7C,QAAA,OAAO,CAAC,IAAR;AACD,OAFD,MAEO,IAAI,QAAQ,YAAY,QAApB,IAAgC,KAAK,CAAC,OAAN,CAAc,QAAd,CAApC,EAA6D;AAClE,QAAA,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,QAAQ,CAAC,GAAxB,EAA6B,QAA7B,CAAV;AACD;AACF,KARI,EASJ,IATI,CASC,YAAA;AAAM,aAAA,OAAA;AAAO,KATd,CAAP;AAUD,GApBD;;AAqBF,SAAA,4BAAA;AAAC,CAtDD,EAAA;;;AAwDA;;AAEG;;AACH,SAAA,oBAAA,CACE,GADF,EAC6B;AAE3B,MAAI,GAAG,YAAY,mBAAnB,EAAwC;AACtC,WAAO,GAAG,CAAC,KAAJ,CACL,gBAAgB,CAAC,KADZ,CAAP;AAGD,GAJD,MAIO;AACL,WAAO,IAAI,CAAC,sCAAD,CAAX;AACD;AACF;;AAED,SAAA,KAAA,CAAe,MAAf,EAAkC;AAChC,SAAO,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAP;AACD","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { DocumentMap, documentMap } from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\n\nimport { DbRemoteDocument, DbRemoteDocumentKey } from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\nexport class IndexedDbRemoteDocumentCache implements RemoteDocumentCache {\n  constructor(private serializer: LocalSerializer) {}\n\n  addEntry(\n    transaction: PersistenceTransaction,\n    maybeDocument: MaybeDocument\n  ): PersistencePromise<void> {\n    return remoteDocumentsStore(transaction).put(\n      dbKey(maybeDocument.key),\n      this.serializer.toDbRemoteDocument(maybeDocument)\n    );\n  }\n\n  removeEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<void> {\n    return remoteDocumentsStore(transaction).delete(dbKey(documentKey));\n  }\n\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return remoteDocumentsStore(transaction)\n      .get(dbKey(documentKey))\n      .next(dbRemoteDoc => {\n        return dbRemoteDoc\n          ? this.serializer.fromDbRemoteDocument(dbRemoteDoc)\n          : null;\n      });\n  }\n\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    let results = documentMap();\n\n    // Documents are ordered by key, so we can use a prefix scan to narrow down\n    // the documents we need to match the query against.\n    const startKey = query.path.toArray();\n    const range = IDBKeyRange.lowerBound(startKey);\n    return remoteDocumentsStore(transaction)\n      .iterate({ range }, (key, dbRemoteDoc, control) => {\n        const maybeDoc = this.serializer.fromDbRemoteDocument(dbRemoteDoc);\n        if (!query.path.isPrefixOf(maybeDoc.key.path)) {\n          control.done();\n        } else if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n          results = results.insert(maybeDoc.key, maybeDoc);\n        }\n      })\n      .next(() => results);\n  }\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbRemoteDocumentKey, DbRemoteDocument> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<DbRemoteDocumentKey, DbRemoteDocument>(\n      DbRemoteDocument.store\n    );\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n\nfunction dbKey(docKey: DocumentKey): DbRemoteDocumentKey {\n  return docKey.path.toArray();\n}\n"]},"metadata":{},"sourceType":"module"}