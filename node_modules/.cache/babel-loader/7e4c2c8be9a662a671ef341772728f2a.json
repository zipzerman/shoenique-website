{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { PersistencePromise } from './persistence_promise';\n\nvar MemoryRemoteDocumentCache =\n/** @class */\nfunction () {\n  function MemoryRemoteDocumentCache() {\n    this.docs = maybeDocumentMap();\n  }\n\n  MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n    this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n    this.docs = this.docs.remove(documentKey);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n    return PersistencePromise.resolve(this.docs.get(documentKey));\n  };\n\n  MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n    var results = documentMap(); // Documents are ordered by key, so we can use a prefix scan to narrow down\n    // the documents we need to match the query against.\n\n    var prefix = new DocumentKey(query.path.child(''));\n    var iterator = this.docs.getIteratorFrom(prefix);\n\n    while (iterator.hasNext()) {\n      var _a = iterator.getNext(),\n          key = _a.key,\n          maybeDoc = _a.value;\n\n      if (!query.path.isPrefixOf(key.path)) {\n        break;\n      }\n\n      if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n        results = results.insert(maybeDoc.key, maybeDoc);\n      }\n    }\n\n    return PersistencePromise.resolve(results);\n  };\n\n  return MemoryRemoteDocumentCache;\n}();\n\nexport { MemoryRemoteDocumentCache };","map":{"version":3,"sources":["../src/local/memory_remote_document_cache.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAGH,SAEE,WAFF,EAGE,gBAHF,QAIO,sBAJP;AAKA,SAAS,QAAT,QAAwC,mBAAxC;AACA,SAAS,WAAT,QAA4B,uBAA5B;AAIA,SAAS,kBAAT,QAAmC,uBAAnC;;AAGA,IAAA,yBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,yBAAA,GAAA;AACU,SAAA,IAAA,GAAO,gBAAgB,EAAvB;AA8CT;;AA5CC,EAAA,yBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UACE,WADF,EAEE,aAFF,EAE8B;AAE5B,SAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,CAAiB,aAAa,CAAC,GAA/B,EAAoC,aAApC,CAAZ;AACA,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GAND;;AAQA,EAAA,yBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE0B;AAExB,SAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,CAAiB,WAAjB,CAAZ;AACA,WAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,GAND;;AAQA,EAAA,yBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UACE,WADF,EAEE,WAFF,EAE0B;AAExB,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,KAAK,IAAL,CAAU,GAAV,CAAc,WAAd,CAA3B,CAAP;AACD,GALD;;AAOA,EAAA,yBAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UACE,WADF,EAEE,KAFF,EAEc;AAEZ,QAAI,OAAO,GAAG,WAAW,EAAzB,CAFY,CAIZ;AACA;;AACA,QAAM,MAAM,GAAG,IAAI,WAAJ,CAAgB,KAAK,CAAC,IAAN,CAAW,KAAX,CAAiB,EAAjB,CAAhB,CAAf;AACA,QAAM,QAAQ,GAAG,KAAK,IAAL,CAAU,eAAV,CAA0B,MAA1B,CAAjB;;AACA,WAAO,QAAQ,CAAC,OAAT,EAAP,EAA2B;AACnB,UAAA,EAAA,GAAA,QAAA,CAAA,OAAA,EAAA;AAAA,UAAE,GAAA,GAAA,EAAA,CAAA,GAAF;AAAA,UAAO,QAAA,GAAA,EAAA,CAAA,KAAP;;AACN,UAAI,CAAC,KAAK,CAAC,IAAN,CAAW,UAAX,CAAsB,GAAG,CAAC,IAA1B,CAAL,EAAsC;AACpC;AACD;;AACD,UAAI,QAAQ,YAAY,QAApB,IAAgC,KAAK,CAAC,OAAN,CAAc,QAAd,CAApC,EAA6D;AAC3D,QAAA,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,QAAQ,CAAC,GAAxB,EAA6B,QAA7B,CAAV;AACD;AACF;;AACD,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,OAA3B,CAAP;AACD,GApBD;;AAqBF,SAAA,yBAAA;AAAC,CA/CD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport {\n  DocumentMap,\n  documentMap,\n  maybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\n\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\nexport class MemoryRemoteDocumentCache implements RemoteDocumentCache {\n  private docs = maybeDocumentMap();\n\n  addEntry(\n    transaction: PersistenceTransaction,\n    maybeDocument: MaybeDocument\n  ): PersistencePromise<void> {\n    this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n    return PersistencePromise.resolve();\n  }\n\n  removeEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<void> {\n    this.docs = this.docs.remove(documentKey);\n    return PersistencePromise.resolve();\n  }\n\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return PersistencePromise.resolve(this.docs.get(documentKey));\n  }\n\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    let results = documentMap();\n\n    // Documents are ordered by key, so we can use a prefix scan to narrow down\n    // the documents we need to match the query against.\n    const prefix = new DocumentKey(query.path.child(''));\n    const iterator = this.docs.getIteratorFrom(prefix);\n    while (iterator.hasNext()) {\n      const { key, value: maybeDoc } = iterator.getNext();\n      if (!query.path.isPrefixOf(key.path)) {\n        break;\n      }\n      if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n        results = results.insert(maybeDoc.key, maybeDoc);\n      }\n    }\n    return PersistencePromise.resolve(results);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}