{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nvar escapeChar = '\\u0001';\nvar encodedSeparatorChar = '\\u0001';\nvar encodedNul = '\\u0010';\nvar encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\n\nexport function encode(path) {\n  var result = '';\n\n  for (var i = 0; i < path.length; i++) {\n    if (result.length > 0) {\n      result = encodeSeparator(result);\n    }\n\n    result = encodeSegment(path.get(i), result);\n  }\n\n  return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\n\nfunction encodeSegment(segment, resultBuf) {\n  var result = resultBuf;\n  var length = segment.length;\n\n  for (var i = 0; i < length; i++) {\n    var c = segment.charAt(i);\n\n    switch (c) {\n      case '\\0':\n        result += escapeChar + encodedNul;\n        break;\n\n      case escapeChar:\n        result += escapeChar + encodedEscape;\n        break;\n\n      default:\n        result += c;\n    }\n  }\n\n  return result;\n}\n/** Encodes a path separator into the given result */\n\n\nfunction encodeSeparator(result) {\n  return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\n\n\nexport function decode(path) {\n  // Event the empty path must encode as a path of at least length 2. A path\n  // with exactly 2 must be the empty path.\n  var length = path.length;\n  assert(length >= 2, 'Invalid path ' + path);\n\n  if (length === 2) {\n    assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');\n    return ResourcePath.EMPTY_PATH;\n  } // Escape characters cannot exist past the second-to-last position in the\n  // source value.\n\n\n  var lastReasonableEscapeIndex = length - 2;\n  var segments = [];\n  var segmentBuilder = '';\n\n  for (var start = 0; start < length;) {\n    // The last two characters of a valid encoded path must be a separator, so\n    // there must be an end to this segment.\n    var end = path.indexOf(escapeChar, start);\n\n    if (end < 0 || end > lastReasonableEscapeIndex) {\n      fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    var next = path.charAt(end + 1);\n\n    switch (next) {\n      case encodedSeparatorChar:\n        var currentPiece = path.substring(start, end);\n        var segment = void 0;\n\n        if (segmentBuilder.length === 0) {\n          // Avoid copying for the common case of a segment that excludes \\0\n          // and \\001\n          segment = currentPiece;\n        } else {\n          segmentBuilder += currentPiece;\n          segment = segmentBuilder;\n          segmentBuilder = '';\n        }\n\n        segments.push(segment);\n        break;\n\n      case encodedNul:\n        segmentBuilder += path.substring(start, end);\n        segmentBuilder += '\\0';\n        break;\n\n      case encodedEscape:\n        // The escape character can be used in the output to encode itself.\n        segmentBuilder += path.substring(start, end + 1);\n        break;\n\n      default:\n        fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    start = end + 2;\n  }\n\n  return new ResourcePath(segments);\n}\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\n\nexport function prefixSuccessor(path) {\n  var c = path.charCodeAt(path.length - 1); // TODO(mcg): this really should be a general thing, but not worth it right\n  // now\n\n  assert(c === 1, 'successor may only operate on paths generated by encode');\n  return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}","map":{"version":3,"sources":["../src/local/encoded_resource_path.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\n\n/**\n * Helpers for dealing with resource paths stored in IndexedDB.\n *\n * Resource paths in their canonical string form do not sort as the server\n * sorts them. Specifically the server splits paths into segments first and then\n * sorts, putting end-of-segment before any character. In a UTF-8 string\n * encoding the slash ('/') that denotes the end-of-segment naturally comes\n * after other characters so the intent here is to encode the path delimiters in\n * such a way that the resulting strings sort naturally.\n *\n * Resource paths are also used for prefix scans so it's important to\n * distinguish whole segments from any longer segments of which they might be a\n * prefix. For example, it's important to make it possible to scan documents in\n * a collection \"foo\" without encountering documents in a collection \"foobar\".\n *\n * Separate from the concerns about resource path ordering and separation,\n * On Android, SQLite imposes additional restrictions since it does not handle\n * keys with embedded NUL bytes particularly well. Rather than change the\n * implementation we keep the encoding identical to keep the ports similar.\n *\n * Taken together this means resource paths when encoded for storage in\n * IndexedDB have the following characteristics:\n *\n *   * Segment separators (\"/\") sort before everything else.\n *   * All paths have a trailing separator.\n *   * NUL bytes do not exist in the output, since IndexedDB doesn't treat them\n * well.\n *\n * Therefore resource paths are encoded into string form using the following\n * rules:\n *\n *   * '\\x01' is used as an escape character.\n *   * Path separators are encoded as \"\\x01\\x01\"\n *   * NUL bytes are encoded as \"\\x01\\x10\"\n *   * '\\x01' is encoded as \"\\x01\\x11\"\n *\n * This encoding leaves some room between path separators and the NUL byte\n * just in case we decide to support integer document ids after all.\n *\n * Note that characters treated specially by the backend ('.', '/', and '~')\n * are not treated specially here. This class assumes that any unescaping of\n * resource path strings into actual ResourcePath objects will handle these\n * characters there.\n */\nexport type EncodedResourcePath = string;\n\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nexport function encode(path: ResourcePath): EncodedResourcePath {\n  let result = '';\n  for (let i = 0; i < path.length; i++) {\n    if (result.length > 0) {\n      result = encodeSeparator(result);\n    }\n    result = encodeSegment(path.get(i), result);\n  }\n  return encodeSeparator(result);\n}\n\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment: string, resultBuf: string) {\n  let result = resultBuf;\n  const length = segment.length;\n  for (let i = 0; i < length; i++) {\n    const c = segment.charAt(i);\n    switch (c) {\n      case '\\0':\n        result += escapeChar + encodedNul;\n        break;\n      case escapeChar:\n        result += escapeChar + encodedEscape;\n        break;\n      default:\n        result += c;\n    }\n  }\n  return result;\n}\n\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result: string): string {\n  return result + escapeChar + encodedSeparatorChar;\n}\n\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nexport function decode(path: EncodedResourcePath): ResourcePath {\n  // Event the empty path must encode as a path of at least length 2. A path\n  // with exactly 2 must be the empty path.\n  const length = path.length;\n  assert(length >= 2, 'Invalid path ' + path);\n  if (length === 2) {\n    assert(\n      path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar,\n      'Non-empty path ' + path + ' had length 2'\n    );\n    return ResourcePath.EMPTY_PATH;\n  }\n\n  // Escape characters cannot exist past the second-to-last position in the\n  // source value.\n  const lastReasonableEscapeIndex = length - 2;\n\n  const segments: string[] = [];\n  let segmentBuilder = '';\n\n  for (let start = 0; start < length; ) {\n    // The last two characters of a valid encoded path must be a separator, so\n    // there must be an end to this segment.\n    const end = path.indexOf(escapeChar, start);\n    if (end < 0 || end > lastReasonableEscapeIndex) {\n      fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    const next = path.charAt(end + 1);\n    switch (next) {\n      case encodedSeparatorChar:\n        const currentPiece = path.substring(start, end);\n        let segment;\n        if (segmentBuilder.length === 0) {\n          // Avoid copying for the common case of a segment that excludes \\0\n          // and \\001\n          segment = currentPiece;\n        } else {\n          segmentBuilder += currentPiece;\n          segment = segmentBuilder;\n          segmentBuilder = '';\n        }\n        segments.push(segment);\n        break;\n      case encodedNul:\n        segmentBuilder += path.substring(start, end);\n        segmentBuilder += '\\0';\n        break;\n      case encodedEscape:\n        // The escape character can be used in the output to encode itself.\n        segmentBuilder += path.substring(start, end + 1);\n        break;\n      default:\n        fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    start = end + 2;\n  }\n\n  return new ResourcePath(segments);\n}\n\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nexport function prefixSuccessor(path: EncodedResourcePath) {\n  const c = path.charCodeAt(path.length - 1);\n  // TODO(mcg): this really should be a general thing, but not worth it right\n  // now\n  assert(c === 1, 'successor may only operate on paths generated by encode');\n  return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n"]},"metadata":{},"sourceType":"module"}