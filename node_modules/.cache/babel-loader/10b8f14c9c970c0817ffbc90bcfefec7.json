{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as objUtil from './obj';\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\n\nvar ObjectMap =\n/** @class */\nfunction () {\n  function ObjectMap(mapKeyFn) {\n    this.mapKeyFn = mapKeyFn;\n    /**\n     * The inner map for a key -> value pair. Due to the possibility of\n     * collisions we keep a list of entries that we do a linear search through\n     * to find an actual match. Note that collisions should be rare, so we still\n     * expect near constant time lookups in practice.\n     */\n\n    this.inner = {};\n  }\n  /** Get a value for this key, or undefined if it does not exist. */\n\n\n  ObjectMap.prototype.get = function (key) {\n    var id = this.mapKeyFn(key);\n    var matches = this.inner[id];\n\n    if (matches === undefined) {\n      return undefined;\n    }\n\n    for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n      var _a = matches_1[_i],\n          otherKey = _a[0],\n          value = _a[1];\n\n      if (otherKey.equals(key)) {\n        return value;\n      }\n    }\n\n    return undefined;\n  };\n\n  ObjectMap.prototype.has = function (key) {\n    return this.get(key) !== undefined;\n  };\n  /** Put this key and value in the map. */\n\n\n  ObjectMap.prototype.set = function (key, value) {\n    var id = this.mapKeyFn(key);\n    var matches = this.inner[id];\n\n    if (matches === undefined) {\n      this.inner[id] = [[key, value]];\n      return;\n    }\n\n    for (var i = 0; i < matches.length; i++) {\n      if (matches[i][0].equals(key)) {\n        matches[i] = [key, value];\n        return;\n      }\n    }\n\n    matches.push([key, value]);\n  };\n  /**\n   * Remove this key from the map. Returns a boolean if anything was deleted.\n   */\n\n\n  ObjectMap.prototype.delete = function (key) {\n    var id = this.mapKeyFn(key);\n    var matches = this.inner[id];\n\n    if (matches === undefined) {\n      return false;\n    }\n\n    for (var i = 0; i < matches.length; i++) {\n      if (matches[i][0].equals(key)) {\n        if (matches.length === 1) {\n          delete this.inner[id];\n        } else {\n          matches.splice(i, 1);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  ObjectMap.prototype.forEach = function (fn) {\n    objUtil.forEach(this.inner, function (_, entries) {\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var _a = entries_1[_i],\n            k = _a[0],\n            v = _a[1];\n        fn(k, v);\n      }\n    });\n  };\n\n  ObjectMap.prototype.isEmpty = function () {\n    return objUtil.isEmpty(this.inner);\n  };\n\n  return ObjectMap;\n}();\n\nexport { ObjectMap };","map":{"version":3,"sources":["../src/util/obj_map.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Equatable } from './misc';\nimport * as objUtil from './obj';\n\ntype Entry<K, V> = [K, V];\n\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nexport class ObjectMap<KeyType extends Equatable<KeyType>, ValueType> {\n  /**\n   * The inner map for a key -> value pair. Due to the possibility of\n   * collisions we keep a list of entries that we do a linear search through\n   * to find an actual match. Note that collisions should be rare, so we still\n   * expect near constant time lookups in practice.\n   */\n  private inner: {\n    [canonicalId: string]: Array<Entry<KeyType, ValueType>>;\n  } = {};\n\n  constructor(private mapKeyFn: (key: KeyType) => string) {}\n\n  /** Get a value for this key, or undefined if it does not exist. */\n  get(key: KeyType): ValueType | undefined {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      return undefined;\n    }\n    for (const [otherKey, value] of matches) {\n      if (otherKey.equals(key)) {\n        return value;\n      }\n    }\n    return undefined;\n  }\n\n  has(key: KeyType): boolean {\n    return this.get(key) !== undefined;\n  }\n\n  /** Put this key and value in the map. */\n  set(key: KeyType, value: ValueType): void {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      this.inner[id] = [[key, value]];\n      return;\n    }\n    for (let i = 0; i < matches.length; i++) {\n      if (matches[i][0].equals(key)) {\n        matches[i] = [key, value];\n        return;\n      }\n    }\n    matches.push([key, value]);\n  }\n\n  /**\n   * Remove this key from the map. Returns a boolean if anything was deleted.\n   */\n  delete(key: KeyType): boolean {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      return false;\n    }\n    for (let i = 0; i < matches.length; i++) {\n      if (matches[i][0].equals(key)) {\n        if (matches.length === 1) {\n          delete this.inner[id];\n        } else {\n          matches.splice(i, 1);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  forEach(fn: (key: KeyType, val: ValueType) => void): void {\n    objUtil.forEach(this.inner, (_, entries) => {\n      for (const [k, v] of entries) {\n        fn(k, v);\n      }\n    });\n  }\n\n  isEmpty(): boolean {\n    return objUtil.isEmpty(this.inner);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}