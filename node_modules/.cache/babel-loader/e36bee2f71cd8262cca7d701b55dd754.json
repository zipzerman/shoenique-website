{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\n\nvar PersistencePromise =\n/** @class */\nfunction () {\n  function PersistencePromise(callback) {\n    var _this = this; // NOTE: next/catchCallback will always point to our own wrapper functions,\n    // not the user's raw next() or catch() callbacks.\n\n\n    this.nextCallback = null;\n    this.catchCallback = null; // When the operation resolves, we'll set result or error and mark isDone.\n\n    this.result = undefined;\n    this.error = null;\n    this.isDone = false; // Set to true when .then() or .catch() are called and prevents additional\n    // chaining.\n\n    this.callbackAttached = false;\n    callback(function (value) {\n      _this.isDone = true;\n      _this.result = value;\n\n      if (_this.nextCallback) {\n        // value should be defined unless T is Void, but we can't express\n        // that in the type system.\n        _this.nextCallback(value);\n      }\n    }, function (error) {\n      _this.isDone = true;\n      _this.error = error;\n\n      if (_this.catchCallback) {\n        _this.catchCallback(error);\n      }\n    });\n  }\n\n  PersistencePromise.prototype.catch = function (fn) {\n    return this.next(undefined, fn);\n  };\n\n  PersistencePromise.prototype.next = function (nextFn, catchFn) {\n    var _this = this;\n\n    if (this.callbackAttached) {\n      fail('Called next() or catch() twice for PersistencePromise');\n    }\n\n    this.callbackAttached = true;\n\n    if (this.isDone) {\n      if (!this.error) {\n        return this.wrapSuccess(nextFn, this.result);\n      } else {\n        return this.wrapFailure(catchFn, this.error);\n      }\n    } else {\n      return new PersistencePromise(function (resolve, reject) {\n        _this.nextCallback = function (value) {\n          _this.wrapSuccess(nextFn, value).next(resolve, reject);\n        };\n\n        _this.catchCallback = function (error) {\n          _this.wrapFailure(catchFn, error).next(resolve, reject);\n        };\n      });\n    }\n  };\n\n  PersistencePromise.prototype.toPromise = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.next(resolve, reject);\n    });\n  };\n\n  PersistencePromise.prototype.wrapUserFunction = function (fn) {\n    try {\n      var result = fn();\n\n      if (result instanceof PersistencePromise) {\n        return result;\n      } else {\n        return PersistencePromise.resolve(result);\n      }\n    } catch (e) {\n      return PersistencePromise.reject(e);\n    }\n  };\n\n  PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {\n    if (nextFn) {\n      return this.wrapUserFunction(function () {\n        return nextFn(value);\n      });\n    } else {\n      // If there's no nextFn, then R must be the same as T but we\n      // can't express that in the type system.\n      return PersistencePromise.resolve(value);\n    }\n  };\n\n  PersistencePromise.prototype.wrapFailure = function (catchFn, error) {\n    if (catchFn) {\n      return this.wrapUserFunction(function () {\n        return catchFn(error);\n      });\n    } else {\n      return PersistencePromise.reject(error);\n    }\n  };\n\n  PersistencePromise.resolve = function (result) {\n    return new PersistencePromise(function (resolve, reject) {\n      resolve(result);\n    });\n  };\n\n  PersistencePromise.reject = function (error) {\n    return new PersistencePromise(function (resolve, reject) {\n      reject(error);\n    });\n  };\n\n  PersistencePromise.waitFor = function (all) {\n    return all.reduce(function (promise, nextPromise, idx) {\n      return promise.next(function () {\n        return nextPromise;\n      });\n    }, PersistencePromise.resolve());\n  };\n\n  PersistencePromise.map = function (all) {\n    var results = [];\n    var first = true; // initial is ignored, so we can cheat on the type.\n\n    var initial = PersistencePromise.resolve(null);\n    return all.reduce(function (promise, nextPromise) {\n      return promise.next(function (result) {\n        if (!first) {\n          results.push(result);\n        }\n\n        first = false;\n        return nextPromise;\n      });\n    }, initial).next(function (result) {\n      results.push(result);\n      return results;\n    });\n  };\n\n  return PersistencePromise;\n}();\n\nexport { PersistencePromise };","map":{"version":3,"sources":["../src/local/persistence_promise.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fail } from '../util/assert';\n\nexport type FulfilledHandler<T, R> =\n  | ((result: T) => R | PersistencePromise<R>)\n  | null;\nexport type RejectedHandler<R> =\n  | ((reason: any) => R | PersistencePromise<R>)\n  | null;\nexport type Resolver<T> = (value?: T) => void;\nexport type Rejector = (error: any) => void;\n\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nexport class PersistencePromise<T> {\n  // NOTE: next/catchCallback will always point to our own wrapper functions,\n  // not the user's raw next() or catch() callbacks.\n  private nextCallback: FulfilledHandler<T, any> = null;\n  private catchCallback: RejectedHandler<any> = null;\n\n  // When the operation resolves, we'll set result or error and mark isDone.\n  private result: T | undefined = undefined;\n  private error: any = null;\n  private isDone = false;\n\n  // Set to true when .then() or .catch() are called and prevents additional\n  // chaining.\n  private callbackAttached = false;\n\n  constructor(callback: (resolve: Resolver<T>, reject: Rejector) => void) {\n    callback(\n      value => {\n        this.isDone = true;\n        this.result = value;\n        if (this.nextCallback) {\n          // value should be defined unless T is Void, but we can't express\n          // that in the type system.\n          this.nextCallback(value!);\n        }\n      },\n      error => {\n        this.isDone = true;\n        this.error = error;\n        if (this.catchCallback) {\n          this.catchCallback(error);\n        }\n      }\n    );\n  }\n\n  catch<R>(\n    fn: (error: any) => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    return this.next(undefined, fn);\n  }\n\n  next<R>(\n    nextFn?: FulfilledHandler<T, R>,\n    catchFn?: RejectedHandler<R>\n  ): PersistencePromise<R> {\n    if (this.callbackAttached) {\n      fail('Called next() or catch() twice for PersistencePromise');\n    }\n    this.callbackAttached = true;\n    if (this.isDone) {\n      if (!this.error) {\n        return this.wrapSuccess(nextFn, this.result!);\n      } else {\n        return this.wrapFailure(catchFn, this.error);\n      }\n    } else {\n      return new PersistencePromise<R>((resolve, reject) => {\n        this.nextCallback = (value: T) => {\n          this.wrapSuccess(nextFn, value).next(resolve, reject);\n        };\n        this.catchCallback = (error: any) => {\n          this.wrapFailure(catchFn, error).next(resolve, reject);\n        };\n      });\n    }\n  }\n\n  toPromise(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.next(resolve, reject);\n    });\n  }\n\n  private wrapUserFunction<R>(\n    fn: () => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    try {\n      const result = fn();\n      if (result instanceof PersistencePromise) {\n        return result;\n      } else {\n        return PersistencePromise.resolve(result);\n      }\n    } catch (e) {\n      return PersistencePromise.reject<R>(e);\n    }\n  }\n\n  private wrapSuccess<R>(\n    nextFn: FulfilledHandler<T, R> | undefined,\n    value: T\n  ): PersistencePromise<R> {\n    if (nextFn) {\n      return this.wrapUserFunction(() => nextFn(value));\n    } else {\n      // If there's no nextFn, then R must be the same as T but we\n      // can't express that in the type system.\n      return PersistencePromise.resolve<R>(value as any);\n    }\n  }\n\n  private wrapFailure<R>(\n    catchFn: RejectedHandler<R> | undefined,\n    error: any\n  ): PersistencePromise<R> {\n    if (catchFn) {\n      return this.wrapUserFunction(() => catchFn(error));\n    } else {\n      return PersistencePromise.reject<R>(error);\n    }\n  }\n\n  static resolve(): PersistencePromise<void>;\n  static resolve<R>(result: R): PersistencePromise<R>;\n  static resolve<R>(result?: R): PersistencePromise<R | void> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      resolve(result);\n    });\n  }\n\n  static reject<R>(error: any): PersistencePromise<R> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  static waitFor(\n    all: Array<PersistencePromise<any>>\n  ): PersistencePromise<void> {\n    return all.reduce((promise, nextPromise, idx) => {\n      return promise.next(() => {\n        return nextPromise;\n      });\n    }, PersistencePromise.resolve());\n  }\n\n  static map<R>(all: Array<PersistencePromise<R>>): PersistencePromise<R[]> {\n    const results: R[] = [];\n    let first = true;\n    // initial is ignored, so we can cheat on the type.\n    const initial = PersistencePromise.resolve<R>(null as any);\n    return all\n      .reduce((promise, nextPromise) => {\n        return promise.next(result => {\n          if (!first) {\n            results.push(result);\n          }\n          first = false;\n          return nextPromise;\n        });\n      }, initial)\n      .next(result => {\n        results.push(result);\n        return results;\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}