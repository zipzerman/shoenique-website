{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetIdGenerator } from '../core/target_id_generator';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { BATCHID_UNKNOWN } from '../model/mutation_batch';\nimport { ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryData, QueryPurpose } from './query_data';\nimport { ReferenceSet } from './reference_set';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\nvar LOG_TAG = 'LocalStore';\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\n\nvar LocalStore =\n/** @class */\nfunction () {\n  function LocalStore(\n  /** Manages our in-memory or durable persistence. */\n  persistence, initialUser,\n  /**\n   * The garbage collector collects documents that should no longer be\n   * cached (e.g. if they are no longer retained by the above reference sets\n   * and the garbage collector is performing eager collection).\n   */\n  garbageCollector) {\n    this.persistence = persistence;\n    this.garbageCollector = garbageCollector;\n    /**\n     * The set of document references maintained by any local views.\n     */\n\n    this.localViewReferences = new ReferenceSet();\n    /** Maps a targetID to data about its query. */\n\n    this.targetIds = {};\n    /** Used to generate targetIDs for queries tracked locally. */\n\n    this.targetIdGenerator = TargetIdGenerator.forLocalStore();\n    /**\n     * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n     * that arrived before the watch stream got notified of a snapshot that\n     * includes the write.â€‚So we \"hold\" it until the watch stream catches up. It\n     * ensures that the local write remains visible (latency compensation) and\n     * doesn't temporarily appear reverted because the watch stream is slower than\n     * the write stream and so wasn't reflecting it.\n     *\n     * NOTE: Eventually we want to move this functionality into the remote store.\n     */\n\n    this.heldBatchResults = [];\n    this.mutationQueue = persistence.getMutationQueue(initialUser);\n    this.remoteDocuments = persistence.getRemoteDocumentCache();\n    this.queryCache = persistence.getQueryCache();\n    this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue);\n    this.garbageCollector.addGarbageSource(this.localViewReferences);\n    this.garbageCollector.addGarbageSource(this.queryCache);\n    this.garbageCollector.addGarbageSource(this.mutationQueue);\n  }\n  /** Performs any initial startup actions required by the local store. */\n\n\n  LocalStore.prototype.start = function () {\n    var _this = this;\n\n    return this.persistence.runTransaction('Start LocalStore', function (txn) {\n      return _this.startMutationQueue(txn).next(function () {\n        return _this.startQueryCache(txn);\n      });\n    });\n  };\n  /**\n   * Tells the LocalStore that the currently authenticated user has changed.\n   *\n   * In response the local store switches the mutation queue to the new user and\n   * returns any resulting document changes.\n   */\n\n\n  LocalStore.prototype.handleUserChange = function (user) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Handle user change', function (txn) {\n      // Swap out the mutation queue, grabbing the pending mutation batches\n      // before and after.\n      var oldBatches;\n      return _this.mutationQueue.getAllMutationBatches(txn).next(function (promisedOldBatches) {\n        oldBatches = promisedOldBatches;\n\n        _this.garbageCollector.removeGarbageSource(_this.mutationQueue);\n\n        _this.mutationQueue = _this.persistence.getMutationQueue(user);\n\n        _this.garbageCollector.addGarbageSource(_this.mutationQueue);\n\n        return _this.startMutationQueue(txn);\n      }).next(function () {\n        // Recreate our LocalDocumentsView using the new\n        // MutationQueue.\n        _this.localDocuments = new LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);\n        return _this.mutationQueue.getAllMutationBatches(txn);\n      }).next(function (newBatches) {\n        // Union the old/new changed keys.\n        var changedKeys = documentKeySet();\n\n        for (var _i = 0, _a = [oldBatches, newBatches]; _i < _a.length; _i++) {\n          var batches = _a[_i];\n\n          for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {\n            var batch = batches_1[_b];\n\n            for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {\n              var mutation = _d[_c];\n              changedKeys = changedKeys.add(mutation.key);\n            }\n          }\n        } // Return the set of all (potentially) changed documents as the\n        // result of the user change.\n\n\n        return _this.localDocuments.getDocuments(txn, changedKeys);\n      });\n    });\n  };\n\n  LocalStore.prototype.startQueryCache = function (txn) {\n    var _this = this;\n\n    return this.queryCache.start(txn).next(function () {\n      var targetId = _this.queryCache.getHighestTargetId();\n\n      _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n    });\n  };\n\n  LocalStore.prototype.startMutationQueue = function (txn) {\n    var _this = this;\n\n    return this.mutationQueue.start(txn).next(function () {\n      // If we have any leftover mutation batch results from a prior run,\n      // just drop them.\n      // TODO(http://b/33446471): We probably need to repopulate\n      // heldBatchResults or similar instead, but that is not\n      // straightforward since we're not persisting the write ack versions.\n      _this.heldBatchResults = [];\n      return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n    }).next(function (highestAck) {\n      // TODO(mikelehen): This is the only usage of\n      // getAllMutationBatchesThroughBatchId(). Consider removing it in\n      // favor of a getAcknowledgedBatches() method.\n      if (highestAck !== BATCHID_UNKNOWN) {\n        return _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck);\n      } else {\n        return PersistencePromise.resolve([]);\n      }\n    }).next(function (ackedBatches) {\n      if (ackedBatches.length > 0) {\n        return _this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n      } else {\n        return PersistencePromise.resolve();\n      }\n    });\n  };\n  /* Accept locally generated Mutations and commit them to storage. */\n\n\n  LocalStore.prototype.localWrite = function (mutations) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Locally write mutations', function (txn) {\n      var batch;\n      var localWriteTime = Timestamp.now();\n      return _this.mutationQueue.addMutationBatch(txn, localWriteTime, mutations).next(function (promisedBatch) {\n        batch = promisedBatch; // TODO(koss): This is doing an N^2 update by replaying ALL the\n        // mutations on each document (instead of just the ones added) in\n        // this batch.\n\n        var keys = batch.keys();\n        return _this.localDocuments.getDocuments(txn, keys);\n      }).next(function (changedDocuments) {\n        return {\n          batchId: batch.batchId,\n          changes: changedDocuments\n        };\n      });\n    });\n  };\n  /**\n   * Acknowledge the given batch.\n   *\n   * On the happy path when a batch is acknowledged, the local store will\n   *\n   *  + remove the batch from the mutation queue;\n   *  + apply the changes to the remote document cache;\n   *  + recalculate the latency compensated view implied by those changes (there\n   *    may be mutations in the queue that affect the documents but haven't been\n   *    acknowledged yet); and\n   *  + give the changed documents back the sync engine\n   *\n   * @returns The resulting (modified) documents.\n   */\n\n\n  LocalStore.prototype.acknowledgeBatch = function (batchResult) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Acknowledge batch', function (txn) {\n      var affected;\n      return _this.mutationQueue.acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken).next(function () {\n        if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {\n          _this.heldBatchResults.push(batchResult);\n\n          affected = documentKeySet();\n          return PersistencePromise.resolve();\n        } else {\n          var documentBuffer_1 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);\n          return _this.releaseBatchResults(txn, [batchResult], documentBuffer_1).next(function (promisedAffectedKeys) {\n            affected = promisedAffectedKeys;\n            return documentBuffer_1.apply(txn);\n          });\n        }\n      }).next(function () {\n        return _this.mutationQueue.performConsistencyCheck(txn);\n      }).next(function () {\n        return _this.localDocuments.getDocuments(txn, affected);\n      });\n    });\n  };\n  /**\n   * Remove mutations from the MutationQueue for the specified batch;\n   * LocalDocuments will be recalculated.\n   *\n   * @returns The resulting modified documents.\n   */\n\n\n  LocalStore.prototype.rejectBatch = function (batchId) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Reject batch', function (txn) {\n      var toReject;\n      var affectedKeys;\n      return _this.mutationQueue.lookupMutationBatch(txn, batchId).next(function (promisedToReject) {\n        assert(promisedToReject != null, 'Attempt to reject nonexistent batch!');\n        toReject = promisedToReject;\n        return _this.mutationQueue.getHighestAcknowledgedBatchId(txn).next(function (lastAcked) {\n          assert(batchId > lastAcked, \"Acknowledged batches can't be rejected.\");\n          return toReject;\n        });\n      }).next(function () {\n        return _this.removeMutationBatch(txn, toReject);\n      }).next(function (promisedAffectedKeys) {\n        affectedKeys = promisedAffectedKeys;\n        return _this.mutationQueue.performConsistencyCheck(txn);\n      }).next(function () {\n        return _this.localDocuments.getDocuments(txn, affectedKeys);\n      });\n    });\n  };\n  /** Returns the last recorded stream token for the current user. */\n\n\n  LocalStore.prototype.getLastStreamToken = function () {\n    var _this = this;\n\n    return this.persistence.runTransaction('Get last stream token', function (txn) {\n      return _this.mutationQueue.getLastStreamToken(txn);\n    });\n  };\n  /**\n   * Sets the stream token for the current user without acknowledging any\n   * mutation batch. This is usually only useful after a stream handshake or in\n   * response to an error that requires clearing the stream token.\n   */\n\n\n  LocalStore.prototype.setLastStreamToken = function (streamToken) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Set last stream token', function (txn) {\n      return _this.mutationQueue.setLastStreamToken(txn, streamToken);\n    });\n  };\n  /**\n   * Returns the last consistent snapshot processed (used by the RemoteStore to\n   * determine whether to buffer incoming snapshots from the backend).\n   */\n\n\n  LocalStore.prototype.getLastRemoteSnapshotVersion = function () {\n    return this.queryCache.getLastRemoteSnapshotVersion();\n  };\n  /**\n   * Update the \"ground-state\" (remote) documents. We assume that the remote\n   * event reflects any write batches that have been acknowledged or rejected\n   * (i.e. we do not re-apply local mutations to updates from this event).\n   *\n   * LocalDocuments are re-calculated if there are remaining mutations in the\n   * queue.\n   */\n\n\n  LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {\n    var _this = this;\n\n    var documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);\n    return this.persistence.runTransaction('Apply remote event', function (txn) {\n      var promises = [];\n      objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n        // Do not ref/unref unassigned targetIds - it may lead to leaks.\n        var queryData = _this.targetIds[targetId];\n        if (!queryData) return;\n        var mapping = change.mapping;\n\n        if (mapping) {\n          // First make sure that all references are deleted\n          if (mapping instanceof ResetMapping) {\n            promises.push(_this.queryCache.removeMatchingKeysForTargetId(txn, targetId).next(function () {\n              return _this.queryCache.addMatchingKeys(txn, mapping.documents, targetId);\n            }));\n          } else if (mapping instanceof UpdateMapping) {\n            promises.push(_this.queryCache.removeMatchingKeys(txn, mapping.removedDocuments, targetId).next(function () {\n              return _this.queryCache.addMatchingKeys(txn, mapping.addedDocuments, targetId);\n            }));\n          } else {\n            return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n          }\n        } // Update the resume token if the change includes one. Don't clear\n        // any preexisting value.\n\n\n        var resumeToken = change.resumeToken;\n\n        if (resumeToken.length > 0) {\n          queryData = queryData.update({\n            resumeToken: resumeToken,\n            snapshotVersion: change.snapshotVersion\n          });\n          _this.targetIds[targetId] = queryData;\n          promises.push(_this.queryCache.addQueryData(txn, queryData));\n        }\n      });\n      var changedDocKeys = documentKeySet();\n      remoteEvent.documentUpdates.forEach(function (key, doc) {\n        changedDocKeys = changedDocKeys.add(key);\n        promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {\n          // Make sure we don't apply an old document version to the remote\n          // cache, though we make an exception for SnapshotVersion.MIN which\n          // can happen for manufactured events (e.g. in the case of a limbo\n          // document resolution failing).\n          if (existingDoc == null || doc.version.equals(SnapshotVersion.MIN) || doc.version.compareTo(existingDoc.version) >= 0) {\n            documentBuffer.addEntry(doc);\n          } else {\n            log.debug(LOG_TAG, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n          } // The document might be garbage because it was unreferenced by\n          // everything. Make sure to mark it as garbage if it is...\n\n\n          _this.garbageCollector.addPotentialGarbageKey(key);\n        }));\n      }); // HACK: The only reason we allow a null snapshot version is so that we\n      // can synthesize remote events when we get permission denied errors while\n      // trying to resolve the state of a locally cached document that is in\n      // limbo.\n\n      var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();\n\n      var remoteVersion = remoteEvent.snapshotVersion;\n\n      if (!remoteVersion.equals(SnapshotVersion.MIN)) {\n        assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' + remoteVersion + ' < ' + lastRemoteVersion);\n        promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));\n      }\n\n      var releasedWriteKeys;\n      return PersistencePromise.waitFor(promises).next(function () {\n        return _this.releaseHeldBatchResults(txn, documentBuffer);\n      }).next(function (promisedReleasedWriteKeys) {\n        releasedWriteKeys = promisedReleasedWriteKeys;\n        return documentBuffer.apply(txn);\n      }).next(function () {\n        return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));\n      });\n    });\n  };\n  /**\n   * Notify local store of the changed views to locally pin documents.\n   */\n\n\n  LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Notify local view changes', function (txn) {\n      var promises = [];\n\n      var _loop_1 = function _loop_1(view) {\n        promises.push(_this.queryCache.getQueryData(txn, view.query).next(function (queryData) {\n          assert(queryData !== null, 'Local view changes contain unallocated query.');\n          var targetId = queryData.targetId;\n\n          _this.localViewReferences.addReferences(view.addedKeys, targetId);\n\n          _this.localViewReferences.removeReferences(view.removedKeys, targetId);\n        }));\n      };\n\n      for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {\n        var view = viewChanges_1[_i];\n\n        _loop_1(view);\n      }\n\n      return PersistencePromise.waitFor(promises);\n    });\n  };\n  /**\n   * Gets the mutation batch after the passed in batchId in the mutation queue\n   * or null if empty.\n   * @param afterBatchId If provided, the batch to search after.\n   * @returns The next mutation or null if there wasn't one.\n   */\n\n\n  LocalStore.prototype.nextMutationBatch = function (afterBatchId) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Get next mutation batch', function (txn) {\n      if (afterBatchId === undefined) {\n        afterBatchId = BATCHID_UNKNOWN;\n      }\n\n      return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n    });\n  };\n  /**\n   * Read the current value of a Document with a given key or null if not\n   * found - used for testing.\n   */\n\n\n  LocalStore.prototype.readDocument = function (key) {\n    var _this = this;\n\n    return this.persistence.runTransaction('read document', function (txn) {\n      return _this.localDocuments.getDocument(txn, key);\n    });\n  };\n  /**\n   * Assigns the given query an internal ID so that its results can be pinned so\n   * they don't get GC'd. A query must be allocated in the local store before\n   * the store can be used to manage its view.\n   */\n\n\n  LocalStore.prototype.allocateQuery = function (query) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Allocate query', function (txn) {\n      var queryData;\n      return _this.queryCache.getQueryData(txn, query).next(function (cached) {\n        if (cached) {\n          // This query has been listened to previously, so reuse the\n          // previous targetID.\n          // TODO(mcg): freshen last accessed date?\n          queryData = cached;\n          return PersistencePromise.resolve();\n        } else {\n          var targetId = _this.targetIdGenerator.next();\n\n          queryData = new QueryData(query, targetId, QueryPurpose.Listen);\n          return _this.queryCache.addQueryData(txn, queryData);\n        }\n      }).next(function () {\n        assert(!_this.targetIds[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);\n        _this.targetIds[queryData.targetId] = queryData;\n        return queryData;\n      });\n    });\n  };\n  /** Unpin all the documents associated with the given query. */\n\n\n  LocalStore.prototype.releaseQuery = function (query) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Release query', function (txn) {\n      return _this.queryCache.getQueryData(txn, query).next(function (queryData) {\n        assert(queryData != null, 'Tried to release nonexistent query: ' + query);\n\n        _this.localViewReferences.removeReferencesForId(queryData.targetId);\n\n        delete _this.targetIds[queryData.targetId];\n\n        if (_this.garbageCollector.isEager) {\n          return _this.queryCache.removeQueryData(txn, queryData);\n        } else {\n          return PersistencePromise.resolve();\n        }\n      }).next(function () {\n        // If this was the last watch target, then we won't get any more\n        // watch snapshots, so we should release any held batch results.\n        if (objUtils.isEmpty(_this.targetIds)) {\n          var documentBuffer_2 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);\n          return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function () {\n            documentBuffer_2.apply(txn);\n          });\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n    });\n  };\n  /**\n   * Runs the specified query against all the documents in the local store and\n   * returns the results.\n   */\n\n\n  LocalStore.prototype.executeQuery = function (query) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Execute query', function (txn) {\n      return _this.localDocuments.getDocumentsMatchingQuery(txn, query);\n    });\n  };\n  /**\n   * Returns the keys of the documents that are associated with the given\n   * target id in the remote table.\n   */\n\n\n  LocalStore.prototype.remoteDocumentKeys = function (targetId) {\n    var _this = this;\n\n    return this.persistence.runTransaction('Remote document keys', function (txn) {\n      return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n    });\n  };\n  /**\n   * Collect garbage if necessary.\n   * Should be called periodically by Sync Engine to recover resources. The\n   * implementation must guarantee that GC won't happen in other places than\n   * this method call.\n   */\n\n\n  LocalStore.prototype.collectGarbage = function () {\n    var _this = this; // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n    // doesn't continue to accumulate the garbage keys.\n\n\n    return this.persistence.runTransaction('Garbage collection', function (txn) {\n      return _this.garbageCollector.collectGarbage(txn).next(function (garbage) {\n        var promises = [];\n        garbage.forEach(function (key) {\n          promises.push(_this.remoteDocuments.removeEntry(txn, key));\n        });\n        return PersistencePromise.waitFor(promises);\n      });\n    });\n  };\n\n  LocalStore.prototype.releaseHeldBatchResults = function (txn, documentBuffer) {\n    var toRelease = [];\n\n    for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {\n      var batchResult = _a[_i];\n\n      if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n        break;\n      }\n\n      toRelease.push(batchResult);\n    }\n\n    if (toRelease.length === 0) {\n      return PersistencePromise.resolve(documentKeySet());\n    } else {\n      this.heldBatchResults.splice(0, toRelease.length);\n      return this.releaseBatchResults(txn, toRelease, documentBuffer);\n    }\n  };\n\n  LocalStore.prototype.isRemoteUpToVersion = function (version) {\n    // If there are no watch targets, then we won't get remote snapshots, and\n    // we are always \"up-to-date.\"\n    var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n    return version.compareTo(lastRemoteVersion) <= 0 || objUtils.isEmpty(this.targetIds);\n  };\n\n  LocalStore.prototype.shouldHoldBatchResult = function (version) {\n    // Check if watcher isn't up to date or prior results are already held.\n    return !this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0;\n  };\n\n  LocalStore.prototype.releaseBatchResults = function (txn, batchResults, documentBuffer) {\n    var _this = this;\n\n    var promiseChain = PersistencePromise.resolve();\n\n    var _loop_2 = function _loop_2(batchResult) {\n      promiseChain = promiseChain.next(function () {\n        return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);\n      });\n    };\n\n    for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {\n      var batchResult = batchResults_1[_i];\n\n      _loop_2(batchResult);\n    }\n\n    return promiseChain.next(function () {\n      return _this.removeMutationBatches(txn, batchResults.map(function (result) {\n        return result.batch;\n      }));\n    });\n  };\n\n  LocalStore.prototype.removeMutationBatch = function (txn, batch) {\n    return this.removeMutationBatches(txn, [batch]);\n  };\n  /** Removes all the mutation batches named in the given array. */\n\n\n  LocalStore.prototype.removeMutationBatches = function (txn, batches) {\n    var affectedDocs = documentKeySet();\n\n    for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {\n      var batch = batches_2[_i];\n\n      for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n        var mutation = _b[_a];\n        var key = mutation.key;\n        affectedDocs = affectedDocs.add(key);\n      }\n    }\n\n    return this.mutationQueue.removeMutationBatches(txn, batches).next(function () {\n      return affectedDocs;\n    });\n  };\n\n  LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {\n    var batch = batchResult.batch;\n    var docKeys = batch.keys();\n    var promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(function (docKey) {\n      promiseChain = promiseChain.next(function () {\n        return documentBuffer.getEntry(txn, docKey);\n      }).next(function (remoteDoc) {\n        var doc = remoteDoc;\n        var ackVersion = batchResult.docVersions.get(docKey);\n        assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');\n\n        if (!doc || doc.version.compareTo(ackVersion) < 0) {\n          doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n\n          if (!doc) {\n            assert(!remoteDoc, 'Mutation batch ' + batch + ' applied to document ' + remoteDoc + ' resulted in null');\n          } else {\n            documentBuffer.addEntry(doc);\n          }\n        }\n      });\n    });\n    return promiseChain;\n  };\n\n  return LocalStore;\n}();\n\nexport { LocalStore };","map":{"version":3,"sources":["../src/local/local_store.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetIdGenerator } from '../core/target_id_generator';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString, TargetId } from '../core/types';\nimport {\n  DocumentKeySet,\n  documentKeySet,\n  DocumentMap,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport {\n  RemoteEvent,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { LocalViewChanges } from './local_view_changes';\nimport { MutationQueue } from './mutation_queue';\nimport { Persistence, PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData, QueryPurpose } from './query_data';\nimport { ReferenceSet } from './reference_set';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\n\nconst LOG_TAG = 'LocalStore';\n\n/** The result of a write to the local store. */\nexport interface LocalWriteResult {\n  batchId: BatchId;\n  changes: MaybeDocumentMap;\n}\n\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nexport class LocalStore {\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  private mutationQueue: MutationQueue;\n\n  /** The set of all cached remote documents. */\n  private remoteDocuments: RemoteDocumentCache;\n\n  /**\n   * The \"local\" view of all documents (layering mutationQueue on top of\n   * remoteDocumentCache).\n   */\n  private localDocuments: LocalDocumentsView;\n\n  /**\n   * The set of document references maintained by any local views.\n   */\n  private localViewReferences = new ReferenceSet();\n\n  /** Maps a query to the data about that query. */\n  private queryCache: QueryCache;\n\n  /** Maps a targetID to data about its query. */\n  private targetIds = {} as { [targetId: number]: QueryData };\n\n  /** Used to generate targetIDs for queries tracked locally. */\n  private targetIdGenerator = TargetIdGenerator.forLocalStore();\n\n  /**\n   * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n   * that arrived before the watch stream got notified of a snapshot that\n   * includes the write.â€‚So we \"hold\" it until the watch stream catches up. It\n   * ensures that the local write remains visible (latency compensation) and\n   * doesn't temporarily appear reverted because the watch stream is slower than\n   * the write stream and so wasn't reflecting it.\n   *\n   * NOTE: Eventually we want to move this functionality into the remote store.\n   */\n  private heldBatchResults: MutationBatchResult[] = [];\n\n  constructor(\n    /** Manages our in-memory or durable persistence. */\n    private persistence: Persistence,\n    initialUser: User,\n    /**\n     * The garbage collector collects documents that should no longer be\n     * cached (e.g. if they are no longer retained by the above reference sets\n     * and the garbage collector is performing eager collection).\n     */\n    private garbageCollector: GarbageCollector\n  ) {\n    this.mutationQueue = persistence.getMutationQueue(initialUser);\n    this.remoteDocuments = persistence.getRemoteDocumentCache();\n    this.queryCache = persistence.getQueryCache();\n    this.localDocuments = new LocalDocumentsView(\n      this.remoteDocuments,\n      this.mutationQueue\n    );\n    this.garbageCollector.addGarbageSource(this.localViewReferences);\n    this.garbageCollector.addGarbageSource(this.queryCache);\n    this.garbageCollector.addGarbageSource(this.mutationQueue);\n  }\n\n  /** Performs any initial startup actions required by the local store. */\n  start(): Promise<void> {\n    return this.persistence.runTransaction('Start LocalStore', txn => {\n      return this.startMutationQueue(txn).next(() => this.startQueryCache(txn));\n    });\n  }\n\n  /**\n   * Tells the LocalStore that the currently authenticated user has changed.\n   *\n   * In response the local store switches the mutation queue to the new user and\n   * returns any resulting document changes.\n   */\n  handleUserChange(user: User): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction('Handle user change', txn => {\n      // Swap out the mutation queue, grabbing the pending mutation batches\n      // before and after.\n      let oldBatches: MutationBatch[];\n      return this.mutationQueue\n        .getAllMutationBatches(txn)\n        .next(promisedOldBatches => {\n          oldBatches = promisedOldBatches;\n\n          this.garbageCollector.removeGarbageSource(this.mutationQueue);\n          this.mutationQueue = this.persistence.getMutationQueue(user);\n          this.garbageCollector.addGarbageSource(this.mutationQueue);\n          return this.startMutationQueue(txn);\n        })\n        .next(() => {\n          // Recreate our LocalDocumentsView using the new\n          // MutationQueue.\n          this.localDocuments = new LocalDocumentsView(\n            this.remoteDocuments,\n            this.mutationQueue\n          );\n          return this.mutationQueue.getAllMutationBatches(txn);\n        })\n        .next(newBatches => {\n          // Union the old/new changed keys.\n          let changedKeys = documentKeySet();\n          for (const batches of [oldBatches, newBatches]) {\n            for (const batch of batches) {\n              for (const mutation of batch.mutations) {\n                changedKeys = changedKeys.add(mutation.key);\n              }\n            }\n          }\n\n          // Return the set of all (potentially) changed documents as the\n          // result of the user change.\n          return this.localDocuments.getDocuments(txn, changedKeys);\n        });\n    });\n  }\n\n  private startQueryCache(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.queryCache.start(txn).next(() => {\n      const targetId = this.queryCache.getHighestTargetId();\n      this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n    });\n  }\n\n  private startMutationQueue(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.mutationQueue\n      .start(txn)\n      .next(() => {\n        // If we have any leftover mutation batch results from a prior run,\n        // just drop them.\n        // TODO(http://b/33446471): We probably need to repopulate\n        // heldBatchResults or similar instead, but that is not\n        // straightforward since we're not persisting the write ack versions.\n        this.heldBatchResults = [];\n        return this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n      })\n      .next(highestAck => {\n        // TODO(mikelehen): This is the only usage of\n        // getAllMutationBatchesThroughBatchId(). Consider removing it in\n        // favor of a getAcknowledgedBatches() method.\n        if (highestAck !== BATCHID_UNKNOWN) {\n          return this.mutationQueue.getAllMutationBatchesThroughBatchId(\n            txn,\n            highestAck\n          );\n        } else {\n          return PersistencePromise.resolve([]);\n        }\n      })\n      .next(ackedBatches => {\n        if (ackedBatches.length > 0) {\n          return this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n  }\n\n  /* Accept locally generated Mutations and commit them to storage. */\n  localWrite(mutations: Mutation[]): Promise<LocalWriteResult> {\n    return this.persistence.runTransaction('Locally write mutations', txn => {\n      let batch: MutationBatch;\n      const localWriteTime = Timestamp.now();\n      return this.mutationQueue\n        .addMutationBatch(txn, localWriteTime, mutations)\n        .next(promisedBatch => {\n          batch = promisedBatch;\n          // TODO(koss): This is doing an N^2 update by replaying ALL the\n          // mutations on each document (instead of just the ones added) in\n          // this batch.\n          const keys = batch.keys();\n          return this.localDocuments.getDocuments(txn, keys);\n        })\n        .next((changedDocuments: MaybeDocumentMap) => {\n          return { batchId: batch.batchId, changes: changedDocuments };\n        });\n    });\n  }\n\n  /**\n   * Acknowledge the given batch.\n   *\n   * On the happy path when a batch is acknowledged, the local store will\n   *\n   *  + remove the batch from the mutation queue;\n   *  + apply the changes to the remote document cache;\n   *  + recalculate the latency compensated view implied by those changes (there\n   *    may be mutations in the queue that affect the documents but haven't been\n   *    acknowledged yet); and\n   *  + give the changed documents back the sync engine\n   *\n   * @returns The resulting (modified) documents.\n   */\n  acknowledgeBatch(\n    batchResult: MutationBatchResult\n  ): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction('Acknowledge batch', txn => {\n      let affected: DocumentKeySet;\n      return this.mutationQueue\n        .acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken)\n        .next(() => {\n          if (this.shouldHoldBatchResult(batchResult.commitVersion)) {\n            this.heldBatchResults.push(batchResult);\n            affected = documentKeySet();\n            return PersistencePromise.resolve();\n          } else {\n            const documentBuffer = new RemoteDocumentChangeBuffer(\n              this.remoteDocuments\n            );\n            return this.releaseBatchResults(\n              txn,\n              [batchResult],\n              documentBuffer\n            ).next(promisedAffectedKeys => {\n              affected = promisedAffectedKeys;\n              return documentBuffer.apply(txn);\n            });\n          }\n        })\n        .next(() => {\n          return this.mutationQueue.performConsistencyCheck(txn);\n        })\n        .next(() => {\n          return this.localDocuments.getDocuments(txn, affected);\n        });\n    });\n  }\n\n  /**\n   * Remove mutations from the MutationQueue for the specified batch;\n   * LocalDocuments will be recalculated.\n   *\n   * @returns The resulting modified documents.\n   */\n  rejectBatch(batchId: BatchId): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction('Reject batch', txn => {\n      let toReject: MutationBatch;\n      let affectedKeys: DocumentKeySet;\n      return this.mutationQueue\n        .lookupMutationBatch(txn, batchId)\n        .next((promisedToReject: MutationBatch | null) => {\n          assert(\n            promisedToReject != null,\n            'Attempt to reject nonexistent batch!'\n          );\n          toReject = promisedToReject!;\n\n          return this.mutationQueue\n            .getHighestAcknowledgedBatchId(txn)\n            .next(lastAcked => {\n              assert(\n                batchId > lastAcked,\n                \"Acknowledged batches can't be rejected.\"\n              );\n              return toReject;\n            });\n        })\n        .next(() => {\n          return this.removeMutationBatch(txn, toReject);\n        })\n        .next(promisedAffectedKeys => {\n          affectedKeys = promisedAffectedKeys;\n          return this.mutationQueue.performConsistencyCheck(txn);\n        })\n        .next(() => {\n          return this.localDocuments.getDocuments(txn, affectedKeys);\n        });\n    });\n  }\n\n  /** Returns the last recorded stream token for the current user. */\n  getLastStreamToken(): Promise<ProtoByteString> {\n    return this.persistence.runTransaction('Get last stream token', txn => {\n      return this.mutationQueue.getLastStreamToken(txn);\n    });\n  }\n\n  /**\n   * Sets the stream token for the current user without acknowledging any\n   * mutation batch. This is usually only useful after a stream handshake or in\n   * response to an error that requires clearing the stream token.\n   */\n  setLastStreamToken(streamToken: ProtoByteString): Promise<void> {\n    return this.persistence.runTransaction('Set last stream token', txn => {\n      return this.mutationQueue.setLastStreamToken(txn, streamToken);\n    });\n  }\n\n  /**\n   * Returns the last consistent snapshot processed (used by the RemoteStore to\n   * determine whether to buffer incoming snapshots from the backend).\n   */\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.queryCache.getLastRemoteSnapshotVersion();\n  }\n\n  /**\n   * Update the \"ground-state\" (remote) documents. We assume that the remote\n   * event reflects any write batches that have been acknowledged or rejected\n   * (i.e. we do not re-apply local mutations to updates from this event).\n   *\n   * LocalDocuments are re-calculated if there are remaining mutations in the\n   * queue.\n   */\n  applyRemoteEvent(remoteEvent: RemoteEvent): Promise<MaybeDocumentMap> {\n    const documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);\n    return this.persistence.runTransaction('Apply remote event', txn => {\n      const promises = [] as Array<PersistencePromise<void>>;\n      objUtils.forEachNumber(\n        remoteEvent.targetChanges,\n        (targetId: TargetId, change: TargetChange) => {\n          // Do not ref/unref unassigned targetIds - it may lead to leaks.\n          let queryData = this.targetIds[targetId];\n          if (!queryData) return;\n\n          const mapping: UpdateMapping | ResetMapping = change.mapping;\n          if (mapping) {\n            // First make sure that all references are deleted\n            if (mapping instanceof ResetMapping) {\n              promises.push(\n                this.queryCache\n                  .removeMatchingKeysForTargetId(txn, targetId)\n                  .next(() => {\n                    return this.queryCache.addMatchingKeys(\n                      txn,\n                      mapping.documents,\n                      targetId\n                    );\n                  })\n              );\n            } else if (mapping instanceof UpdateMapping) {\n              promises.push(\n                this.queryCache\n                  .removeMatchingKeys(txn, mapping.removedDocuments, targetId)\n                  .next(() => {\n                    return this.queryCache.addMatchingKeys(\n                      txn,\n                      mapping.addedDocuments,\n                      targetId\n                    );\n                  })\n              );\n            } else {\n              return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n            }\n          }\n\n          // Update the resume token if the change includes one. Don't clear\n          // any preexisting value.\n          const resumeToken = change.resumeToken;\n          if (resumeToken.length > 0) {\n            queryData = queryData.update({\n              resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n            this.targetIds[targetId] = queryData;\n            promises.push(this.queryCache.addQueryData(txn, queryData));\n          }\n        }\n      );\n\n      let changedDocKeys = documentKeySet();\n      remoteEvent.documentUpdates.forEach((key, doc) => {\n        changedDocKeys = changedDocKeys.add(key);\n        promises.push(\n          documentBuffer.getEntry(txn, key).next(existingDoc => {\n            // Make sure we don't apply an old document version to the remote\n            // cache, though we make an exception for SnapshotVersion.MIN which\n            // can happen for manufactured events (e.g. in the case of a limbo\n            // document resolution failing).\n            if (\n              existingDoc == null ||\n              doc.version.equals(SnapshotVersion.MIN) ||\n              doc.version.compareTo(existingDoc.version) >= 0\n            ) {\n              documentBuffer.addEntry(doc);\n            } else {\n              log.debug(\n                LOG_TAG,\n                'Ignoring outdated watch update for ',\n                key,\n                '. Current version:',\n                existingDoc.version,\n                ' Watch version:',\n                doc.version\n              );\n            }\n\n            // The document might be garbage because it was unreferenced by\n            // everything. Make sure to mark it as garbage if it is...\n            this.garbageCollector.addPotentialGarbageKey(key);\n          })\n        );\n      });\n\n      // HACK: The only reason we allow a null snapshot version is so that we\n      // can synthesize remote events when we get permission denied errors while\n      // trying to resolve the state of a locally cached document that is in\n      // limbo.\n      const lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n      const remoteVersion = remoteEvent.snapshotVersion;\n      if (!remoteVersion.equals(SnapshotVersion.MIN)) {\n        assert(\n          remoteVersion.compareTo(lastRemoteVersion) >= 0,\n          'Watch stream reverted to previous snapshot?? ' +\n            remoteVersion +\n            ' < ' +\n            lastRemoteVersion\n        );\n        promises.push(\n          this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion)\n        );\n      }\n\n      let releasedWriteKeys: DocumentKeySet;\n      return PersistencePromise.waitFor(promises)\n        .next(() => this.releaseHeldBatchResults(txn, documentBuffer))\n        .next(promisedReleasedWriteKeys => {\n          releasedWriteKeys = promisedReleasedWriteKeys;\n          return documentBuffer.apply(txn);\n        })\n        .next(() => {\n          return this.localDocuments.getDocuments(\n            txn,\n            changedDocKeys.unionWith(releasedWriteKeys)\n          );\n        });\n    });\n  }\n\n  /**\n   * Notify local store of the changed views to locally pin documents.\n   */\n  notifyLocalViewChanges(viewChanges: LocalViewChanges[]): Promise<void> {\n    return this.persistence.runTransaction('Notify local view changes', txn => {\n      const promises = [] as Array<PersistencePromise<void>>;\n      for (const view of viewChanges) {\n        promises.push(\n          this.queryCache\n            .getQueryData(txn, view.query)\n            .next((queryData: QueryData | null) => {\n              assert(\n                queryData !== null,\n                'Local view changes contain unallocated query.'\n              );\n              const targetId = queryData!.targetId;\n              this.localViewReferences.addReferences(view.addedKeys, targetId);\n              this.localViewReferences.removeReferences(\n                view.removedKeys,\n                targetId\n              );\n            })\n        );\n      }\n      return PersistencePromise.waitFor(promises);\n    });\n  }\n\n  /**\n   * Gets the mutation batch after the passed in batchId in the mutation queue\n   * or null if empty.\n   * @param afterBatchId If provided, the batch to search after.\n   * @returns The next mutation or null if there wasn't one.\n   */\n  nextMutationBatch(afterBatchId?: BatchId): Promise<MutationBatch | null> {\n    return this.persistence.runTransaction('Get next mutation batch', txn => {\n      if (afterBatchId === undefined) {\n        afterBatchId = BATCHID_UNKNOWN;\n      }\n      return this.mutationQueue.getNextMutationBatchAfterBatchId(\n        txn,\n        afterBatchId\n      );\n    });\n  }\n\n  /**\n   * Read the current value of a Document with a given key or null if not\n   * found - used for testing.\n   */\n  readDocument(key: DocumentKey): Promise<MaybeDocument | null> {\n    return this.persistence.runTransaction('read document', txn => {\n      return this.localDocuments.getDocument(txn, key);\n    });\n  }\n\n  /**\n   * Assigns the given query an internal ID so that its results can be pinned so\n   * they don't get GC'd. A query must be allocated in the local store before\n   * the store can be used to manage its view.\n   */\n  allocateQuery(query: Query): Promise<QueryData> {\n    return this.persistence.runTransaction('Allocate query', txn => {\n      let queryData: QueryData;\n      return this.queryCache\n        .getQueryData(txn, query)\n        .next((cached: QueryData | null) => {\n          if (cached) {\n            // This query has been listened to previously, so reuse the\n            // previous targetID.\n            // TODO(mcg): freshen last accessed date?\n            queryData = cached;\n            return PersistencePromise.resolve();\n          } else {\n            const targetId = this.targetIdGenerator.next();\n            queryData = new QueryData(query, targetId, QueryPurpose.Listen);\n            return this.queryCache.addQueryData(txn, queryData);\n          }\n        })\n        .next(() => {\n          assert(\n            !this.targetIds[queryData.targetId],\n            'Tried to allocate an already allocated query: ' + query\n          );\n          this.targetIds[queryData.targetId] = queryData;\n          return queryData;\n        });\n    });\n  }\n\n  /** Unpin all the documents associated with the given query. */\n  releaseQuery(query: Query): Promise<void> {\n    return this.persistence.runTransaction('Release query', txn => {\n      return this.queryCache\n        .getQueryData(txn, query)\n        .next((queryData: QueryData | null) => {\n          assert(\n            queryData != null,\n            'Tried to release nonexistent query: ' + query\n          );\n          this.localViewReferences.removeReferencesForId(queryData!.targetId);\n          delete this.targetIds[queryData!.targetId];\n          if (this.garbageCollector.isEager) {\n            return this.queryCache.removeQueryData(txn, queryData!);\n          } else {\n            return PersistencePromise.resolve();\n          }\n        })\n        .next(() => {\n          // If this was the last watch target, then we won't get any more\n          // watch snapshots, so we should release any held batch results.\n          if (objUtils.isEmpty(this.targetIds)) {\n            const documentBuffer = new RemoteDocumentChangeBuffer(\n              this.remoteDocuments\n            );\n            return this.releaseHeldBatchResults(txn, documentBuffer).next(\n              () => {\n                documentBuffer.apply(txn);\n              }\n            );\n          } else {\n            return PersistencePromise.resolve();\n          }\n        });\n    });\n  }\n\n  /**\n   * Runs the specified query against all the documents in the local store and\n   * returns the results.\n   */\n  executeQuery(query: Query): Promise<DocumentMap> {\n    return this.persistence.runTransaction('Execute query', txn => {\n      return this.localDocuments.getDocumentsMatchingQuery(txn, query);\n    });\n  }\n\n  /**\n   * Returns the keys of the documents that are associated with the given\n   * target id in the remote table.\n   */\n  remoteDocumentKeys(targetId: TargetId): Promise<DocumentKeySet> {\n    return this.persistence.runTransaction('Remote document keys', txn => {\n      return this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n    });\n  }\n\n  /**\n   * Collect garbage if necessary.\n   * Should be called periodically by Sync Engine to recover resources. The\n   * implementation must guarantee that GC won't happen in other places than\n   * this method call.\n   */\n  collectGarbage(): Promise<void> {\n    // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n    // doesn't continue to accumulate the garbage keys.\n    return this.persistence.runTransaction('Garbage collection', txn => {\n      return this.garbageCollector.collectGarbage(txn).next(garbage => {\n        const promises = [] as Array<PersistencePromise<void>>;\n        garbage.forEach(key => {\n          promises.push(this.remoteDocuments.removeEntry(txn, key));\n        });\n        return PersistencePromise.waitFor(promises);\n      });\n    });\n  }\n\n  private releaseHeldBatchResults(\n    txn: PersistenceTransaction,\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<DocumentKeySet> {\n    const toRelease: MutationBatchResult[] = [];\n    for (const batchResult of this.heldBatchResults) {\n      if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n        break;\n      }\n      toRelease.push(batchResult);\n    }\n\n    if (toRelease.length === 0) {\n      return PersistencePromise.resolve(documentKeySet());\n    } else {\n      this.heldBatchResults.splice(0, toRelease.length);\n      return this.releaseBatchResults(txn, toRelease, documentBuffer);\n    }\n  }\n\n  private isRemoteUpToVersion(version: SnapshotVersion): boolean {\n    // If there are no watch targets, then we won't get remote snapshots, and\n    // we are always \"up-to-date.\"\n    const lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n    return (\n      version.compareTo(lastRemoteVersion) <= 0 ||\n      objUtils.isEmpty(this.targetIds)\n    );\n  }\n\n  private shouldHoldBatchResult(version: SnapshotVersion): boolean {\n    // Check if watcher isn't up to date or prior results are already held.\n    return (\n      !this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0\n    );\n  }\n\n  private releaseBatchResults(\n    txn: PersistenceTransaction,\n    batchResults: MutationBatchResult[],\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<DocumentKeySet> {\n    let promiseChain = PersistencePromise.resolve();\n    for (const batchResult of batchResults) {\n      promiseChain = promiseChain.next(() =>\n        this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer)\n      );\n    }\n    return promiseChain.next(() => {\n      return this.removeMutationBatches(\n        txn,\n        batchResults.map(result => result.batch)\n      );\n    });\n  }\n\n  private removeMutationBatch(\n    txn: PersistenceTransaction,\n    batch: MutationBatch\n  ): PersistencePromise<DocumentKeySet> {\n    return this.removeMutationBatches(txn, [batch]);\n  }\n\n  /** Removes all the mutation batches named in the given array. */\n  private removeMutationBatches(\n    txn: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<DocumentKeySet> {\n    let affectedDocs = documentKeySet();\n    for (const batch of batches) {\n      for (const mutation of batch.mutations) {\n        const key = mutation.key;\n        affectedDocs = affectedDocs.add(key);\n      }\n    }\n\n    return this.mutationQueue\n      .removeMutationBatches(txn, batches)\n      .next(() => affectedDocs);\n  }\n\n  private applyWriteToRemoteDocuments(\n    txn: PersistenceTransaction,\n    batchResult: MutationBatchResult,\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<void> {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n      promiseChain = promiseChain\n        .next(() => {\n          return documentBuffer.getEntry(txn, docKey);\n        })\n        .next((remoteDoc: MaybeDocument | null) => {\n          let doc = remoteDoc;\n          const ackVersion = batchResult.docVersions.get(docKey);\n          assert(\n            ackVersion !== null,\n            'ackVersions should contain every doc in the write.'\n          );\n          if (!doc || doc.version.compareTo(ackVersion!) < 0) {\n            doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n            if (!doc) {\n              assert(\n                !remoteDoc,\n                'Mutation batch ' +\n                  batch +\n                  ' applied to document ' +\n                  remoteDoc +\n                  ' resulted in null'\n              );\n            } else {\n              documentBuffer.addEntry(doc);\n            }\n          }\n        });\n    });\n    return promiseChain;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}