{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbDocumentMutation, DbMutationBatch, DbMutationQueue } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n/** A mutation queue for a specific user, backed by IndexedDB. */\n\nvar IndexedDbMutationQueue =\n/** @class */\nfunction () {\n  function IndexedDbMutationQueue(\n  /**\n   * The normalized userId (e.g. null UID => \"\" userId) used to store /\n   * retrieve mutations.\n   */\n  userId, serializer) {\n    this.userId = userId;\n    this.serializer = serializer;\n    this.garbageCollector = null;\n  }\n  /**\n   * Creates a new mutation queue for the given user.\n   * @param user The user for which to create a mutation queue.\n   * @param serializer The serializer to use when persisting to IndexedDb.\n   */\n\n\n  IndexedDbMutationQueue.forUser = function (user, serializer) {\n    // TODO(mcg): Figure out what constraints there are on userIDs\n    // In particular, are there any reserved characters? are empty ids allowed?\n    // For the moment store these together in the same mutations table assuming\n    // that empty userIDs aren't allowed.\n    assert(user.uid !== '', 'UserID must not be an empty string.');\n    var userId = user.isUnauthenticated() ? '' : user.uid;\n    return new IndexedDbMutationQueue(userId, serializer);\n  };\n\n  IndexedDbMutationQueue.prototype.start = function (transaction) {\n    var _this = this;\n\n    return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction).next(function (nextBatchId) {\n      _this.nextBatchId = nextBatchId;\n      return mutationQueuesStore(transaction).get(_this.userId);\n    }).next(function (metadata) {\n      if (!metadata) {\n        metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN,\n        /*lastStreamToken=*/\n        '');\n      }\n\n      _this.metadata = metadata; // On restart, nextBatchId may end up lower than\n      // lastAcknowledgedBatchId since it's computed from the queue\n      // contents, and there may be no mutations in the queue. In this\n      // case, we need to reset lastAcknowledgedBatchId (which is safe\n      // since the queue must be empty).\n\n      if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n        return _this.checkEmpty(transaction).next(function (empty) {\n          assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n          _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n          return mutationQueuesStore(transaction).put(_this.metadata);\n        });\n      } else {\n        return PersistencePromise.resolve();\n      }\n    });\n  };\n  /**\n   * Returns one larger than the largest batch ID that has been stored. If there\n   * are no mutations returns 0. Note that batch IDs are global.\n   */\n\n\n  IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n    var maxBatchId = BATCHID_UNKNOWN;\n    return mutationsStore(txn).iterate({\n      reverse: true\n    }, function (key, batch, control) {\n      var userId = key[0],\n          batchId = key[1];\n\n      if (batchId > maxBatchId) {\n        maxBatchId = batch.batchId;\n      }\n\n      if (userId === '') {\n        // We can't compute a predecessor for the empty string, since it\n        // is lexographically first. That also means that no other\n        // userIds can come before this one, so we can just exit early.\n        control.done();\n      } else {\n        var nextUser = immediatePredecessor(userId);\n        control.skip([nextUser]);\n      }\n    }).next(function () {\n      return maxBatchId + 1;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n    var empty = true;\n    var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n    return mutationsStore(transaction).iterate({\n      range: range\n    }, function (key, value, control) {\n      empty = false;\n      control.done();\n    }).next(function () {\n      return empty;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n    return PersistencePromise.resolve(this.nextBatchId);\n  };\n\n  IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n    return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n  };\n\n  IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n    var batchId = batch.batchId;\n    assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n    this.metadata.lastAcknowledgedBatchId = batchId;\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  };\n\n  IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n    return PersistencePromise.resolve(this.metadata.lastStreamToken);\n  };\n\n  IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  };\n\n  IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n    var _this = this;\n\n    var batchId = this.nextBatchId;\n    this.nextBatchId++;\n    var batch = new MutationBatch(batchId, localWriteTime, mutations);\n    var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n    return mutationsStore(transaction).put(dbBatch).next(function () {\n      var promises = [];\n\n      for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n        var mutation = mutations_1[_i];\n        var encodedPath = EncodedResourcePath.encode(mutation.key.path);\n        var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n        documentMutationsStore(transaction).put(indexKey, DbDocumentMutation.PLACEHOLDER);\n      }\n\n      return PersistencePromise.waitFor(promises);\n    }).next(function () {\n      return batch;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n    var _this = this;\n\n    return mutationsStore(transaction).get(this.keyForBatchId(batchId)).next(function (dbBatch) {\n      return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n    var _this = this;\n\n    var range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n    var foundBatch = null;\n    return mutationsStore(transaction).iterate({\n      range: range\n    }, function (key, dbBatch, control) {\n      if (dbBatch.userId === _this.userId) {\n        assert(dbBatch.batchId > batchId, 'Should have found mutation after ' + batchId);\n        foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n      }\n\n      control.done();\n    }).next(function () {\n      return foundBatch;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n    var _this = this;\n\n    var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n    return mutationsStore(transaction).loadAll(range).next(function (dbBatches) {\n      return dbBatches.map(function (dbBatch) {\n        return _this.serializer.fromDbMutationBatch(dbBatch);\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n    var _this = this;\n\n    var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n    return mutationsStore(transaction).loadAll(range).next(function (dbBatches) {\n      return dbBatches.map(function (dbBatch) {\n        return _this.serializer.fromDbMutationBatch(dbBatch);\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n    var _this = this; // Scan the document-mutation index starting with a prefix starting with\n    // the given documentKey.\n\n\n    var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n    var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n    var results = [];\n    return documentMutationsStore(transaction).iterate({\n      range: indexStart\n    }, function (indexKey, _, control) {\n      var userID = indexKey[0],\n          encodedPath = indexKey[1],\n          batchID = indexKey[2]; // Only consider rows matching exactly the specific key of\n      // interest. Note that because we order by path first, and we\n      // order terminators before path separators, we'll encounter all\n      // the index rows for documentKey contiguously. In particular, all\n      // the rows for documentKey will occur before any rows for\n      // documents nested in a subcollection beneath documentKey so we\n      // can stop as soon as we hit any such row.\n\n      var path = EncodedResourcePath.decode(encodedPath);\n\n      if (userID !== _this.userId || !documentKey.path.equals(path)) {\n        control.done();\n        return;\n      }\n\n      var mutationKey = _this.keyForBatchId(batchID); // Look up the mutation batch in the store.\n      // PORTING NOTE: because iteration is callback driven in the web,\n      // we just look up the key instead of keeping an open iterator\n      // like iOS.\n\n\n      return mutationsStore(transaction).get(mutationKey).next(function (dbBatch) {\n        if (dbBatch === null) {\n          fail('Dangling document-mutation reference found: ' + indexKey + ' which points to ' + mutationKey);\n        }\n\n        results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n      });\n    }).next(function () {\n      return results;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n    var _this = this;\n\n    assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n    var queryPath = query.path;\n    var immediateChildrenLength = queryPath.length + 1; // TODO(mcg): Actually implement a single-collection query\n    //\n    // This is actually executing an ancestor query, traversing the whole\n    // subtree below the collection which can be horrifically inefficient for\n    // some structures. The right way to solve this is to implement the full\n    // value index, but that's not in the cards in the near future so this is\n    // the best we can do for the moment.\n    //\n    // Since we don't yet index the actual properties in the mutations, our\n    // current approach is to just return all mutation batches that affect\n    // documents in the collection being queried.\n\n    var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);\n    var encodedQueryPath = indexPrefix[1];\n    var indexStart = IDBKeyRange.lowerBound(indexPrefix); // Collect up unique batchIDs encountered during a scan of the index. Use a\n    // SortedSet to accumulate batch IDs so they can be traversed in order in a\n    // scan of the main table.\n\n    var uniqueBatchIDs = new SortedSet(primitiveComparator);\n    return documentMutationsStore(transaction).iterate({\n      range: indexStart\n    }, function (indexKey, _, control) {\n      var userID = indexKey[0],\n          encodedPath = indexKey[1],\n          batchID = indexKey[2];\n      var path = EncodedResourcePath.decode(encodedPath);\n\n      if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n        control.done();\n        return;\n      } // Rows with document keys more than one segment longer than the\n      // query path can't be matches. For example, a query on 'rooms'\n      // can't match the document /rooms/abc/messages/xyx.\n      // TODO(mcg): we'll need a different scanner when we implement\n      // ancestor queries.\n\n\n      if (path.length !== immediateChildrenLength) {\n        return;\n      }\n\n      uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n    }).next(function () {\n      var results = [];\n      var promises = []; // TODO(rockwood): Implement this using iterate.\n\n      uniqueBatchIDs.forEach(function (batchID) {\n        var mutationKey = _this.keyForBatchId(batchID);\n\n        promises.push(mutationsStore(transaction).get(mutationKey).next(function (mutation) {\n          if (mutation === null) {\n            fail('Dangling document-mutation reference found, ' + 'which points to ' + mutationKey);\n          }\n\n          results.push(_this.serializer.fromDbMutationBatch(mutation));\n        }));\n      });\n      return PersistencePromise.waitFor(promises).next(function () {\n        return results;\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n    var txn = mutationsStore(transaction);\n    var indexTxn = documentMutationsStore(transaction);\n    var promises = [];\n\n    var _loop_1 = function _loop_1(batch) {\n      var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n      var numDeleted = 0;\n      var removePromise = txn.iterate({\n        range: range\n      }, function (key, value, control) {\n        numDeleted++;\n        return control.delete();\n      });\n      promises.push(removePromise.next(function () {\n        assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' + batch.batchId);\n      }));\n\n      for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n        var mutation = _a[_i];\n        var indexKey = DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n        promises.push(indexTxn.delete(indexKey));\n\n        if (this_1.garbageCollector !== null) {\n          this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n        }\n      }\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n      var batch = batches_1[_i];\n\n      _loop_1(batch);\n    }\n\n    return PersistencePromise.waitFor(promises);\n  };\n\n  IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n    var _this = this;\n\n    return this.checkEmpty(txn).next(function (empty) {\n      if (!empty) {\n        return PersistencePromise.resolve();\n      } // Verify that there are no entries in the documentMutations index if\n      // the queue is empty.\n\n\n      var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));\n      var danglingMutationReferences = [];\n      return documentMutationsStore(txn).iterate({\n        range: startRange\n      }, function (key, _, control) {\n        var userID = key[0];\n\n        if (userID !== _this.userId) {\n          control.done();\n          return;\n        } else {\n          var path = EncodedResourcePath.decode(key[1]);\n          danglingMutationReferences.push(path);\n        }\n      }).next(function () {\n        assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' + danglingMutationReferences.map(function (p) {\n          return p.canonicalString();\n        }));\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n    this.garbageCollector = gc;\n  };\n\n  IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n    var _this = this;\n\n    var indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n    var encodedPath = indexKey[1];\n    var startRange = IDBKeyRange.lowerBound(indexKey);\n    var containsKey = false;\n    return documentMutationsStore(txn).iterate({\n      range: startRange,\n      keysOnly: true\n    }, function (key, _, control) {\n      var userID = key[0],\n          keyPath = key[1],\n          batchID = key[2];\n\n      if (userID === _this.userId && keyPath === encodedPath) {\n        containsKey = true;\n      }\n\n      control.done();\n    }).next(function () {\n      return containsKey;\n    });\n  };\n  /**\n   * Creates a [userId, batchId] key for use with the DbMutationQueue object\n   * store.\n   */\n\n\n  IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n    return [this.userId, batchId];\n  };\n\n  return IndexedDbMutationQueue;\n}();\n\nexport { IndexedDbMutationQueue };\n\nfunction validateStreamToken(token) {\n  assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n  return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\n\n\nfunction mutationsStore(txn) {\n  return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\n\n\nfunction documentMutationsStore(txn) {\n  return getStore(txn, DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\n\n\nfunction mutationQueuesStore(txn) {\n  return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\n\n\nfunction getStore(txn, store) {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}","map":{"version":3,"sources":["../src/local/indexeddb_mutation_queue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { GarbageCollector } from './garbage_collector';\nimport {\n  DbDocumentMutation,\n  DbDocumentMutationKey,\n  DbMutationBatch,\n  DbMutationBatchKey,\n  DbMutationQueue,\n  DbMutationQueueKey\n} from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\n/** A mutation queue for a specific user, backed by IndexedDB. */\nexport class IndexedDbMutationQueue implements MutationQueue {\n  /**\n   * Next value to use when assigning sequential IDs to each mutation batch.\n   *\n   * NOTE: There can only be one IndexedDbMutationQueue for a given db at a\n   * time, hence it is safe to track nextBatchID as an instance-level property.\n   * Should we ever relax this constraint we'll need to revisit this.\n   */\n  private nextBatchId: BatchId;\n\n  /**\n   * A write-through cache copy of the metadata describing the current queue.\n   */\n  private metadata: DbMutationQueue;\n\n  private garbageCollector: GarbageCollector | null = null;\n\n  constructor(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    private userId: string,\n    private serializer: LocalSerializer\n  ) {}\n\n  /**\n   * Creates a new mutation queue for the given user.\n   * @param user The user for which to create a mutation queue.\n   * @param serializer The serializer to use when persisting to IndexedDb.\n   */\n  static forUser(user: User, serializer: LocalSerializer) {\n    // TODO(mcg): Figure out what constraints there are on userIDs\n    // In particular, are there any reserved characters? are empty ids allowed?\n    // For the moment store these together in the same mutations table assuming\n    // that empty userIDs aren't allowed.\n    assert(user.uid !== '', 'UserID must not be an empty string.');\n    const userId = user.isUnauthenticated() ? '' : user.uid!;\n    return new IndexedDbMutationQueue(userId, serializer);\n  }\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n      .next(nextBatchId => {\n        this.nextBatchId = nextBatchId;\n        return mutationQueuesStore(transaction).get(this.userId);\n      })\n      .next((metadata: DbMutationQueue | null) => {\n        if (!metadata) {\n          metadata = new DbMutationQueue(\n            this.userId,\n            BATCHID_UNKNOWN,\n            /*lastStreamToken=*/ ''\n          );\n        }\n        this.metadata = metadata;\n\n        // On restart, nextBatchId may end up lower than\n        // lastAcknowledgedBatchId since it's computed from the queue\n        // contents, and there may be no mutations in the queue. In this\n        // case, we need to reset lastAcknowledgedBatchId (which is safe\n        // since the queue must be empty).\n        if (this.metadata.lastAcknowledgedBatchId >= this.nextBatchId) {\n          return this.checkEmpty(transaction).next(empty => {\n            assert(\n              empty,\n              'Reset nextBatchID is only possible when the queue is empty'\n            );\n\n            this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n            return mutationQueuesStore(transaction).put(this.metadata);\n          });\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n  }\n\n  /**\n   * Returns one larger than the largest batch ID that has been stored. If there\n   * are no mutations returns 0. Note that batch IDs are global.\n   */\n  static loadNextBatchIdFromDb(\n    txn: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    let maxBatchId = BATCHID_UNKNOWN;\n    return mutationsStore(txn)\n      .iterate({ reverse: true }, (key, batch, control) => {\n        const [userId, batchId] = key;\n        if (batchId > maxBatchId) {\n          maxBatchId = batch.batchId;\n        }\n\n        if (userId === '') {\n          // We can't compute a predecessor for the empty string, since it\n          // is lexographically first. That also means that no other\n          // userIds can come before this one, so we can just exit early.\n          control.done();\n        } else {\n          const nextUser = immediatePredecessor(userId);\n          control.skip([nextUser]);\n        }\n      })\n      .next(() => maxBatchId + 1);\n  }\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    let empty = true;\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(Number.NEGATIVE_INFINITY),\n      this.keyForBatchId(Number.POSITIVE_INFINITY)\n    );\n    return mutationsStore(transaction)\n      .iterate({ range }, (key, value, control) => {\n        empty = false;\n        control.done();\n      })\n      .next(() => empty);\n  }\n\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.nextBatchId);\n  }\n\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n  }\n\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    const batchId = batch.batchId;\n    assert(\n      batchId > this.metadata.lastAcknowledgedBatchId,\n      'Mutation batchIDs must be acknowledged in order'\n    );\n\n    this.metadata.lastAcknowledgedBatchId = batchId;\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n\n    return mutationQueuesStore(transaction).put(this.metadata);\n  }\n\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString> {\n    return PersistencePromise.resolve(this.metadata.lastStreamToken);\n  }\n\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n    const batch = new MutationBatch(batchId, localWriteTime, mutations);\n\n    const dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n\n    return mutationsStore(transaction)\n      .put(dbBatch)\n      .next(() => {\n        const promises: Array<PersistencePromise<void>> = [];\n        for (const mutation of mutations) {\n          const encodedPath = EncodedResourcePath.encode(mutation.key.path);\n          const indexKey = DbDocumentMutation.key(\n            this.userId,\n            mutation.key.path,\n            batchId\n          );\n          documentMutationsStore(transaction).put(\n            indexKey,\n            DbDocumentMutation.PLACEHOLDER\n          );\n        }\n        return PersistencePromise.waitFor(promises);\n      })\n      .next(() => {\n        return batch;\n      });\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return mutationsStore(transaction)\n      .get(this.keyForBatchId(batchId))\n      .next(\n        dbBatch =>\n          dbBatch ? this.serializer.fromDbMutationBatch(dbBatch) : null\n      );\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n    let foundBatch: MutationBatch | null = null;\n    return mutationsStore(transaction)\n      .iterate({ range }, (key, dbBatch, control) => {\n        if (dbBatch.userId === this.userId) {\n          assert(\n            dbBatch.batchId > batchId,\n            'Should have found mutation after ' + batchId\n          );\n          foundBatch = this.serializer.fromDbMutationBatch(dbBatch);\n        }\n        control.done();\n      })\n      .next(() => foundBatch);\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(BATCHID_UNKNOWN),\n      this.keyForBatchId(Number.POSITIVE_INFINITY)\n    );\n    return mutationsStore(transaction)\n      .loadAll(range)\n      .next(dbBatches =>\n        dbBatches.map(dbBatch => this.serializer.fromDbMutationBatch(dbBatch))\n      );\n  }\n\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]> {\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(BATCHID_UNKNOWN),\n      this.keyForBatchId(batchId)\n    );\n    return mutationsStore(transaction)\n      .loadAll(range)\n      .next(dbBatches =>\n        dbBatches.map(dbBatch => this.serializer.fromDbMutationBatch(dbBatch))\n      );\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    // Scan the document-mutation index starting with a prefix starting with\n    // the given documentKey.\n    const indexPrefix = DbDocumentMutation.prefixForPath(\n      this.userId,\n      documentKey.path\n    );\n    const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n\n    const results: MutationBatch[] = [];\n    return documentMutationsStore(transaction)\n      .iterate({ range: indexStart }, (indexKey, _, control) => {\n        const [userID, encodedPath, batchID] = indexKey;\n\n        // Only consider rows matching exactly the specific key of\n        // interest. Note that because we order by path first, and we\n        // order terminators before path separators, we'll encounter all\n        // the index rows for documentKey contiguously. In particular, all\n        // the rows for documentKey will occur before any rows for\n        // documents nested in a subcollection beneath documentKey so we\n        // can stop as soon as we hit any such row.\n        const path = EncodedResourcePath.decode(encodedPath);\n        if (userID !== this.userId || !documentKey.path.equals(path)) {\n          control.done();\n          return;\n        }\n        const mutationKey = this.keyForBatchId(batchID);\n        // Look up the mutation batch in the store.\n        // PORTING NOTE: because iteration is callback driven in the web,\n        // we just look up the key instead of keeping an open iterator\n        // like iOS.\n        return mutationsStore(transaction)\n          .get(mutationKey)\n          .next(dbBatch => {\n            if (dbBatch === null) {\n              fail(\n                'Dangling document-mutation reference found: ' +\n                  indexKey +\n                  ' which points to ' +\n                  mutationKey\n              );\n            }\n            results.push(this.serializer.fromDbMutationBatch(dbBatch!));\n          });\n      })\n      .next(() => results);\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    assert(\n      !query.isDocumentQuery(),\n      \"Document queries shouldn't go down this path\"\n    );\n\n    const queryPath = query.path;\n    const immediateChildrenLength = queryPath.length + 1;\n\n    // TODO(mcg): Actually implement a single-collection query\n    //\n    // This is actually executing an ancestor query, traversing the whole\n    // subtree below the collection which can be horrifically inefficient for\n    // some structures. The right way to solve this is to implement the full\n    // value index, but that's not in the cards in the near future so this is\n    // the best we can do for the moment.\n    //\n    // Since we don't yet index the actual properties in the mutations, our\n    // current approach is to just return all mutation batches that affect\n    // documents in the collection being queried.\n    const indexPrefix = DbDocumentMutation.prefixForPath(\n      this.userId,\n      queryPath\n    );\n    const encodedQueryPath = indexPrefix[1];\n    const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n\n    // Collect up unique batchIDs encountered during a scan of the index. Use a\n    // SortedSet to accumulate batch IDs so they can be traversed in order in a\n    // scan of the main table.\n    let uniqueBatchIDs = new SortedSet<BatchId>(primitiveComparator);\n    return documentMutationsStore(transaction)\n      .iterate({ range: indexStart }, (indexKey, _, control) => {\n        const [userID, encodedPath, batchID] = indexKey;\n        const path = EncodedResourcePath.decode(encodedPath);\n        if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n          control.done();\n          return;\n        }\n        // Rows with document keys more than one segment longer than the\n        // query path can't be matches. For example, a query on 'rooms'\n        // can't match the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (path.length !== immediateChildrenLength) {\n          return;\n        }\n        uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n      })\n      .next(() => {\n        const results: MutationBatch[] = [];\n        const promises: Array<PersistencePromise<void>> = [];\n        // TODO(rockwood): Implement this using iterate.\n        uniqueBatchIDs.forEach(batchID => {\n          const mutationKey = this.keyForBatchId(batchID);\n          promises.push(\n            mutationsStore(transaction)\n              .get(mutationKey)\n              .next(mutation => {\n                if (mutation === null) {\n                  fail(\n                    'Dangling document-mutation reference found, ' +\n                      'which points to ' +\n                      mutationKey\n                  );\n                }\n                results.push(this.serializer.fromDbMutationBatch(mutation!));\n              })\n          );\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n      });\n  }\n\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void> {\n    const txn = mutationsStore(transaction);\n    const indexTxn = documentMutationsStore(transaction);\n    const promises: Array<PersistencePromise<void>> = [];\n\n    for (const batch of batches) {\n      const range = IDBKeyRange.only(this.keyForBatchId(batch.batchId));\n      let numDeleted = 0;\n      const removePromise = txn.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n      });\n      promises.push(\n        removePromise.next(() => {\n          assert(\n            numDeleted === 1,\n            'Dangling document-mutation reference found: Missing batch ' +\n              batch.batchId\n          );\n        })\n      );\n      for (const mutation of batch.mutations) {\n        const indexKey = DbDocumentMutation.key(\n          this.userId,\n          mutation.key.path,\n          batch.batchId\n        );\n        promises.push(indexTxn.delete(indexKey));\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(mutation.key);\n        }\n      }\n    }\n    return PersistencePromise.waitFor(promises);\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.checkEmpty(txn).next(empty => {\n      if (!empty) {\n        return PersistencePromise.resolve();\n      }\n\n      // Verify that there are no entries in the documentMutations index if\n      // the queue is empty.\n      const startRange = IDBKeyRange.lowerBound(\n        DbDocumentMutation.prefixForUser(this.userId)\n      );\n      const danglingMutationReferences: ResourcePath[] = [];\n      return documentMutationsStore(txn)\n        .iterate({ range: startRange }, (key, _, control) => {\n          const userID = key[0];\n          if (userID !== this.userId) {\n            control.done();\n            return;\n          } else {\n            const path = EncodedResourcePath.decode(key[1]);\n            danglingMutationReferences.push(path);\n          }\n        })\n        .next(() => {\n          assert(\n            danglingMutationReferences.length === 0,\n            'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n              danglingMutationReferences.map(p => p.canonicalString())\n          );\n        });\n    });\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.garbageCollector = gc;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n      .iterate({ range: startRange, keysOnly: true }, (key, _, control) => {\n        const [userID, keyPath, batchID] = key;\n        if (userID === this.userId && keyPath === encodedPath) {\n          containsKey = true;\n        }\n        control.done();\n      })\n      .next(() => containsKey);\n  }\n\n  /**\n   * Creates a [userId, batchId] key for use with the DbMutationQueue object\n   * store.\n   */\n  private keyForBatchId(batchId: BatchId): DbMutationBatchKey {\n    return [this.userId, batchId];\n  }\n}\n\nfunction validateStreamToken(token: ProtoByteString): string {\n  assert(\n    typeof token === 'string',\n    'Persisting non-string stream token not supported.'\n  );\n  return token as string;\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbMutationBatchKey, DbMutationBatch> {\n  return getStore<DbMutationBatchKey, DbMutationBatch>(\n    txn,\n    DbMutationBatch.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbDocumentMutationKey, DbDocumentMutation> {\n  return getStore<DbDocumentMutationKey, DbDocumentMutation>(\n    txn,\n    DbDocumentMutation.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbMutationQueueKey, DbMutationQueue> {\n  return getStore<DbMutationQueueKey, DbMutationQueue>(\n    txn,\n    DbMutationQueue.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore<KeyType extends IDBValidKey, ValueType>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<KeyType, ValueType> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<KeyType, ValueType>(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}