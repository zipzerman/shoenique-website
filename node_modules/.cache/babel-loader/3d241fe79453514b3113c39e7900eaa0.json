{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { AddedLimboDocument, RemovedLimboDocument, View } from './view';\nvar LOG_TAG = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\n\nvar QueryView =\n/** @class */\nfunction () {\n  function QueryView(\n  /**\n   * The query itself.\n   */\n  query,\n  /**\n   * The target number created by the client that is used in the watch\n   * stream to identify this query.\n   */\n  targetId,\n  /**\n   * An identifier from the datastore backend that indicates the last state\n   * of the results that was received. This can be used to indicate where\n   * to continue receiving new doc changes for the query.\n   */\n  resumeToken,\n  /**\n   * The view is responsible for computing the final merged truth of what\n   * docs are in the query. It gets notified of local and remote changes,\n   * and applies the query filters and limits to determine the most correct\n   * possible results.\n   */\n  view) {\n    this.query = query;\n    this.targetId = targetId;\n    this.resumeToken = resumeToken;\n    this.view = view;\n  }\n\n  return QueryView;\n}();\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\n\n\nvar SyncEngine =\n/** @class */\nfunction () {\n  function SyncEngine(localStore, remoteStore, currentUser) {\n    this.localStore = localStore;\n    this.remoteStore = remoteStore;\n    this.currentUser = currentUser;\n    this.viewHandler = null;\n    this.errorHandler = null;\n    this.queryViewsByQuery = new ObjectMap(function (q) {\n      return q.canonicalId();\n    });\n    this.queryViewsByTarget = {};\n    this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);\n    this.limboKeysByTarget = {};\n    this.limboDocumentRefs = new ReferenceSet();\n    this.limboCollector = new EagerGarbageCollector();\n    /** Stores user completion handlers, indexed by User and BatchId. */\n\n    this.mutationUserCallbacks = {};\n    this.targetIdGenerator = TargetIdGenerator.forSyncEngine();\n  }\n  /** Subscribes view and error handler. Can be called only once. */\n\n\n  SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {\n    assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');\n    assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');\n    this.viewHandler = viewHandler;\n    this.errorHandler = errorHandler;\n    this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n  };\n  /**\n   * Initiates the new listen, resolves promise when listen enqueued to the\n   * server. All the subsequent view snapshots or errors are sent to the\n   * subscribed handlers. Returns the targetId of the query.\n   */\n\n\n  SyncEngine.prototype.listen = function (query) {\n    var _this = this;\n\n    this.assertSubscribed('listen()');\n    assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);\n    return this.localStore.allocateQuery(query).then(function (queryData) {\n      return _this.localStore.executeQuery(query).then(function (docs) {\n        return _this.localStore.remoteDocumentKeys(queryData.targetId).then(function (remoteKeys) {\n          var view = new View(query, remoteKeys);\n          var viewDocChanges = view.computeDocChanges(docs);\n          var viewChange = view.applyChanges(viewDocChanges);\n          assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');\n          assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');\n          var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);\n\n          _this.queryViewsByQuery.set(query, data);\n\n          _this.queryViewsByTarget[queryData.targetId] = data;\n\n          _this.viewHandler([viewChange.snapshot]);\n\n          _this.remoteStore.listen(queryData);\n        });\n      }).then(function () {\n        return queryData.targetId;\n      });\n    });\n  };\n  /** Stops listening to the query. */\n\n\n  SyncEngine.prototype.unlisten = function (query) {\n    var _this = this;\n\n    this.assertSubscribed('unlisten()');\n    var queryView = this.queryViewsByQuery.get(query);\n    assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n    return this.localStore.releaseQuery(query).then(function () {\n      _this.remoteStore.unlisten(queryView.targetId);\n\n      return _this.removeAndCleanupQuery(queryView).then(function () {\n        return _this.localStore.collectGarbage();\n      });\n    });\n  };\n  /**\n   * Initiates the write of local mutation batch which involves adding the\n   * writes to the mutation queue, notifying the remote store about new\n   * mutations and raising events for any changes this write caused.\n   *\n   * The promise returned by this call is resolved when the above steps\n   * have completed, *not* when the write was acked by the backend. The\n   * userCallback is resolved once the write was acked/rejected by the\n   * backend (or failed locally for any other reason).\n   */\n\n\n  SyncEngine.prototype.write = function (batch, userCallback) {\n    var _this = this;\n\n    this.assertSubscribed('write()');\n    return this.localStore.localWrite(batch).then(function (result) {\n      _this.addMutationCallback(result.batchId, userCallback);\n\n      return _this.emitNewSnapsAndNotifyLocalStore(result.changes);\n    }).then(function () {\n      return _this.remoteStore.fillWritePipeline();\n    });\n  }; // TODO(klimt): Wrap the given error in a standard Firestore error object.\n\n\n  SyncEngine.prototype.wrapUpdateFunctionError = function (error) {\n    return error;\n  };\n  /**\n   * Takes an updateFunction in which a set of reads and writes can be performed\n   * atomically. In the updateFunction, the client can read and write values\n   * using the supplied transaction object. After the updateFunction, all\n   * changes will be committed. If some other client has changed any of the data\n   * referenced, then the updateFunction will be called again. If the\n   * updateFunction still fails after the given number of retries, then the\n   * transaction will be rejection.\n   *\n   * The transaction object passed to the updateFunction contains methods for\n   * accessing documents and collections. Unlike other datastore access, data\n   * accessed with the transaction will not reflect local changes that have not\n   * been committed. For this reason, it is required that all reads are\n   * performed before any writes. Transactions must be performed while online.\n   *\n   * The promise returned is resolved when the transaction is fully committed.\n   */\n\n\n  SyncEngine.prototype.runTransaction = function (updateFunction, retries) {\n    var _this = this;\n\n    if (retries === void 0) {\n      retries = 5;\n    }\n\n    assert(retries >= 0, 'Got negative number of retries for transaction.');\n    var transaction = this.remoteStore.createTransaction();\n\n    var wrappedUpdateFunction = function wrappedUpdateFunction() {\n      try {\n        var userPromise = updateFunction(transaction);\n\n        if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {\n          return Promise.reject(Error('Transaction callback must return a Promise'));\n        }\n\n        return userPromise.catch(function (e) {\n          return Promise.reject(_this.wrapUpdateFunctionError(e));\n        });\n      } catch (e) {\n        return Promise.reject(_this.wrapUpdateFunctionError(e));\n      }\n    };\n\n    return wrappedUpdateFunction().then(function (result) {\n      return transaction.commit().then(function () {\n        return result;\n      }).catch(function (error) {\n        if (retries === 0) {\n          return Promise.reject(error);\n        } // TODO(klimt): Put in a retry delay?\n\n\n        return _this.runTransaction(updateFunction, retries - 1);\n      });\n    });\n  };\n\n  SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {\n    var _this = this;\n\n    this.assertSubscribed('applyRemoteEvent()'); // Make sure limbo documents are deleted if there were no results\n\n    objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {\n      var limboKey = _this.limboKeysByTarget[targetId];\n\n      if (limboKey && targetChange.currentStatusUpdate === CurrentStatusUpdate.MarkCurrent && !remoteEvent.documentUpdates.get(limboKey)) {\n        // When listening to a query the server responds with a snapshot\n        // containing documents matching the query and a current marker\n        // telling us we're now in sync. It's possible for these to arrive\n        // as separate remote events or as a single remote event.\n        // For a document query, there will be no documents sent in the\n        // response if the document doesn't exist.\n        //\n        // If the snapshot arrives separately from the current marker,\n        // we handle it normally and updateTrackedLimbos will resolve the\n        // limbo status of the document, removing it from limboDocumentRefs.\n        // This works because clients only initiate limbo resolution when\n        // a target is current and because all current targets are\n        // always at a consistent snapshot.\n        //\n        // However, if the document doesn't exist and the current marker\n        // arrives, the document is not present in the snapshot and our\n        // normal view handling would consider the document to remain in\n        // limbo indefinitely because there are no updates to the document.\n        // To avoid this, we specially handle this just this case here:\n        // synthesizing a delete.\n        //\n        // TODO(dimond): Ideally we would have an explicit lookup query\n        // instead resulting in an explicit delete message and we could\n        // remove this special logic.\n        remoteEvent.addDocumentUpdate(new NoDocument(limboKey, remoteEvent.snapshotVersion));\n      }\n    });\n    return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {\n      return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n    });\n  };\n\n  SyncEngine.prototype.rejectListen = function (targetId, err) {\n    var _this = this;\n\n    this.assertSubscribed('rejectListens()');\n    var limboKey = this.limboKeysByTarget[targetId];\n\n    if (limboKey) {\n      // Since this query failed, we won't want to manually unlisten to it.\n      // So go ahead and remove it from bookkeeping.\n      this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n      delete this.limboKeysByTarget[targetId]; // TODO(klimt): We really only should do the following on permission\n      // denied errors, but we don't have the cause code here.\n      // It's a limbo doc. Create a synthetic event saying it was deleted.\n      // This is kind of a hack. Ideally, we would have a method in the local\n      // store to purge a document. However, it would be tricky to keep all of\n      // the local store's invariants with another method.\n\n      var docMap = new SortedMap(DocumentKey.comparator);\n      docMap = docMap.insert(limboKey, new NoDocument(limboKey, SnapshotVersion.forDeletedDoc()));\n      var event_1 = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n      return this.applyRemoteEvent(event_1);\n    } else {\n      var queryView_1 = this.queryViewsByTarget[targetId];\n      assert(!!queryView_1, 'Unknown targetId: ' + targetId);\n      return this.localStore.releaseQuery(queryView_1.query).then(function () {\n        return _this.removeAndCleanupQuery(queryView_1).then(function () {\n          _this.errorHandler(queryView_1.query, err);\n        });\n      });\n    }\n  };\n\n  SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {\n    var _this = this;\n\n    this.assertSubscribed('applySuccessfulWrite()'); // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught\n    // up), so we raise user callbacks first so that they consistently happen\n    // before listen events.\n\n    this.processUserCallback(mutationBatchResult.batch.batchId,\n    /*error=*/\n    null);\n    return this.localStore.acknowledgeBatch(mutationBatchResult).then(function (changes) {\n      return _this.emitNewSnapsAndNotifyLocalStore(changes);\n    });\n  };\n\n  SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {\n    var _this = this;\n\n    this.assertSubscribed('rejectFailedWrite()'); // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught up),\n    // so we raise user callbacks first so that they consistently happen before\n    // listen events.\n\n    this.processUserCallback(batchId, error);\n    return this.localStore.rejectBatch(batchId).then(function (changes) {\n      return _this.emitNewSnapsAndNotifyLocalStore(changes);\n    });\n  };\n\n  SyncEngine.prototype.addMutationCallback = function (batchId, callback) {\n    var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n    if (!newCallbacks) {\n      newCallbacks = new SortedMap(primitiveComparator);\n    }\n\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n  };\n  /**\n   * Resolves or rejects the user callback for the given batch and then discards\n   * it.\n   */\n\n\n  SyncEngine.prototype.processUserCallback = function (batchId, error) {\n    var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()]; // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n\n    if (newCallbacks) {\n      var callback = newCallbacks.get(batchId);\n\n      if (callback) {\n        assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');\n\n        if (error) {\n          callback.reject(error);\n        } else {\n          callback.resolve();\n        }\n\n        newCallbacks = newCallbacks.remove(batchId);\n      }\n\n      this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    }\n  };\n\n  SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {\n    this.queryViewsByQuery.delete(queryView.query);\n    delete this.queryViewsByTarget[queryView.targetId];\n    this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n    return this.gcLimboDocuments();\n  };\n\n  SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {\n    for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {\n      var limboChange = limboChanges_1[_i];\n\n      if (limboChange instanceof AddedLimboDocument) {\n        this.limboDocumentRefs.addReference(limboChange.key, targetId);\n        this.trackLimboChange(limboChange);\n      } else if (limboChange instanceof RemovedLimboDocument) {\n        log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n        this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n      } else {\n        fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n      }\n    }\n\n    return this.gcLimboDocuments();\n  };\n\n  SyncEngine.prototype.trackLimboChange = function (limboChange) {\n    var key = limboChange.key;\n\n    if (!this.limboTargetsByKey.get(key)) {\n      log.debug(LOG_TAG, 'New document in limbo: ' + key);\n      var limboTargetId = this.targetIdGenerator.next();\n      var query = Query.atPath(key.path);\n      this.limboKeysByTarget[limboTargetId] = key;\n      this.remoteStore.listen(new QueryData(query, limboTargetId, QueryPurpose.Listen));\n      this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);\n    }\n  };\n\n  SyncEngine.prototype.gcLimboDocuments = function () {\n    var _this = this; // HACK: We can use a null transaction here, because we know that the\n    // reference set is entirely within memory and doesn't need a store engine.\n\n\n    return this.limboCollector.collectGarbage(null).next(function (keys) {\n      keys.forEach(function (key) {\n        var limboTargetId = _this.limboTargetsByKey.get(key);\n\n        if (limboTargetId === null) {\n          // This target already got removed, because the query failed.\n          return;\n        }\n\n        _this.remoteStore.unlisten(limboTargetId);\n\n        _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);\n        delete _this.limboKeysByTarget[limboTargetId];\n      });\n    }).toPromise();\n  }; // Visible for testing\n\n\n  SyncEngine.prototype.currentLimboDocs = function () {\n    return this.limboTargetsByKey;\n  };\n\n  SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {\n    var _this = this;\n\n    var newSnaps = [];\n    var docChangesInAllViews = [];\n    var queriesProcessed = [];\n    this.queryViewsByQuery.forEach(function (_, queryView) {\n      queriesProcessed.push(Promise.resolve().then(function () {\n        var viewDocChanges = queryView.view.computeDocChanges(changes);\n\n        if (!viewDocChanges.needsRefill) {\n          return viewDocChanges;\n        } // The query has a limit and some docs were removed, so we need\n        // to re-run the query against the local store to make sure we\n        // didn't lose any good docs that had been past the limit.\n\n\n        return _this.localStore.executeQuery(queryView.query).then(function (docs) {\n          return queryView.view.computeDocChanges(docs, viewDocChanges);\n        });\n      }).then(function (viewDocChanges) {\n        var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n        var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);\n        return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {\n          if (viewChange.snapshot) {\n            newSnaps.push(viewChange.snapshot);\n            var docChanges = LocalViewChanges.fromSnapshot(viewChange.snapshot);\n            docChangesInAllViews.push(docChanges);\n          }\n        });\n      }));\n    });\n    return Promise.all(queriesProcessed).then(function () {\n      _this.viewHandler(newSnaps);\n\n      return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n    }).then(function () {\n      return _this.localStore.collectGarbage();\n    });\n  };\n\n  SyncEngine.prototype.assertSubscribed = function (fnName) {\n    assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');\n  };\n\n  SyncEngine.prototype.handleUserChange = function (user) {\n    var _this = this;\n\n    this.currentUser = user;\n    return this.localStore.handleUserChange(user).then(function (changes) {\n      return _this.emitNewSnapsAndNotifyLocalStore(changes);\n    }).then(function () {\n      return _this.remoteStore.handleUserChange(user);\n    });\n  };\n\n  return SyncEngine;\n}();\n\nexport { SyncEngine };","map":{"version":3,"sources":["../src/core/sync_engine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalStore } from '../local/local_store';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { MaybeDocumentMap } from '../model/collections';\nimport { MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { MutationBatchResult } from '../model/mutation_batch';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { RemoteStore } from '../remote/remote_store';\nimport { RemoteSyncer } from '../remote/remote_syncer';\nimport { assert, fail } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AnyJs, primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { Deferred } from '../util/promise';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\n\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { Transaction } from './transaction';\nimport { BatchId, ProtoByteString, TargetId } from './types';\nimport {\n  AddedLimboDocument,\n  LimboDocumentChange,\n  RemovedLimboDocument,\n  View,\n  ViewDocumentChanges\n} from './view';\nimport { ViewSnapshot } from './view_snapshot';\n\nconst LOG_TAG = 'SyncEngine';\n\nexport type ViewHandler = (viewSnaps: ViewSnapshot[]) => void;\nexport type ErrorHandler = (query: Query, error: Error) => void;\n\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n  constructor(\n    /**\n     * The query itself.\n     */\n    public query: Query,\n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    public targetId: TargetId,\n    /**\n     * An identifier from the datastore backend that indicates the last state\n     * of the results that was received. This can be used to indicate where\n     * to continue receiving new doc changes for the query.\n     */\n    public resumeToken: ProtoByteString,\n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    public view: View\n  ) {}\n}\n\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\nexport class SyncEngine implements RemoteSyncer {\n  private viewHandler: ViewHandler | null = null;\n  private errorHandler: ErrorHandler | null = null;\n\n  private queryViewsByQuery = new ObjectMap<Query, QueryView>(q =>\n    q.canonicalId()\n  );\n  private queryViewsByTarget: { [targetId: number]: QueryView } = {};\n  private limboTargetsByKey = new SortedMap<DocumentKey, TargetId>(\n    DocumentKey.comparator\n  );\n  private limboKeysByTarget: { [targetId: number]: DocumentKey } = {};\n  private limboDocumentRefs = new ReferenceSet();\n  private limboCollector = new EagerGarbageCollector();\n  /** Stores user completion handlers, indexed by User and BatchId. */\n  private mutationUserCallbacks = {} as {\n    [uidKey: string]: SortedMap<BatchId, Deferred<void>>;\n  };\n  private targetIdGenerator = TargetIdGenerator.forSyncEngine();\n\n  constructor(\n    private localStore: LocalStore,\n    private remoteStore: RemoteStore,\n    private currentUser: User\n  ) {}\n\n  /** Subscribes view and error handler. Can be called only once. */\n  subscribe(viewHandler: ViewHandler, errorHandler: ErrorHandler): void {\n    assert(\n      viewHandler !== null && errorHandler !== null,\n      'View and error handlers cannot be null'\n    );\n    assert(\n      this.viewHandler === null && this.errorHandler === null,\n      'SyncEngine already has a subscriber.'\n    );\n    this.viewHandler = viewHandler;\n    this.errorHandler = errorHandler;\n    this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n  }\n\n  /**\n   * Initiates the new listen, resolves promise when listen enqueued to the\n   * server. All the subsequent view snapshots or errors are sent to the\n   * subscribed handlers. Returns the targetId of the query.\n   */\n  listen(query: Query): Promise<TargetId> {\n    this.assertSubscribed('listen()');\n    assert(\n      !this.queryViewsByQuery.has(query),\n      'We already listen to the query: ' + query\n    );\n\n    return this.localStore.allocateQuery(query).then(queryData => {\n      return this.localStore\n        .executeQuery(query)\n        .then(docs => {\n          return this.localStore\n            .remoteDocumentKeys(queryData.targetId)\n            .then(remoteKeys => {\n              const view = new View(query, remoteKeys);\n              const viewDocChanges = view.computeDocChanges(docs);\n              const viewChange = view.applyChanges(viewDocChanges);\n              assert(\n                viewChange.limboChanges.length === 0,\n                'View returned limbo docs before target ack from the server.'\n              );\n              assert(\n                !!viewChange.snapshot,\n                'applyChanges for new view should always return a snapshot'\n              );\n\n              const data = new QueryView(\n                query,\n                queryData.targetId,\n                queryData.resumeToken,\n                view\n              );\n              this.queryViewsByQuery.set(query, data);\n              this.queryViewsByTarget[queryData.targetId] = data;\n              this.viewHandler!([viewChange.snapshot!]);\n              this.remoteStore.listen(queryData);\n            });\n        })\n        .then(() => {\n          return queryData.targetId;\n        });\n    });\n  }\n\n  /** Stops listening to the query. */\n  unlisten(query: Query): Promise<void> {\n    this.assertSubscribed('unlisten()');\n\n    const queryView = this.queryViewsByQuery.get(query)!;\n    assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n\n    return this.localStore.releaseQuery(query).then(() => {\n      this.remoteStore.unlisten(queryView.targetId);\n      return this.removeAndCleanupQuery(queryView).then(() => {\n        return this.localStore.collectGarbage();\n      });\n    });\n  }\n\n  /**\n   * Initiates the write of local mutation batch which involves adding the\n   * writes to the mutation queue, notifying the remote store about new\n   * mutations and raising events for any changes this write caused.\n   *\n   * The promise returned by this call is resolved when the above steps\n   * have completed, *not* when the write was acked by the backend. The\n   * userCallback is resolved once the write was acked/rejected by the\n   * backend (or failed locally for any other reason).\n   */\n  write(batch: Mutation[], userCallback: Deferred<void>): Promise<void> {\n    this.assertSubscribed('write()');\n    return this.localStore\n      .localWrite(batch)\n      .then(result => {\n        this.addMutationCallback(result.batchId, userCallback);\n        return this.emitNewSnapsAndNotifyLocalStore(result.changes);\n      })\n      .then(() => {\n        return this.remoteStore.fillWritePipeline();\n      });\n  }\n\n  // TODO(klimt): Wrap the given error in a standard Firestore error object.\n  private wrapUpdateFunctionError(error: AnyJs): AnyJs {\n    return error;\n  }\n\n  /**\n   * Takes an updateFunction in which a set of reads and writes can be performed\n   * atomically. In the updateFunction, the client can read and write values\n   * using the supplied transaction object. After the updateFunction, all\n   * changes will be committed. If some other client has changed any of the data\n   * referenced, then the updateFunction will be called again. If the\n   * updateFunction still fails after the given number of retries, then the\n   * transaction will be rejection.\n   *\n   * The transaction object passed to the updateFunction contains methods for\n   * accessing documents and collections. Unlike other datastore access, data\n   * accessed with the transaction will not reflect local changes that have not\n   * been committed. For this reason, it is required that all reads are\n   * performed before any writes. Transactions must be performed while online.\n   *\n   * The promise returned is resolved when the transaction is fully committed.\n   */\n  runTransaction<T>(\n    updateFunction: (transaction: Transaction) => Promise<T>,\n    retries = 5\n  ): Promise<T> {\n    assert(retries >= 0, 'Got negative number of retries for transaction.');\n    const transaction = this.remoteStore.createTransaction();\n    const wrappedUpdateFunction = () => {\n      try {\n        const userPromise = updateFunction(transaction);\n        if (\n          isNullOrUndefined(userPromise) ||\n          !userPromise.catch ||\n          !userPromise.then\n        ) {\n          return Promise.reject<T>(\n            Error('Transaction callback must return a Promise')\n          );\n        }\n        return userPromise.catch(e => {\n          return Promise.reject<T>(this.wrapUpdateFunctionError(e));\n        });\n      } catch (e) {\n        return Promise.reject<T>(this.wrapUpdateFunctionError(e));\n      }\n    };\n    return wrappedUpdateFunction().then(result => {\n      return transaction\n        .commit()\n        .then(() => {\n          return result;\n        })\n        .catch(error => {\n          if (retries === 0) {\n            return Promise.reject<T>(error);\n          }\n          // TODO(klimt): Put in a retry delay?\n          return this.runTransaction(updateFunction, retries - 1);\n        });\n    });\n  }\n\n  applyRemoteEvent(remoteEvent: RemoteEvent): Promise<void> {\n    this.assertSubscribed('applyRemoteEvent()');\n\n    // Make sure limbo documents are deleted if there were no results\n    objUtils.forEachNumber(\n      remoteEvent.targetChanges,\n      (targetId, targetChange) => {\n        const limboKey = this.limboKeysByTarget[targetId];\n        if (\n          limboKey &&\n          targetChange.currentStatusUpdate ===\n            CurrentStatusUpdate.MarkCurrent &&\n          !remoteEvent.documentUpdates.get(limboKey)\n        ) {\n          // When listening to a query the server responds with a snapshot\n          // containing documents matching the query and a current marker\n          // telling us we're now in sync. It's possible for these to arrive\n          // as separate remote events or as a single remote event.\n          // For a document query, there will be no documents sent in the\n          // response if the document doesn't exist.\n          //\n          // If the snapshot arrives separately from the current marker,\n          // we handle it normally and updateTrackedLimbos will resolve the\n          // limbo status of the document, removing it from limboDocumentRefs.\n          // This works because clients only initiate limbo resolution when\n          // a target is current and because all current targets are\n          // always at a consistent snapshot.\n          //\n          // However, if the document doesn't exist and the current marker\n          // arrives, the document is not present in the snapshot and our\n          // normal view handling would consider the document to remain in\n          // limbo indefinitely because there are no updates to the document.\n          // To avoid this, we specially handle this just this case here:\n          // synthesizing a delete.\n          //\n          // TODO(dimond): Ideally we would have an explicit lookup query\n          // instead resulting in an explicit delete message and we could\n          // remove this special logic.\n          remoteEvent.addDocumentUpdate(\n            new NoDocument(limboKey, remoteEvent.snapshotVersion)\n          );\n        }\n      }\n    );\n\n    return this.localStore.applyRemoteEvent(remoteEvent).then(changes => {\n      return this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n    });\n  }\n\n  rejectListen(targetId: TargetId, err: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectListens()');\n    const limboKey = this.limboKeysByTarget[targetId];\n    if (limboKey) {\n      // Since this query failed, we won't want to manually unlisten to it.\n      // So go ahead and remove it from bookkeeping.\n      this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n      delete this.limboKeysByTarget[targetId];\n\n      // TODO(klimt): We really only should do the following on permission\n      // denied errors, but we don't have the cause code here.\n\n      // It's a limbo doc. Create a synthetic event saying it was deleted.\n      // This is kind of a hack. Ideally, we would have a method in the local\n      // store to purge a document. However, it would be tricky to keep all of\n      // the local store's invariants with another method.\n      let docMap = new SortedMap<DocumentKey, MaybeDocument>(\n        DocumentKey.comparator\n      );\n      docMap = docMap.insert(\n        limboKey,\n        new NoDocument(limboKey, SnapshotVersion.forDeletedDoc())\n      );\n      const event = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n      return this.applyRemoteEvent(event);\n    } else {\n      const queryView = this.queryViewsByTarget[targetId];\n      assert(!!queryView, 'Unknown targetId: ' + targetId);\n      return this.localStore.releaseQuery(queryView.query).then(() => {\n        return this.removeAndCleanupQuery(queryView).then(() => {\n          this.errorHandler!(queryView.query, err);\n        });\n      });\n    }\n  }\n\n  applySuccessfulWrite(\n    mutationBatchResult: MutationBatchResult\n  ): Promise<void> {\n    this.assertSubscribed('applySuccessfulWrite()');\n\n    // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught\n    // up), so we raise user callbacks first so that they consistently happen\n    // before listen events.\n    this.processUserCallback(\n      mutationBatchResult.batch.batchId,\n      /*error=*/ null\n    );\n\n    return this.localStore\n      .acknowledgeBatch(mutationBatchResult)\n      .then(changes => {\n        return this.emitNewSnapsAndNotifyLocalStore(changes);\n      });\n  }\n\n  rejectFailedWrite(batchId: BatchId, error: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectFailedWrite()');\n\n    // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught up),\n    // so we raise user callbacks first so that they consistently happen before\n    // listen events.\n    this.processUserCallback(batchId, error);\n\n    return this.localStore.rejectBatch(batchId).then(changes => {\n      return this.emitNewSnapsAndNotifyLocalStore(changes);\n    });\n  }\n\n  private addMutationCallback(\n    batchId: BatchId,\n    callback: Deferred<void>\n  ): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n    if (!newCallbacks) {\n      newCallbacks = new SortedMap<BatchId, Deferred<void>>(\n        primitiveComparator\n      );\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n  }\n\n  /**\n   * Resolves or rejects the user callback for the given batch and then discards\n   * it.\n   */\n  private processUserCallback(batchId: BatchId, error: Error | null): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n      const callback = newCallbacks.get(batchId);\n      if (callback) {\n        assert(\n          batchId === newCallbacks.minKey(),\n          'Mutation callbacks processed out-of-order?'\n        );\n        if (error) {\n          callback.reject(error);\n        } else {\n          callback.resolve();\n        }\n        newCallbacks = newCallbacks.remove(batchId);\n      }\n      this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    }\n  }\n\n  private removeAndCleanupQuery(queryView: QueryView): Promise<void> {\n    this.queryViewsByQuery.delete(queryView.query);\n    delete this.queryViewsByTarget[queryView.targetId];\n\n    this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n    return this.gcLimboDocuments();\n  }\n\n  private updateTrackedLimbos(\n    targetId: TargetId,\n    limboChanges: LimboDocumentChange[]\n  ): Promise<void> {\n    for (const limboChange of limboChanges) {\n      if (limboChange instanceof AddedLimboDocument) {\n        this.limboDocumentRefs.addReference(limboChange.key, targetId);\n        this.trackLimboChange(limboChange);\n      } else if (limboChange instanceof RemovedLimboDocument) {\n        log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n        this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n      } else {\n        fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n      }\n    }\n    return this.gcLimboDocuments();\n  }\n\n  private trackLimboChange(limboChange: AddedLimboDocument): void {\n    const key = limboChange.key;\n    if (!this.limboTargetsByKey.get(key)) {\n      log.debug(LOG_TAG, 'New document in limbo: ' + key);\n      const limboTargetId = this.targetIdGenerator.next();\n      const query = Query.atPath(key.path);\n      this.limboKeysByTarget[limboTargetId] = key;\n      this.remoteStore.listen(\n        new QueryData(query, limboTargetId, QueryPurpose.Listen)\n      );\n      this.limboTargetsByKey = this.limboTargetsByKey.insert(\n        key,\n        limboTargetId\n      );\n    }\n  }\n\n  private gcLimboDocuments(): Promise<void> {\n    // HACK: We can use a null transaction here, because we know that the\n    // reference set is entirely within memory and doesn't need a store engine.\n    return this.limboCollector\n      .collectGarbage(null)\n      .next(keys => {\n        keys.forEach(key => {\n          const limboTargetId = this.limboTargetsByKey.get(key);\n          if (limboTargetId === null) {\n            // This target already got removed, because the query failed.\n            return;\n          }\n          this.remoteStore.unlisten(limboTargetId);\n          this.limboTargetsByKey = this.limboTargetsByKey.remove(key);\n          delete this.limboKeysByTarget[limboTargetId];\n        });\n      })\n      .toPromise();\n  }\n\n  // Visible for testing\n  currentLimboDocs(): SortedMap<DocumentKey, TargetId> {\n    return this.limboTargetsByKey;\n  }\n\n  private emitNewSnapsAndNotifyLocalStore(\n    changes: MaybeDocumentMap,\n    remoteEvent?: RemoteEvent\n  ): Promise<void> {\n    const newSnaps: ViewSnapshot[] = [];\n    const docChangesInAllViews: LocalViewChanges[] = [];\n    const queriesProcessed: Array<Promise<void>> = [];\n\n    this.queryViewsByQuery.forEach((_, queryView) => {\n      queriesProcessed.push(\n        Promise.resolve()\n          .then(() => {\n            const viewDocChanges = queryView.view.computeDocChanges(changes);\n            if (!viewDocChanges.needsRefill) {\n              return viewDocChanges;\n            }\n            // The query has a limit and some docs were removed, so we need\n            // to re-run the query against the local store to make sure we\n            // didn't lose any good docs that had been past the limit.\n            return this.localStore.executeQuery(queryView.query).then(docs => {\n              return queryView.view.computeDocChanges(docs, viewDocChanges);\n            });\n          })\n          .then((viewDocChanges: ViewDocumentChanges) => {\n            const targetChange =\n              remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n            const viewChange = queryView.view.applyChanges(\n              viewDocChanges,\n              targetChange\n            );\n            return this.updateTrackedLimbos(\n              queryView.targetId,\n              viewChange.limboChanges\n            ).then(() => {\n              if (viewChange.snapshot) {\n                newSnaps.push(viewChange.snapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(\n                  viewChange.snapshot\n                );\n                docChangesInAllViews.push(docChanges);\n              }\n            });\n          })\n      );\n    });\n\n    return Promise.all(queriesProcessed)\n      .then(() => {\n        this.viewHandler!(newSnaps);\n        return this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n      })\n      .then(() => {\n        return this.localStore.collectGarbage();\n      });\n  }\n\n  private assertSubscribed(fnName: string): void {\n    assert(\n      this.viewHandler !== null && this.errorHandler !== null,\n      'Trying to call ' + fnName + ' before calling subscribe().'\n    );\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    this.currentUser = user;\n    return this.localStore\n      .handleUserChange(user)\n      .then(changes => {\n        return this.emitNewSnapsAndNotifyLocalStore(changes);\n      })\n      .then(() => {\n        return this.remoteStore.handleUserChange(user);\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}