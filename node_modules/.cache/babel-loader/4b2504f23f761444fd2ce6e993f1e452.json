{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\n\nvar EagerGarbageCollector =\n/** @class */\nfunction () {\n  function EagerGarbageCollector() {\n    this.isEager = true;\n    /**\n     * The garbage collectible sources to double-check during garbage collection.\n     */\n\n    this.sources = [];\n    /**\n     * A set of potentially garbage keys.\n     * PORTING NOTE: This would be a mutable set if Javascript had one.\n     */\n\n    this.potentialGarbage = documentKeySet();\n  }\n\n  EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n    this.sources.push(garbageSource);\n    garbageSource.setGarbageCollector(this);\n  };\n\n  EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n    this.sources.splice(this.sources.indexOf(garbageSource), 1);\n    garbageSource.setGarbageCollector(null);\n  };\n\n  EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n    this.potentialGarbage = this.potentialGarbage.add(key);\n  };\n\n  EagerGarbageCollector.prototype.collectGarbage = function (txn) {\n    var _this = this;\n\n    var promises = [];\n    var garbageKeys = documentKeySet();\n    this.potentialGarbage.forEach(function (key) {\n      var hasRefsPromise = _this.documentHasAnyReferences(txn, key);\n\n      promises.push(hasRefsPromise.next(function (hasRefs) {\n        // If there are no references, get the key.\n        if (!hasRefs) {\n          garbageKeys = garbageKeys.add(key);\n        }\n\n        return PersistencePromise.resolve();\n      }));\n    }); // Clear locally retained potential keys and returned confirmed garbage.\n\n    this.potentialGarbage = documentKeySet();\n    return PersistencePromise.waitFor(promises).next(function () {\n      return garbageKeys;\n    });\n  };\n\n  EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {\n    var initial = PersistencePromise.resolve(false);\n    return this.sources.map(function (source) {\n      return function () {\n        return source.containsKey(txn, key);\n      };\n    }).reduce(function (promise, nextPromise) {\n      return promise.next(function (result) {\n        if (result) {\n          return PersistencePromise.resolve(true);\n        } else {\n          return nextPromise();\n        }\n      });\n    }, initial);\n  };\n\n  return EagerGarbageCollector;\n}();\n\nexport { EagerGarbageCollector };","map":{"version":3,"sources":["../src/local/eager_garbage_collector.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAAyB,cAAzB,QAA+C,sBAA/C;AAMA,SAAS,kBAAT,QAAmC,uBAAnC;AAEA;;;;;;;;AAQG;;AACH,IAAA,qBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,qBAAA,GAAA;AACW,SAAA,OAAA,GAAU,IAAV;AAET;;AAEG;;AACK,SAAA,OAAA,GAA2B,EAA3B;AAER;;;AAGG;;AACK,SAAA,gBAAA,GAAmC,cAAc,EAAjD;AAyDT;;AAvDC,EAAA,qBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,aAAjB,EAA6C;AAC3C,SAAK,OAAL,CAAa,IAAb,CAAkB,aAAlB;AACA,IAAA,aAAa,CAAC,mBAAd,CAAkC,IAAlC;AACD,GAHD;;AAKA,EAAA,qBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,aAApB,EAAgD;AAC9C,SAAK,OAAL,CAAa,MAAb,CAAoB,KAAK,OAAL,CAAa,OAAb,CAAqB,aAArB,CAApB,EAAyD,CAAzD;AACA,IAAA,aAAa,CAAC,mBAAd,CAAkC,IAAlC;AACD,GAHD;;AAKA,EAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,GAAvB,EAAuC;AACrC,SAAK,gBAAL,GAAwB,KAAK,gBAAL,CAAsB,GAAtB,CAA0B,GAA1B,CAAxB;AACD,GAFD;;AAIA,EAAA,qBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UACE,GADF,EACoC;AADpC,QAAA,KAAA,GAAA,IAAA;;AAGE,QAAM,QAAQ,GAAoC,EAAlD;AACA,QAAI,WAAW,GAAG,cAAc,EAAhC;AAEA,SAAK,gBAAL,CAAsB,OAAtB,CAA8B,UAAA,GAAA,EAAG;AAC/B,UAAM,cAAc,GAAG,KAAI,CAAC,wBAAL,CAA8B,GAA9B,EAAmC,GAAnC,CAAvB;;AACA,MAAA,QAAQ,CAAC,IAAT,CACE,cAAc,CAAC,IAAf,CAAoB,UAAA,OAAA,EAAO;AACzB;AACA,YAAI,CAAC,OAAL,EAAc;AACZ,UAAA,WAAW,GAAG,WAAW,CAAC,GAAZ,CAAgB,GAAhB,CAAd;AACD;;AACD,eAAO,kBAAkB,CAAC,OAAnB,EAAP;AACD,OAND,CADF;AASD,KAXD,EALkC,CAkBlC;;AACA,SAAK,gBAAL,GAAwB,cAAc,EAAtC;AACA,WAAO,kBAAkB,CAAC,OAAnB,CAA2B,QAA3B,EAAqC,IAArC,CAA0C,YAAA;AAAM,aAAA,WAAA;AAAW,KAA3D,CAAP;AACD,GAtBD;;AAwBA,EAAA,qBAAA,CAAA,SAAA,CAAA,wBAAA,GAAA,UACE,GADF,EAEE,GAFF,EAEkB;AAEhB,QAAM,OAAO,GAAG,kBAAkB,CAAC,OAAnB,CAA2B,KAA3B,CAAhB;AACA,WAAO,KAAK,OAAL,CACJ,GADI,CACA,UAAA,MAAA,EAAM;AAAI,aAAA,YAAA;AAAM,eAAA,MAAM,CAAC,WAAP,CAAmB,GAAnB,EAAA,GAAA,CAAA;AAAN,OAAA;AAAkC,KAD5C,EAEJ,MAFI,CAEgC,UAAC,OAAD,EAAU,WAAV,EAAqB;AACxD,aAAO,OAAO,CAAC,IAAR,CAAa,UAAA,MAAA,EAAM;AACxB,YAAI,MAAJ,EAAY;AACV,iBAAO,kBAAkB,CAAC,OAAnB,CAA2B,IAA3B,CAAP;AACD,SAFD,MAEO;AACL,iBAAO,WAAW,EAAlB;AACD;AACF,OANM,CAAP;AAOD,KAVI,EAUF,OAVE,CAAP;AAWD,GAhBD;;AAiBF,SAAA,qBAAA;AAAC,CArED,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentKeySet, documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { GarbageSource } from './garbage_source';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nexport class EagerGarbageCollector implements GarbageCollector {\n  readonly isEager = true;\n\n  /**\n   * The garbage collectible sources to double-check during garbage collection.\n   */\n  private sources: GarbageSource[] = [];\n\n  /**\n   * A set of potentially garbage keys.\n   * PORTING NOTE: This would be a mutable set if Javascript had one.\n   */\n  private potentialGarbage: DocumentKeySet = documentKeySet();\n\n  addGarbageSource(garbageSource: GarbageSource): void {\n    this.sources.push(garbageSource);\n    garbageSource.setGarbageCollector(this);\n  }\n\n  removeGarbageSource(garbageSource: GarbageSource): void {\n    this.sources.splice(this.sources.indexOf(garbageSource), 1);\n    garbageSource.setGarbageCollector(null);\n  }\n\n  addPotentialGarbageKey(key: DocumentKey): void {\n    this.potentialGarbage = this.potentialGarbage.add(key);\n  }\n\n  collectGarbage(\n    txn: PersistenceTransaction | null\n  ): PersistencePromise<DocumentKeySet> {\n    const promises: Array<PersistencePromise<void>> = [];\n    let garbageKeys = documentKeySet();\n\n    this.potentialGarbage.forEach(key => {\n      const hasRefsPromise = this.documentHasAnyReferences(txn, key);\n      promises.push(\n        hasRefsPromise.next(hasRefs => {\n          // If there are no references, get the key.\n          if (!hasRefs) {\n            garbageKeys = garbageKeys.add(key);\n          }\n          return PersistencePromise.resolve();\n        })\n      );\n    });\n\n    // Clear locally retained potential keys and returned confirmed garbage.\n    this.potentialGarbage = documentKeySet();\n    return PersistencePromise.waitFor(promises).next(() => garbageKeys);\n  }\n\n  documentHasAnyReferences(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const initial = PersistencePromise.resolve(false);\n    return this.sources\n      .map(source => () => source.containsKey(txn, key))\n      .reduce<PersistencePromise<boolean>>((promise, nextPromise) => {\n        return promise.next(result => {\n          if (result) {\n            return PersistencePromise.resolve(true);\n          } else {\n            return nextPromise();\n          }\n        });\n      }, initial);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}