{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OnlineState } from './types';\nimport { ChangeType } from './view_snapshot';\nimport { DocumentSet } from '../model/document_set';\nimport { assert } from '../util/assert';\nimport { ObjectMap } from '../util/obj_map';\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\n\nvar QueryListenersInfo =\n/** @class */\nfunction () {\n  function QueryListenersInfo() {\n    this.listeners = [];\n  }\n\n  return QueryListenersInfo;\n}();\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\n\n\nvar EventManager =\n/** @class */\nfunction () {\n  function EventManager(syncEngine) {\n    this.syncEngine = syncEngine;\n    this.queries = new ObjectMap(function (q) {\n      return q.canonicalId();\n    });\n    this.onlineState = OnlineState.Unknown;\n    this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));\n  }\n\n  EventManager.prototype.listen = function (listener) {\n    var query = listener.query;\n    var firstListen = false;\n    var queryInfo = this.queries.get(query);\n\n    if (!queryInfo) {\n      firstListen = true;\n      queryInfo = new QueryListenersInfo();\n      this.queries.set(query, queryInfo);\n    }\n\n    queryInfo.listeners.push(listener);\n    listener.onOnlineStateChanged(this.onlineState);\n    if (queryInfo.viewSnap) listener.onViewSnapshot(queryInfo.viewSnap);\n\n    if (firstListen) {\n      return this.syncEngine.listen(query).then(function (targetId) {\n        queryInfo.targetId = targetId;\n        return targetId;\n      });\n    } else {\n      return Promise.resolve(queryInfo.targetId);\n    }\n  };\n\n  EventManager.prototype.unlisten = function (listener) {\n    var query = listener.query;\n    var lastListen = false;\n    var queryInfo = this.queries.get(query);\n\n    if (queryInfo) {\n      var i = queryInfo.listeners.indexOf(listener);\n\n      if (i >= 0) {\n        queryInfo.listeners.splice(i, 1);\n        lastListen = queryInfo.listeners.length === 0;\n      }\n    }\n\n    if (lastListen) {\n      this.queries.delete(query);\n      return this.syncEngine.unlisten(query);\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  EventManager.prototype.onChange = function (viewSnaps) {\n    for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {\n      var viewSnap = viewSnaps_1[_i];\n      var query = viewSnap.query;\n      var queryInfo = this.queries.get(query);\n\n      if (queryInfo) {\n        for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {\n          var listener = _b[_a];\n          listener.onViewSnapshot(viewSnap);\n        }\n\n        queryInfo.viewSnap = viewSnap;\n      }\n    }\n  };\n\n  EventManager.prototype.onError = function (query, error) {\n    var queryInfo = this.queries.get(query);\n\n    if (queryInfo) {\n      for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.onError(error);\n      }\n    } // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n\n\n    this.queries.delete(query);\n  };\n\n  EventManager.prototype.onOnlineStateChanged = function (onlineState) {\n    this.onlineState = onlineState;\n    this.queries.forEach(function (_, queryInfo) {\n      for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.onOnlineStateChanged(onlineState);\n      }\n    });\n  };\n\n  return EventManager;\n}();\n\nexport { EventManager };\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\n\nvar QueryListener =\n/** @class */\nfunction () {\n  function QueryListener(query, queryObserver, options) {\n    this.query = query;\n    this.queryObserver = queryObserver;\n    /**\n     * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n     * observer. This flag is set to true once we've actually raised an event.\n     */\n\n    this.raisedInitialEvent = false;\n    this.onlineState = OnlineState.Unknown;\n    this.options = options || {};\n  }\n\n  QueryListener.prototype.onViewSnapshot = function (snap) {\n    assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');\n\n    if (!this.options.includeDocumentMetadataChanges) {\n      // Remove the metadata only changes.\n      var docChanges = [];\n\n      for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {\n        var docChange = _a[_i];\n\n        if (docChange.type !== ChangeType.Metadata) {\n          docChanges.push(docChange);\n        }\n      }\n\n      snap = {\n        query: snap.query,\n        docs: snap.docs,\n        oldDocs: snap.oldDocs,\n        docChanges: docChanges,\n        fromCache: snap.fromCache,\n        hasPendingWrites: snap.hasPendingWrites,\n        syncStateChanged: snap.syncStateChanged\n      };\n    }\n\n    if (!this.raisedInitialEvent) {\n      if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n        this.raiseInitialEvent(snap);\n      }\n    } else if (this.shouldRaiseEvent(snap)) {\n      this.queryObserver.next(snap);\n    }\n\n    this.snap = snap;\n  };\n\n  QueryListener.prototype.onError = function (error) {\n    this.queryObserver.error(error);\n  };\n\n  QueryListener.prototype.onOnlineStateChanged = function (onlineState) {\n    this.onlineState = onlineState;\n\n    if (this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n      this.raiseInitialEvent(this.snap);\n    }\n  };\n\n  QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {\n    assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event'); // Always raise the first event when we're synced\n\n    if (!snap.fromCache) {\n      return true;\n    } // NOTE: We consider OnlineState.Unknown as online (it should become Failed\n    // or Online if we wait long enough).\n\n\n    var maybeOnline = onlineState !== OnlineState.Failed; // Don't raise the event if we're online, aren't synced yet (checked\n    // above) and are waiting for a sync.\n\n    if (this.options.waitForSyncWhenOnline && maybeOnline) {\n      assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');\n      return false;\n    } // Raise data from cache if we have any documents or we are offline\n\n\n    return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;\n  };\n\n  QueryListener.prototype.shouldRaiseEvent = function (snap) {\n    // We don't need to handle includeDocumentMetadataChanges here because\n    // the Metadata only changes have already been stripped out if needed.\n    // At this point the only changes we will see are the ones we should\n    // propagate.\n    if (snap.docChanges.length > 0) {\n      return true;\n    }\n\n    var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n\n    if (snap.syncStateChanged || hasPendingWritesChanged) {\n      return this.options.includeQueryMetadataChanges === true;\n    } // Generally we should have hit one of the cases above, but it's possible\n    // to get here if there were only metadata docChanges and they got\n    // stripped out.\n\n\n    return false;\n  };\n\n  QueryListener.prototype.raiseInitialEvent = function (snap) {\n    assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');\n    snap = {\n      query: snap.query,\n      docs: snap.docs,\n      oldDocs: DocumentSet.emptySet(snap.docs),\n      docChanges: QueryListener.getInitialViewChanges(snap),\n      fromCache: snap.fromCache,\n      hasPendingWrites: snap.hasPendingWrites,\n      syncStateChanged: true\n    };\n    this.raisedInitialEvent = true;\n    this.queryObserver.next(snap);\n  };\n  /** Returns changes as if all documents in the snap were added. */\n\n\n  QueryListener.getInitialViewChanges = function (snap) {\n    var result = [];\n    snap.docs.forEach(function (doc) {\n      result.push({\n        type: ChangeType.Added,\n        doc: doc\n      });\n    });\n    return result;\n  };\n\n  return QueryListener;\n}();\n\nexport { QueryListener };","map":{"version":3,"sources":["../src/core/event_manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from './query';\nimport { SyncEngine } from './sync_engine';\nimport { OnlineState, TargetId } from './types';\nimport { DocumentViewChange } from './view_snapshot';\nimport { ChangeType, ViewSnapshot } from './view_snapshot';\nimport { DocumentSet } from '../model/document_set';\nimport { assert } from '../util/assert';\nimport { EventHandler } from '../util/misc';\nimport * as obj from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\n\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n  public viewSnap: ViewSnapshot | null;\n  public targetId: TargetId;\n  public listeners: QueryListener[] = [];\n}\n\n/**\n * Interface for handling events from the EventManager.\n */\nexport interface Observer<T> {\n  next: EventHandler<T>;\n  error: EventHandler<Error>;\n}\n\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nexport class EventManager {\n  private queries = new ObjectMap<Query, QueryListenersInfo>(q =>\n    q.canonicalId()\n  );\n\n  private onlineState: OnlineState = OnlineState.Unknown;\n\n  constructor(private syncEngine: SyncEngine) {\n    this.syncEngine.subscribe(\n      this.onChange.bind(this),\n      this.onError.bind(this)\n    );\n  }\n\n  listen(listener: QueryListener): Promise<TargetId> {\n    const query = listener.query;\n    let firstListen = false;\n\n    let queryInfo = this.queries.get(query);\n    if (!queryInfo) {\n      firstListen = true;\n      queryInfo = new QueryListenersInfo();\n      this.queries.set(query, queryInfo);\n    }\n    queryInfo.listeners.push(listener);\n\n    listener.onOnlineStateChanged(this.onlineState);\n\n    if (queryInfo.viewSnap) listener.onViewSnapshot(queryInfo.viewSnap);\n\n    if (firstListen) {\n      return this.syncEngine.listen(query).then(targetId => {\n        queryInfo!.targetId = targetId;\n        return targetId;\n      });\n    } else {\n      return Promise.resolve(queryInfo.targetId);\n    }\n  }\n\n  unlisten(listener: QueryListener): Promise<void> {\n    const query = listener.query;\n    let lastListen = false;\n\n    const queryInfo = this.queries.get(query);\n    if (queryInfo) {\n      const i = queryInfo.listeners.indexOf(listener);\n      if (i >= 0) {\n        queryInfo.listeners.splice(i, 1);\n        lastListen = queryInfo.listeners.length === 0;\n      }\n    }\n\n    if (lastListen) {\n      this.queries.delete(query);\n      return this.syncEngine.unlisten(query);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  onChange(viewSnaps: ViewSnapshot[]): void {\n    for (const viewSnap of viewSnaps) {\n      const query = viewSnap.query;\n      const queryInfo = this.queries.get(query);\n      if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n          listener.onViewSnapshot(viewSnap);\n        }\n        queryInfo.viewSnap = viewSnap;\n      }\n    }\n  }\n\n  onError(query: Query, error: Error): void {\n    const queryInfo = this.queries.get(query);\n    if (queryInfo) {\n      for (const listener of queryInfo.listeners) {\n        listener.onError(error);\n      }\n    }\n\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    this.queries.delete(query);\n  }\n\n  onOnlineStateChanged(onlineState: OnlineState): void {\n    this.onlineState = onlineState;\n    this.queries.forEach((_, queryInfo) => {\n      for (const listener of queryInfo.listeners) {\n        listener.onOnlineStateChanged(onlineState);\n      }\n    });\n  }\n}\n\nexport interface ListenOptions {\n  /** Raise events when only metadata of documents changes */\n  readonly includeDocumentMetadataChanges?: boolean;\n\n  /** Raise events when only metadata of the query changes */\n  readonly includeQueryMetadataChanges?: boolean;\n\n  /**\n   * Wait for a sync with the server when online, but still raise events while\n   * offline.\n   */\n  readonly waitForSyncWhenOnline?: boolean;\n}\n\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nexport class QueryListener {\n  /**\n   * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n   * observer. This flag is set to true once we've actually raised an event.\n   */\n  private raisedInitialEvent = false;\n\n  private options: ListenOptions;\n\n  private snap: ViewSnapshot;\n\n  private onlineState: OnlineState = OnlineState.Unknown;\n\n  constructor(\n    readonly query: Query,\n    private queryObserver: Observer<ViewSnapshot>,\n    options?: ListenOptions\n  ) {\n    this.options = options || {};\n  }\n\n  onViewSnapshot(snap: ViewSnapshot): void {\n    assert(\n      snap.docChanges.length > 0 || snap.syncStateChanged,\n      'We got a new snapshot with no changes?'\n    );\n\n    if (!this.options.includeDocumentMetadataChanges) {\n      // Remove the metadata only changes.\n      const docChanges: DocumentViewChange[] = [];\n      for (const docChange of snap.docChanges) {\n        if (docChange.type !== ChangeType.Metadata) {\n          docChanges.push(docChange);\n        }\n      }\n      snap = {\n        query: snap.query,\n        docs: snap.docs,\n        oldDocs: snap.oldDocs,\n        docChanges,\n        fromCache: snap.fromCache,\n        hasPendingWrites: snap.hasPendingWrites,\n        syncStateChanged: snap.syncStateChanged\n      };\n    }\n\n    if (!this.raisedInitialEvent) {\n      if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n        this.raiseInitialEvent(snap);\n      }\n    } else if (this.shouldRaiseEvent(snap)) {\n      this.queryObserver.next(snap);\n    }\n\n    this.snap = snap;\n  }\n\n  onError(error: Error): void {\n    this.queryObserver.error(error);\n  }\n\n  onOnlineStateChanged(onlineState: OnlineState): void {\n    this.onlineState = onlineState;\n    if (\n      this.snap &&\n      !this.raisedInitialEvent &&\n      this.shouldRaiseInitialEvent(this.snap, onlineState)\n    ) {\n      this.raiseInitialEvent(this.snap);\n    }\n  }\n\n  private shouldRaiseInitialEvent(\n    snap: ViewSnapshot,\n    onlineState: OnlineState\n  ): boolean {\n    assert(\n      !this.raisedInitialEvent,\n      'Determining whether to raise first event but already had first event'\n    );\n\n    // Always raise the first event when we're synced\n    if (!snap.fromCache) {\n      return true;\n    }\n\n    // NOTE: We consider OnlineState.Unknown as online (it should become Failed\n    // or Online if we wait long enough).\n    const maybeOnline = onlineState !== OnlineState.Failed;\n    // Don't raise the event if we're online, aren't synced yet (checked\n    // above) and are waiting for a sync.\n    if (this.options.waitForSyncWhenOnline && maybeOnline) {\n      assert(\n        snap.fromCache,\n        'Waiting for sync, but snapshot is not from cache'\n      );\n      return false;\n    }\n\n    // Raise data from cache if we have any documents or we are offline\n    return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;\n  }\n\n  private shouldRaiseEvent(snap: ViewSnapshot): boolean {\n    // We don't need to handle includeDocumentMetadataChanges here because\n    // the Metadata only changes have already been stripped out if needed.\n    // At this point the only changes we will see are the ones we should\n    // propagate.\n    if (snap.docChanges.length > 0) {\n      return true;\n    }\n\n    const hasPendingWritesChanged =\n      this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n    if (snap.syncStateChanged || hasPendingWritesChanged) {\n      return this.options.includeQueryMetadataChanges === true;\n    }\n\n    // Generally we should have hit one of the cases above, but it's possible\n    // to get here if there were only metadata docChanges and they got\n    // stripped out.\n    return false;\n  }\n\n  private raiseInitialEvent(snap: ViewSnapshot): void {\n    assert(\n      !this.raisedInitialEvent,\n      'Trying to raise initial events for second time'\n    );\n    snap = {\n      query: snap.query,\n      docs: snap.docs,\n      oldDocs: DocumentSet.emptySet(snap.docs),\n      docChanges: QueryListener.getInitialViewChanges(snap),\n      fromCache: snap.fromCache,\n      hasPendingWrites: snap.hasPendingWrites,\n      syncStateChanged: true\n    };\n    this.raisedInitialEvent = true;\n    this.queryObserver.next(snap);\n  }\n\n  /** Returns changes as if all documents in the snap were added. */\n  private static getInitialViewChanges(\n    snap: ViewSnapshot\n  ): DocumentViewChange[] {\n    const result: DocumentViewChange[] = [];\n    snap.docs.forEach(doc => {\n      result.push({ type: ChangeType.Added, doc });\n    });\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}