{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\n\nfunction deepCopy(value) {\n  return deepExtend(undefined, value);\n}\n\nexports.deepCopy = deepCopy;\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n */\n\nfunction deepExtend(target, source) {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      var dateValue = source;\n      return new Date(dateValue.getTime());\n\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n\n      break;\n\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n\n  for (var prop in source) {\n    if (!source.hasOwnProperty(prop)) {\n      continue;\n    }\n\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n\n  return target;\n}\n\nexports.deepExtend = deepExtend; // TODO: Really needed (for JSCompiler type checking)?\n\nfunction patchProperty(obj, prop, value) {\n  obj[prop] = value;\n}\n\nexports.patchProperty = patchProperty;","map":{"version":3,"sources":["../src/deepCopy.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;AAEH;;AAEG;;AACH,SAAA,QAAA,CAA4B,KAA5B,EAAoC;AAClC,SAAO,UAAU,CAAC,SAAD,EAAY,KAAZ,CAAjB;AACD;;AAFD,OAAA,CAAA,QAAA,GAAA,QAAA;AAIA;;;;;;;;;;;AAWG;;AACH,SAAA,UAAA,CAA2B,MAA3B,EAAwC,MAAxC,EAAmD;AACjD,MAAI,EAAE,MAAM,YAAY,MAApB,CAAJ,EAAiC;AAC/B,WAAO,MAAP;AACD;;AAED,UAAQ,MAAM,CAAC,WAAf;AACE,SAAK,IAAL;AACE;AACA;AACA,UAAI,SAAS,GAAI,MAAjB;AACA,aAAO,IAAI,IAAJ,CAAS,SAAS,CAAC,OAAV,EAAT,CAAP;;AAEF,SAAK,MAAL;AACE,UAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,QAAA,MAAM,GAAG,EAAT;AACD;;AACD;;AAEF,SAAK,KAAL;AACE;AACA,MAAA,MAAM,GAAG,EAAT;AACA;;AAEF;AACE;AACA,aAAO,MAAP;AApBJ;;AAuBA,OAAK,IAAI,IAAT,IAAiB,MAAjB,EAAyB;AACvB,QAAI,CAAC,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAAL,EAAkC;AAChC;AACD;;AACD,IAAA,MAAM,CAAC,IAAD,CAAN,GAAe,UAAU,CAAC,MAAM,CAAC,IAAD,CAAP,EAAe,MAAM,CAAC,IAAD,CAArB,CAAzB;AACD;;AAED,SAAO,MAAP;AACD;;AApCD,OAAA,CAAA,UAAA,GAAA,UAAA,C,CAsCA;;AACA,SAAA,aAAA,CAA8B,GAA9B,EAAwC,IAAxC,EAAsD,KAAtD,EAAgE;AAC9D,EAAA,GAAG,CAAC,IAAD,CAAH,GAAY,KAAZ;AACD;;AAFD,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nexport function deepCopy<T>(value: T): T {\n  return deepExtend(undefined, value);\n}\n\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n */\nexport function deepExtend(target: any, source: any): any {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      let dateValue = (source as any) as Date;\n      return new Date(dateValue.getTime());\n\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n      break;\n\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n\n  for (let prop in source) {\n    if (!source.hasOwnProperty(prop)) {\n      continue;\n    }\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n\n  return target;\n}\n\n// TODO: Really needed (for JSCompiler type checking)?\nexport function patchProperty(obj: any, prop: string, value: any) {\n  obj[prop] = value;\n}\n"]},"metadata":{},"sourceType":"script"}