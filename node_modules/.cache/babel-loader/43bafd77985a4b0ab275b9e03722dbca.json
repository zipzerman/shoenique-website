{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\n\nvar ExponentialBackoff =\n/** @class */\nfunction () {\n  function ExponentialBackoff(\n  /**\n   * The initial delay (used as the base delay on the first retry attempt).\n   * Note that jitter will still be applied, so the actual delay could be as\n   * little as 0.5*initialDelayMs.\n   */\n  initialDelayMs,\n  /**\n   * The multiplier to use to determine the extended base delay after each\n   * attempt.\n   */\n  backoffFactor,\n  /**\n   * The maximum base delay after which no further backoff is performed.\n   * Note that jitter will still be applied, so the actual delay could be as\n   * much as 1.5*maxDelayMs.\n   */\n  maxDelayMs) {\n    this.initialDelayMs = initialDelayMs;\n    this.backoffFactor = backoffFactor;\n    this.maxDelayMs = maxDelayMs;\n    this.reset();\n  }\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n\n\n  ExponentialBackoff.prototype.reset = function () {\n    this.currentBaseMs = 0;\n  };\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n\n\n  ExponentialBackoff.prototype.resetToMax = function () {\n    this.currentBaseMs = this.maxDelayMs;\n  };\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts.\n   */\n\n\n  ExponentialBackoff.prototype.backoffAndWait = function () {\n    var def = new Deferred(); // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n\n    var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n\n    if (this.currentBaseMs > 0) {\n      log.debug(LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" + (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n    }\n\n    setTimeout(function () {\n      def.resolve();\n    }, delayWithJitterMs); // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n\n    this.currentBaseMs *= this.backoffFactor;\n\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n\n    return def.promise;\n  };\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n\n\n  ExponentialBackoff.prototype.jitterDelayMs = function () {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  };\n\n  return ExponentialBackoff;\n}();\n\nexport { ExponentialBackoff };","map":{"version":3,"sources":["../src/remote/backoff.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,OAAO,KAAK,GAAZ,MAAqB,aAArB;AACA,SAAS,QAAT,QAAyB,iBAAzB;AAEA,IAAM,OAAO,GAAG,oBAAhB;AAEA;;;;;;;;AAQG;;AACH,IAAA,kBAAA;AAAA;AAAA,YAAA;AAGE,WAAA,kBAAA;AACE;;;;AAIG;AACc,EAAA,cANnB;AAOE;;;AAGG;AACc,EAAA,aAXnB;AAYE;;;;AAIG;AACc,EAAA,UAjBnB,EAiBqC;AAXlB,SAAA,cAAA,GAAA,cAAA;AAKA,SAAA,aAAA,GAAA,aAAA;AAMA,SAAA,UAAA,GAAA,UAAA;AAEjB,SAAK,KAAL;AACD;AAED;;;;;;AAMG;;;AACH,EAAA,kBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,SAAK,aAAL,GAAqB,CAArB;AACD,GAFD;AAIA;;;AAGG;;;AACH,EAAA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,SAAK,aAAL,GAAqB,KAAK,UAA1B;AACD,GAFD;AAIA;;;AAGG;;;AACH,EAAA,kBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,QAAM,GAAG,GAAG,IAAI,QAAJ,EAAZ,CADF,CAGE;AACA;;AACA,QAAM,iBAAiB,GAAG,KAAK,aAAL,GAAqB,KAAK,aAAL,EAA/C;;AACA,QAAI,KAAK,aAAL,GAAqB,CAAzB,EAA4B;AAC1B,MAAA,GAAG,CAAC,KAAJ,CACE,OADF,EAEE,qBAAmB,iBAAnB,GAAoC,MAApC,IACE,kBAAgB,KAAK,aAArB,GAAkC,MADpC,CAFF;AAKD;;AACD,IAAA,UAAU,CAAC,YAAA;AACT,MAAA,GAAG,CAAC,OAAJ;AACD,KAFS,EAEP,iBAFO,CAAV,CAbF,CAiBE;AACA;;AACA,SAAK,aAAL,IAAsB,KAAK,aAA3B;;AACA,QAAI,KAAK,aAAL,GAAqB,KAAK,cAA9B,EAA8C;AAC5C,WAAK,aAAL,GAAqB,KAAK,cAA1B;AACD;;AACD,QAAI,KAAK,aAAL,GAAqB,KAAK,UAA9B,EAA0C;AACxC,WAAK,aAAL,GAAqB,KAAK,UAA1B;AACD;;AAED,WAAO,GAAG,CAAC,OAAX;AACD,GA5BD;AA8BA;;;AACQ,EAAA,kBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,YAAA;AACE,WAAO,CAAC,IAAI,CAAC,MAAL,KAAgB,GAAjB,IAAwB,KAAK,aAApC;AACD,GAFO;;AAGV,SAAA,kBAAA;AAAC,CAlFD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\n\nconst LOG_TAG = 'ExponentialBackoff';\n\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nexport class ExponentialBackoff {\n  private currentBaseMs: number;\n\n  constructor(\n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    private readonly initialDelayMs: number,\n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    private readonly backoffFactor: number,\n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    private readonly maxDelayMs: number\n  ) {\n    this.reset();\n  }\n\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n  reset(): void {\n    this.currentBaseMs = 0;\n  }\n\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n  resetToMax(): void {\n    this.currentBaseMs = this.maxDelayMs;\n  }\n\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts.\n   */\n  backoffAndWait(): Promise<void> {\n    const def = new Deferred<void>();\n\n    // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n    const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n    if (this.currentBaseMs > 0) {\n      log.debug(\n        LOG_TAG,\n        `Backing off for ${delayWithJitterMs} ms ` +\n          `(base delay: ${this.currentBaseMs} ms)`\n      );\n    }\n    setTimeout(() => {\n      def.resolve();\n    }, delayWithJitterMs);\n\n    // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n    this.currentBaseMs *= this.backoffFactor;\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n\n    return def.promise;\n  }\n\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n  private jitterDelayMs(): number {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}