{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ERROR_NAME = 'FirebaseError';\nvar captureStackTrace = Error.captureStackTrace; // Export for faking in tests\n\nfunction patchCapture(captureFake) {\n  var result = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexports.patchCapture = patchCapture;\n\nvar FirebaseError =\n/** @class */\nfunction () {\n  function FirebaseError(code, message) {\n    this.code = code;\n    this.message = message;\n    var stack; // We want the stack value, if implemented by Error\n\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      var err_1 = Error.apply(this, arguments);\n      this.name = ERROR_NAME; // Make non-enumerable getter for the property.\n\n      Object.defineProperty(this, 'stack', {\n        get: function get() {\n          return err_1.stack;\n        }\n      });\n    }\n  }\n\n  return FirebaseError;\n}();\n\nexports.FirebaseError = FirebaseError; // Back-door inheritance\n\nFirebaseError.prototype = Object.create(Error.prototype);\nFirebaseError.prototype.constructor = FirebaseError;\nFirebaseError.prototype.name = ERROR_NAME;\n\nvar ErrorFactory =\n/** @class */\nfunction () {\n  function ErrorFactory(service, serviceName, errors) {\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors; // Matches {$name}, by default.\n\n    this.pattern = /\\{\\$([^}]+)}/g; // empty\n  }\n\n  ErrorFactory.prototype.create = function (code, data) {\n    if (data === undefined) {\n      data = {};\n    }\n\n    var template = this.errors[code];\n    var fullCode = this.service + '/' + code;\n    var message;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, function (match, key) {\n        var value = data[key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    } // Service: Error message (service/code).\n\n\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    var err = new FirebaseError(fullCode, message); // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n\n    for (var prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n\n      err[prop] = data[prop];\n    }\n\n    return err;\n  };\n\n  return ErrorFactory;\n}();\n\nexports.ErrorFactory = ErrorFactory;","map":{"version":3,"sources":["../src/errors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = { [code: string]: string };\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void = (Error as any)\n  .captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexport interface FirebaseError {\n  // Unique code for error - format is service/error-code-string\n  code: string;\n\n  // Developer-friendly error message.\n  message: string;\n\n  // Always 'FirebaseError'\n  name: string;\n\n  // Where available - stack backtrace in a string\n  stack: string;\n}\n\nexport class FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string, public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g;\n\n  constructor(\n    private service: string,\n    private serviceName: string,\n    private errors: ErrorList<T>\n  ) {\n    // empty\n  }\n\n  create(code: T, data?: { [prop: string]: StringLike }): FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[code as string];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}