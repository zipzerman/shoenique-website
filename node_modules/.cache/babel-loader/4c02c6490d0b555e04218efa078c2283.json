{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nexport var ChangeType;\n\n(function (ChangeType) {\n  ChangeType[ChangeType[\"Added\"] = 0] = \"Added\";\n  ChangeType[ChangeType[\"Removed\"] = 1] = \"Removed\";\n  ChangeType[ChangeType[\"Modified\"] = 2] = \"Modified\";\n  ChangeType[ChangeType[\"Metadata\"] = 3] = \"Metadata\";\n})(ChangeType || (ChangeType = {}));\n\nexport var SyncState;\n\n(function (SyncState) {\n  SyncState[SyncState[\"Local\"] = 0] = \"Local\";\n  SyncState[SyncState[\"Synced\"] = 1] = \"Synced\";\n})(SyncState || (SyncState = {}));\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\n\n\nvar DocumentChangeSet =\n/** @class */\nfunction () {\n  function DocumentChangeSet() {\n    this.changeMap = new SortedMap(DocumentKey.comparator);\n  }\n\n  DocumentChangeSet.prototype.track = function (change) {\n    var key = change.doc.key;\n    var oldChange = this.changeMap.get(key);\n\n    if (!oldChange) {\n      this.changeMap = this.changeMap.insert(key, change);\n      return;\n    } // Merge the new change with the existing change.\n\n\n    if (change.type !== ChangeType.Added && oldChange.type === ChangeType.Metadata) {\n      this.changeMap = this.changeMap.insert(key, change);\n    } else if (change.type === ChangeType.Metadata && oldChange.type !== ChangeType.Removed) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: oldChange.type,\n        doc: change.doc\n      });\n    } else if (change.type === ChangeType.Modified && oldChange.type === ChangeType.Modified) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Modified,\n        doc: change.doc\n      });\n    } else if (change.type === ChangeType.Modified && oldChange.type === ChangeType.Added) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Added,\n        doc: change.doc\n      });\n    } else if (change.type === ChangeType.Removed && oldChange.type === ChangeType.Added) {\n      this.changeMap = this.changeMap.remove(key);\n    } else if (change.type === ChangeType.Removed && oldChange.type === ChangeType.Modified) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Removed,\n        doc: oldChange.doc\n      });\n    } else if (change.type === ChangeType.Added && oldChange.type === ChangeType.Removed) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Modified,\n        doc: change.doc\n      });\n    } else {\n      // This includes these cases, which don't make sense:\n      // Added->Added\n      // Removed->Removed\n      // Modified->Added\n      // Removed->Modified\n      // Metadata->Added\n      // Removed->Metadata\n      fail('unsupported combination of changes: ' + JSON.stringify(change) + ' after ' + JSON.stringify(oldChange));\n    }\n  };\n\n  DocumentChangeSet.prototype.getChanges = function () {\n    var changes = [];\n    this.changeMap.inorderTraversal(function (key, change) {\n      changes.push(change);\n    });\n    return changes;\n  };\n\n  return DocumentChangeSet;\n}();\n\nexport { DocumentChangeSet };","map":{"version":3,"sources":["../src/core/view_snapshot.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport { fail } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\n\nimport { Query } from './query';\n\nexport enum ChangeType {\n  Added,\n  Removed,\n  Modified,\n  Metadata\n}\n\nexport interface DocumentViewChange {\n  type: ChangeType;\n  doc: Document;\n}\n\nexport enum SyncState {\n  Local,\n  Synced\n}\n\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nexport class DocumentChangeSet {\n  private changeMap = new SortedMap<DocumentKey, DocumentViewChange>(\n    DocumentKey.comparator\n  );\n\n  constructor() {}\n\n  track(change: DocumentViewChange) {\n    const key = change.doc.key;\n    const oldChange = this.changeMap.get(key);\n    if (!oldChange) {\n      this.changeMap = this.changeMap.insert(key, change);\n      return;\n    }\n\n    // Merge the new change with the existing change.\n    if (\n      change.type !== ChangeType.Added &&\n      oldChange.type === ChangeType.Metadata\n    ) {\n      this.changeMap = this.changeMap.insert(key, change);\n    } else if (\n      change.type === ChangeType.Metadata &&\n      oldChange.type !== ChangeType.Removed\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: oldChange.type,\n        doc: change.doc\n      });\n    } else if (\n      change.type === ChangeType.Modified &&\n      oldChange.type === ChangeType.Modified\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Modified,\n        doc: change.doc\n      });\n    } else if (\n      change.type === ChangeType.Modified &&\n      oldChange.type === ChangeType.Added\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Added,\n        doc: change.doc\n      });\n    } else if (\n      change.type === ChangeType.Removed &&\n      oldChange.type === ChangeType.Added\n    ) {\n      this.changeMap = this.changeMap.remove(key);\n    } else if (\n      change.type === ChangeType.Removed &&\n      oldChange.type === ChangeType.Modified\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Removed,\n        doc: oldChange.doc\n      });\n    } else if (\n      change.type === ChangeType.Added &&\n      oldChange.type === ChangeType.Removed\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Modified,\n        doc: change.doc\n      });\n    } else {\n      // This includes these cases, which don't make sense:\n      // Added->Added\n      // Removed->Removed\n      // Modified->Added\n      // Removed->Modified\n      // Metadata->Added\n      // Removed->Metadata\n      fail(\n        'unsupported combination of changes: ' +\n          JSON.stringify(change) +\n          ' after ' +\n          JSON.stringify(oldChange)\n      );\n    }\n  }\n\n  getChanges(): DocumentViewChange[] {\n    const changes: DocumentViewChange[] = [];\n    this.changeMap.inorderTraversal(\n      (key: DocumentKey, change: DocumentViewChange) => {\n        changes.push(change);\n      }\n    );\n    return changes;\n  }\n}\n\nexport interface ViewSnapshot {\n  readonly query: Query;\n  readonly docs: DocumentSet;\n  readonly oldDocs: DocumentSet;\n  readonly docChanges: DocumentViewChange[];\n  readonly fromCache: boolean;\n  readonly hasPendingWrites: boolean;\n  readonly syncStateChanged: boolean;\n}\n"]},"metadata":{},"sourceType":"module"}