{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { ExponentialBackoff } from './backoff';\nimport { isNullOrUndefined } from '../util/types';\nvar LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n\n(function (PersistentStreamState) {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\n\n\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\n\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/** The time a stream stays open after it is marked idle. */\n\nvar IDLE_TIMEOUT_MS = 60 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\n\nvar PersistentStream =\n/** @class */\nfunction () {\n  function PersistentStream(queue, connection, credentialsProvider, // Used for faster retries in testing\n  initialBackoffDelay) {\n    this.queue = queue;\n    this.connection = connection;\n    this.credentialsProvider = credentialsProvider;\n    this.idle = false;\n    this.stream = null;\n    this.listener = null;\n    this.backoff = new ExponentialBackoff(initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n    this.state = PersistentStreamState.Initial;\n  }\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n\n\n  PersistentStream.prototype.isStarted = function () {\n    return this.state === PersistentStreamState.Backoff || this.state === PersistentStreamState.Auth || this.state === PersistentStreamState.Open;\n  };\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n\n\n  PersistentStream.prototype.isOpen = function () {\n    return this.state === PersistentStreamState.Open;\n  };\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n\n\n  PersistentStream.prototype.start = function (listener) {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff(listener);\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n    this.listener = listener;\n    this.auth();\n  };\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n\n\n  PersistentStream.prototype.stop = function () {\n    if (this.isStarted()) {\n      this.close(PersistentStreamState.Stopped);\n    }\n  };\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n\n\n  PersistentStream.prototype.inhibitBackoff = function () {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  };\n  /**\n   * Initializes the idle timer. If no write takes place within one minute, the\n   * WebChannel stream will be closed.\n   */\n\n\n  PersistentStream.prototype.markIdle = function () {\n    var _this = this;\n\n    this.idle = true;\n    this.queue.schedule(function () {\n      return _this.handleIdleCloseTimer();\n    }, IDLE_TIMEOUT_MS).catch(function (err) {\n      // When the AsyncQueue gets drained during testing, pending Promises\n      // (including these idle checks) will get rejected. We special-case\n      // these cancelled idle checks to make sure that these specific Promise\n      // rejections are not considered unhandled.\n      assert(err.code === Code.CANCELLED, \"Received unexpected error in idle timeout closure. Expected CANCELLED, but was: \" + err);\n    });\n  };\n  /** Sends a message to the underlying stream. */\n\n\n  PersistentStream.prototype.sendRequest = function (msg) {\n    this.cancelIdleCheck();\n    this.stream.send(msg);\n  };\n  /** Called by the idle timer when the stream should close due to inactivity. */\n\n\n  PersistentStream.prototype.handleIdleCloseTimer = function () {\n    if (this.isOpen() && this.idle) {\n      // When timing out an idle stream there's no reason to force the stream into backoff when\n      // it restarts so set the stream state to Initial instead of Error.\n      return this.close(PersistentStreamState.Initial);\n    }\n\n    return Promise.resolve();\n  };\n  /** Marks the stream as active again. */\n\n\n  PersistentStream.prototype.cancelIdleCheck = function () {\n    this.idle = false;\n  };\n  /**\n   * Closes the stream and cleans up as necessary:\n   *\n   * * closes the underlying GRPC stream;\n   * * calls the onClose handler with the given 'error';\n   * * sets internal stream state to 'finalState';\n   * * adjusts the backoff timer based on the error\n   *\n   * A new stream can be opened by calling `start` unless `finalState` is set to\n   * `PersistentStreamState.Stopped`.\n   *\n   * @param finalState the intended state of the stream after closing.\n   * @param error the error the connection was closed with.\n   */\n\n\n  PersistentStream.prototype.close = function (finalState, error) {\n    assert(finalState == PersistentStreamState.Error || isNullOrUndefined(error), \"Can't provide an error when not in an error state.\");\n    this.cancelIdleCheck();\n\n    if (finalState != PersistentStreamState.Error) {\n      // If this is an intentional close ensure we don't delay our next connection attempt.\n      this.backoff.reset();\n    } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      log.debug(LOG_TAG, 'Using maximum backoff delay to prevent overloading the backend.');\n      this.backoff.resetToMax();\n    } // Clean up the underlying stream because we are no longer interested in events.\n\n\n    if (this.stream !== null) {\n      this.tearDown();\n      this.stream.close();\n      this.stream = null;\n    } // This state must be assigned before calling onClose() to allow the callback to\n    // inhibit backoff or otherwise manipulate the state in its non-started state.\n\n\n    this.state = finalState;\n    var listener = this.listener; // Clear the listener to avoid bleeding of events from the underlying streams.\n\n    this.listener = null; // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n    // could trigger undesirable recovery logic, etc.).\n\n    if (finalState != PersistentStreamState.Stopped) {\n      return listener.onClose(error);\n    } else {\n      return Promise.resolve();\n    }\n  };\n  /**\n   * Can be overridden to perform additional cleanup before the stream is closed.\n   * Calling super.tearDown() is not required.\n   */\n\n\n  PersistentStream.prototype.tearDown = function () {};\n\n  PersistentStream.prototype.auth = function () {\n    var _this = this;\n\n    assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n    this.state = PersistentStreamState.Auth;\n    this.credentialsProvider.getToken(\n    /*forceRefresh=*/\n    false).then(function (token) {\n      // Normally we'd have to schedule the callback on the AsyncQueue.\n      // However, the following calls are safe to be called outside the\n      // AsyncQueue since they don't chain asynchronous calls\n      _this.startStream(token);\n    }, function (error) {\n      _this.queue.schedule(function () {\n        if (_this.state !== PersistentStreamState.Stopped) {\n          // Stream can be stopped while waiting for authorization.\n          var rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n          return _this.handleStreamClose(rpcError);\n        } else {\n          return Promise.resolve();\n        }\n      });\n    });\n  };\n\n  PersistentStream.prototype.startStream = function (token) {\n    var _this = this;\n\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state'); // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n\n    var dispatchIfStillActive = function dispatchIfStillActive(stream, fn) {\n      _this.queue.schedule(function () {\n        // Only raise events if the stream instance has not changed\n        if (_this.stream === stream) {\n          return fn();\n        } else {\n          return Promise.resolve();\n        }\n      });\n    }; // Only start stream if listener has not changed\n\n\n    if (this.listener !== null) {\n      var currentStream_1 = this.startRpc(token);\n      this.stream = currentStream_1;\n      this.stream.onOpen(function () {\n        dispatchIfStillActive(currentStream_1, function () {\n          assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n          _this.state = PersistentStreamState.Open;\n          return _this.listener.onOpen();\n        });\n      });\n      this.stream.onClose(function (error) {\n        dispatchIfStillActive(currentStream_1, function () {\n          return _this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage(function (msg) {\n        dispatchIfStillActive(currentStream_1, function () {\n          return _this.onMessage(msg);\n        });\n      });\n    }\n  };\n\n  PersistentStream.prototype.performBackoff = function (listener) {\n    var _this = this;\n\n    assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n    this.state = PersistentStreamState.Backoff;\n    this.backoff.backoffAndWait().then(function () {\n      // Backoff does not run on the AsyncQueue, so we need to reschedule to\n      // make sure the queue blocks\n      _this.queue.schedule(function () {\n        if (_this.state === PersistentStreamState.Stopped) {\n          // Stream can be stopped while waiting for backoff to complete.\n          return Promise.resolve();\n        }\n\n        _this.state = PersistentStreamState.Initial;\n\n        _this.start(listener);\n\n        assert(_this.isStarted(), 'PersistentStream should have started');\n        return Promise.resolve();\n      });\n    });\n  };\n\n  PersistentStream.prototype.handleStreamClose = function (error) {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, \"close with error: \" + error);\n    this.stream = null; // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n\n    return this.close(PersistentStreamState.Error, error);\n  };\n\n  return PersistentStream;\n}();\n\nexport { PersistentStream };\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\n\nvar PersistentListenStream =\n/** @class */\nfunction (_super) {\n  __extends(PersistentListenStream, _super);\n\n  function PersistentListenStream(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {\n    var _this = _super.call(this, queue, connection, credentials, initialBackoffDelay) || this;\n\n    _this.databaseInfo = databaseInfo;\n    _this.serializer = serializer;\n    return _this;\n  }\n\n  PersistentListenStream.prototype.startRpc = function (token) {\n    return this.connection.openStream('Listen', token);\n  };\n\n  PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n    var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n    return this.listener.onWatchChange(watchChange, snapshot);\n  };\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n\n\n  PersistentListenStream.prototype.watch = function (queryData) {\n    var request = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n    var labels = this.serializer.toListenRequestLabels(queryData);\n\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.sendRequest(request);\n  };\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n\n\n  PersistentListenStream.prototype.unwatch = function (targetId) {\n    var request = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.sendRequest(request);\n  };\n\n  return PersistentListenStream;\n}(PersistentStream);\n\nexport { PersistentListenStream };\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\n\nvar PersistentWriteStream =\n/** @class */\nfunction (_super) {\n  __extends(PersistentWriteStream, _super);\n\n  function PersistentWriteStream(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {\n    var _this = _super.call(this, queue, connection, credentials, initialBackoffDelay) || this;\n\n    _this.databaseInfo = databaseInfo;\n    _this.serializer = serializer;\n    _this.handshakeComplete_ = false;\n    return _this;\n  }\n\n  Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n    /**\n     * Tracks whether or not a handshake has been successfully exchanged and\n     * the stream is ready to accept mutations.\n     */\n    get: function get() {\n      return this.handshakeComplete_;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Override of PersistentStream.start\n\n  PersistentWriteStream.prototype.start = function (listener) {\n    this.handshakeComplete_ = false;\n\n    _super.prototype.start.call(this, listener);\n  };\n\n  PersistentWriteStream.prototype.tearDown = function () {\n    if (this.handshakeComplete_) {\n      this.writeMutations([]);\n    }\n  };\n\n  PersistentWriteStream.prototype.startRpc = function (token) {\n    return this.connection.openStream('Write', token);\n  };\n\n  PersistentWriteStream.prototype.onMessage = function (responseProto) {\n    // Always capture the last stream token.\n    assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n    this.lastStreamToken = responseProto.streamToken;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n      this.handshakeComplete_ = true;\n      return this.listener.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n      var results = this.serializer.fromWriteResults(responseProto.writeResults);\n      var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n      return this.listener.onMutationResult(commitVersion, results);\n    }\n  };\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n\n\n  PersistentWriteStream.prototype.writeHandshake = function () {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed'); // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n\n    var request = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.sendRequest(request);\n  };\n  /** Sends a group of mutations to the Firestore backend to apply. */\n\n\n  PersistentWriteStream.prototype.writeMutations = function (mutations) {\n    var _this = this;\n\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n    assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n    var request = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken,\n      writes: mutations.map(function (mutation) {\n        return _this.serializer.toMutation(mutation);\n      })\n    };\n    this.sendRequest(request);\n  };\n\n  return PersistentWriteStream;\n}(PersistentStream);\n\nexport { PersistentWriteStream };","map":{"version":3,"sources":["../src/remote/persistent_stream.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider, Token } from '../api/credentials';\nimport { DatabaseInfo } from '../core/database_info';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\n\nimport { ExponentialBackoff } from './backoff';\nimport { Connection, Stream } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport { WatchChange } from './watch_change';\nimport { isNullOrUndefined } from '../util/types';\n\nconst LOG_TAG = 'PersistentStream';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface ListenRequest extends api.ListenRequest {\n  database?: string;\n}\nexport interface WriteRequest extends api.WriteRequest {\n  database?: string;\n}\n\nenum PersistentStreamState {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  Initial,\n\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n  Auth,\n\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n  Open,\n\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n  Error,\n\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n  Backoff,\n\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n  Stopped\n}\n\n/**\n * Provides a common interface that is shared by the listeners for stream\n * events by the concrete implementation classes.\n */\nexport interface PersistentStreamListener {\n  /**\n   * Called after the stream was established and can accept outgoing\n   * messages\n   */\n  onOpen: () => Promise<void>;\n  /**\n   * Called after the stream has closed. If there was an error, the\n   * FirestoreError will be set.\n   */\n  onClose: (err?: FirestoreError) => Promise<void>;\n}\n\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst BACKOFF_INITIAL_DELAY_MS = 1000;\n\n/** Maximum backoff time in milliseconds */\nconst BACKOFF_MAX_DELAY_MS = 60 * 1000;\n\nconst BACKOFF_FACTOR = 1.5;\n\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nexport abstract class PersistentStream<\n  SendType,\n  ReceiveType,\n  ListenerType extends PersistentStreamListener\n> {\n  private state: PersistentStreamState;\n  private idle: boolean = false;\n  private stream: Stream<SendType, ReceiveType> | null = null;\n\n  protected backoff: ExponentialBackoff;\n\n  protected listener: ListenerType | null = null;\n\n  constructor(\n    private queue: AsyncQueue,\n    protected connection: Connection,\n    private credentialsProvider: CredentialsProvider,\n    // Used for faster retries in testing\n    initialBackoffDelay?: number\n  ) {\n    this.backoff = new ExponentialBackoff(\n      initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS,\n      BACKOFF_FACTOR,\n      BACKOFF_MAX_DELAY_MS\n    );\n    this.state = PersistentStreamState.Initial;\n  }\n\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n  isStarted(): boolean {\n    return (\n      this.state === PersistentStreamState.Backoff ||\n      this.state === PersistentStreamState.Auth ||\n      this.state === PersistentStreamState.Open\n    );\n  }\n\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n  isOpen(): boolean {\n    return this.state === PersistentStreamState.Open;\n  }\n\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n  start(listener: ListenerType): void {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff(listener);\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n    this.listener = listener;\n    this.auth();\n  }\n\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n  stop(): void {\n    if (this.isStarted()) {\n      this.close(PersistentStreamState.Stopped);\n    }\n  }\n\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n  inhibitBackoff(): void {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  }\n\n  /**\n   * Initializes the idle timer. If no write takes place within one minute, the\n   * WebChannel stream will be closed.\n   */\n  markIdle(): void {\n    this.idle = true;\n    this.queue\n      .schedule(() => {\n        return this.handleIdleCloseTimer();\n      }, IDLE_TIMEOUT_MS)\n      .catch((err: FirestoreError) => {\n        // When the AsyncQueue gets drained during testing, pending Promises\n        // (including these idle checks) will get rejected. We special-case\n        // these cancelled idle checks to make sure that these specific Promise\n        // rejections are not considered unhandled.\n        assert(\n          err.code === Code.CANCELLED,\n          `Received unexpected error in idle timeout closure. Expected CANCELLED, but was: ${\n            err\n          }`\n        );\n      });\n  }\n\n  /** Sends a message to the underlying stream. */\n  protected sendRequest(msg: SendType): void {\n    this.cancelIdleCheck();\n    this.stream!.send(msg);\n  }\n\n  /** Called by the idle timer when the stream should close due to inactivity. */\n  private handleIdleCloseTimer(): Promise<void> {\n    if (this.isOpen() && this.idle) {\n      // When timing out an idle stream there's no reason to force the stream into backoff when\n      // it restarts so set the stream state to Initial instead of Error.\n      return this.close(PersistentStreamState.Initial);\n    }\n    return Promise.resolve();\n  }\n\n  /** Marks the stream as active again. */\n  private cancelIdleCheck() {\n    this.idle = false;\n  }\n\n  /**\n   * Closes the stream and cleans up as necessary:\n   *\n   * * closes the underlying GRPC stream;\n   * * calls the onClose handler with the given 'error';\n   * * sets internal stream state to 'finalState';\n   * * adjusts the backoff timer based on the error\n   *\n   * A new stream can be opened by calling `start` unless `finalState` is set to\n   * `PersistentStreamState.Stopped`.\n   *\n   * @param finalState the intended state of the stream after closing.\n   * @param error the error the connection was closed with.\n   */\n  private close(\n    finalState: PersistentStreamState,\n    error?: FirestoreError\n  ): Promise<void> {\n    assert(\n      finalState == PersistentStreamState.Error || isNullOrUndefined(error),\n      \"Can't provide an error when not in an error state.\"\n    );\n\n    this.cancelIdleCheck();\n\n    if (finalState != PersistentStreamState.Error) {\n      // If this is an intentional close ensure we don't delay our next connection attempt.\n      this.backoff.reset();\n    } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      log.debug(\n        LOG_TAG,\n        'Using maximum backoff delay to prevent overloading the backend.'\n      );\n      this.backoff.resetToMax();\n    }\n\n    // Clean up the underlying stream because we are no longer interested in events.\n    if (this.stream !== null) {\n      this.tearDown();\n      this.stream.close();\n      this.stream = null;\n    }\n\n    // This state must be assigned before calling onClose() to allow the callback to\n    // inhibit backoff or otherwise manipulate the state in its non-started state.\n    this.state = finalState;\n    const listener = this.listener!;\n\n    // Clear the listener to avoid bleeding of events from the underlying streams.\n    this.listener = null;\n\n    // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n    // could trigger undesirable recovery logic, etc.).\n    if (finalState != PersistentStreamState.Stopped) {\n      return listener.onClose(error);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Can be overridden to perform additional cleanup before the stream is closed.\n   * Calling super.tearDown() is not required.\n   */\n  protected tearDown(): void {}\n\n  /**\n   * Used by subclasses to start the concrete RPC and return the underlying\n   * connection stream.\n   */\n  protected abstract startRpc(\n    token: Token | null\n  ): Stream<SendType, ReceiveType>;\n\n  /**\n   * Called after the stream has received a message. The function will be\n   * called on the right queue and must return a Promise.\n   * @param message The message received from the stream.\n   */\n  protected abstract onMessage(message: ReceiveType): Promise<void>;\n\n  private auth(): void {\n    assert(\n      this.state === PersistentStreamState.Initial,\n      'Must be in initial state to auth'\n    );\n\n    this.state = PersistentStreamState.Auth;\n\n    this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(\n      token => {\n        // Normally we'd have to schedule the callback on the AsyncQueue.\n        // However, the following calls are safe to be called outside the\n        // AsyncQueue since they don't chain asynchronous calls\n        this.startStream(token);\n      },\n      (error: Error) => {\n        this.queue.schedule(() => {\n          if (this.state !== PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            const rpcError = new FirestoreError(\n              Code.UNKNOWN,\n              'Fetching auth token failed: ' + error.message\n            );\n            return this.handleStreamClose(rpcError);\n          } else {\n            return Promise.resolve();\n          }\n        });\n      }\n    );\n  }\n\n  private startStream(token: Token | null): void {\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(\n      this.state === PersistentStreamState.Auth,\n      'Trying to start stream in a non-auth state'\n    );\n    // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n    const dispatchIfStillActive = (\n      stream: Stream<SendType, ReceiveType>,\n      fn: () => Promise<void>\n    ) => {\n      this.queue.schedule(() => {\n        // Only raise events if the stream instance has not changed\n        if (this.stream === stream) {\n          return fn();\n        } else {\n          return Promise.resolve();\n        }\n      });\n    };\n\n    // Only start stream if listener has not changed\n    if (this.listener !== null) {\n      const currentStream = this.startRpc(token);\n      this.stream = currentStream;\n      this.stream.onOpen(() => {\n        dispatchIfStillActive(currentStream, () => {\n          assert(\n            this.state === PersistentStreamState.Auth,\n            'Expected stream to be in state auth, but was ' + this.state\n          );\n          this.state = PersistentStreamState.Open;\n          return this.listener!.onOpen();\n        });\n      });\n      this.stream.onClose((error: FirestoreError) => {\n        dispatchIfStillActive(currentStream, () => {\n          return this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage((msg: ReceiveType) => {\n        dispatchIfStillActive(currentStream, () => {\n          return this.onMessage(msg);\n        });\n      });\n    }\n  }\n\n  private performBackoff(listener: ListenerType): void {\n    assert(\n      this.state === PersistentStreamState.Error,\n      'Should only perform backoff in an error case'\n    );\n    this.state = PersistentStreamState.Backoff;\n\n    this.backoff.backoffAndWait().then(() => {\n      // Backoff does not run on the AsyncQueue, so we need to reschedule to\n      // make sure the queue blocks\n      this.queue.schedule(() => {\n        if (this.state === PersistentStreamState.Stopped) {\n          // Stream can be stopped while waiting for backoff to complete.\n          return Promise.resolve();\n        }\n\n        this.state = PersistentStreamState.Initial;\n        this.start(listener);\n        assert(this.isStarted(), 'PersistentStream should have started');\n        return Promise.resolve();\n      });\n    });\n  }\n\n  private handleStreamClose(error?: FirestoreError): Promise<void> {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, `close with error: ${error}`);\n\n    this.stream = null;\n\n    // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n    return this.close(PersistentStreamState.Error, error);\n  }\n}\n\n/** Listener for the PersistentWatchStream */\nexport interface WatchStreamListener extends PersistentStreamListener {\n  /**\n   * Called on a watchChange. The snapshot parameter will be MIN if the watch\n   * change did not have a snapshot associated with it.\n   */\n  onWatchChange: (\n    watchChange: WatchChange,\n    snapshot: SnapshotVersion\n  ) => Promise<void>;\n}\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nexport class PersistentListenStream extends PersistentStream<\n  api.ListenRequest,\n  api.ListenResponse,\n  WatchStreamListener\n> {\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    initialBackoffDelay?: number\n  ) {\n    super(queue, connection, credentials, initialBackoffDelay);\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.ListenRequest, api.ListenResponse> {\n    return this.connection.openStream('Listen', token);\n  }\n\n  protected onMessage(watchChangeProto: api.ListenResponse): Promise<void> {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n\n    const watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    const snapshot = this.serializer.versionFromListenResponse(\n      watchChangeProto\n    );\n    return this.listener!.onWatchChange(watchChange, snapshot);\n  }\n\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n  watch(queryData: QueryData): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n\n    const labels = this.serializer.toListenRequestLabels(queryData);\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.sendRequest(request);\n  }\n\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n  unwatch(targetId: TargetId): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.sendRequest(request);\n  }\n}\n\n/** Listener for the PersistentWriteStream */\nexport interface WriteStreamListener extends PersistentStreamListener {\n  /**\n   * Called by the PersistentWriteStream upon a successful handshake response\n   * from the server, which is the receiver's cue to send any pending writes.\n   */\n  onHandshakeComplete: () => Promise<void>;\n\n  /**\n   * Called by the PersistentWriteStream upon receiving a StreamingWriteResponse\n   * from the server that contains a mutation result.\n   */\n  onMutationResult: (\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ) => Promise<void>;\n}\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nexport class PersistentWriteStream extends PersistentStream<\n  api.WriteRequest,\n  api.WriteResponse,\n  WriteStreamListener\n> {\n  private handshakeComplete_ = false;\n\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    initialBackoffDelay?: number\n  ) {\n    super(queue, connection, credentials, initialBackoffDelay);\n  }\n\n  /**\n   * The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   *\n   * PersistentWriteStream manages propagating this value from responses to the\n   * next request.\n   */\n  public lastStreamToken: ProtoByteString;\n\n  /**\n   * Tracks whether or not a handshake has been successfully exchanged and\n   * the stream is ready to accept mutations.\n   */\n  get handshakeComplete(): boolean {\n    return this.handshakeComplete_;\n  }\n\n  // Override of PersistentStream.start\n  start(listener: WriteStreamListener): void {\n    this.handshakeComplete_ = false;\n    super.start(listener);\n  }\n\n  protected tearDown() {\n    if (this.handshakeComplete_) {\n      this.writeMutations([]);\n    }\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.WriteRequest, api.WriteResponse> {\n    return this.connection.openStream('Write', token);\n  }\n\n  protected onMessage(responseProto: api.WriteResponse): Promise<void> {\n    // Always capture the last stream token.\n    assert(\n      !!responseProto.streamToken,\n      'Got a write response without a stream token'\n    );\n    this.lastStreamToken = responseProto.streamToken!;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(\n        !responseProto.writeResults || responseProto.writeResults.length === 0,\n        'Got mutation results for handshake'\n      );\n      this.handshakeComplete_ = true;\n      return this.listener!.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n\n      const results = this.serializer.fromWriteResults(\n        responseProto.writeResults\n      );\n      const commitVersion = this.serializer.fromVersion(\n        responseProto.commitTime!\n      );\n      return this.listener!.onMutationResult(commitVersion, results);\n    }\n  }\n\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n  writeHandshake(): void {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed');\n    // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n    const request: WriteRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.sendRequest(request);\n  }\n\n  /** Sends a group of mutations to the Firestore backend to apply. */\n  writeMutations(mutations: Mutation[]): void {\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(\n      this.handshakeComplete_,\n      'Handshake must be complete before writing mutations'\n    );\n    assert(\n      this.lastStreamToken.length > 0,\n      'Trying to write mutation without a token'\n    );\n\n    const request: WriteRequest = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken as any,\n      writes: mutations.map(mutation => this.serializer.toMutation(mutation))\n    };\n\n    this.sendRequest(request);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}