{"ast":null,"code":"import _slicedToArray from \"/Users/artemis/Desktop/r3f-basic-demo-forked (1)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useEffect, useReducer, useCallback, useMemo, useLayoutEffect, useDebugValue } from 'react';\nimport { markToTrack, getUntrackedObject, isDeepChanged, createDeepProxy, affectedToPathList } from 'proxy-compare';\n/*\nexport {\n  unstable_createMutableSource as createMutableSource,\n  unstable_useMutableSource as useMutableSource,\n} from 'react'\n*/\n\nconst TARGET = Symbol();\nconst GET_VERSION = Symbol();\n\nconst createMutableSource = (target, getVersion) => ({\n  [TARGET]: target,\n  [GET_VERSION]: getVersion\n});\n\nconst useMutableSource = (source, getSnapshot, subscribe) => {\n  const lastVersion = useRef(0);\n  const currentVersion = source[GET_VERSION](source[TARGET]);\n\n  const _useState = useState(() => [\n  /* [0] */\n  source,\n  /* [1] */\n  getSnapshot,\n  /* [2] */\n  subscribe,\n  /* [3] */\n  currentVersion,\n  /* [4] */\n  getSnapshot(source[TARGET])]),\n        _useState2 = _slicedToArray(_useState, 2),\n        state = _useState2[0],\n        setState = _useState2[1];\n\n  let currentSnapshot = state[4];\n\n  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe || currentVersion !== state[3] && currentVersion !== lastVersion.current) {\n    currentSnapshot = getSnapshot(source[TARGET]);\n    setState([\n    /* [0] */\n    source,\n    /* [1] */\n    getSnapshot,\n    /* [2] */\n    subscribe,\n    /* [3] */\n    currentVersion,\n    /* [4] */\n    currentSnapshot]);\n  }\n\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      if (didUnsubscribe) {\n        return;\n      }\n\n      const nextVersion = source[GET_VERSION](source[TARGET]);\n      lastVersion.current = nextVersion;\n      const nextSnapshot = getSnapshot(source[TARGET]);\n      setState(prev => {\n        if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {\n          return prev;\n        }\n\n        if (prev[4] === nextSnapshot) {\n          return prev;\n        }\n\n        return [\n        /* [0] */\n        prev[0],\n        /* [1] */\n        prev[1],\n        /* [2] */\n        prev[2],\n        /* [3] */\n        nextVersion,\n        /* [4] */\n        nextSnapshot];\n      });\n    };\n\n    const unsubscribe = subscribe(source[TARGET], checkForUpdates);\n    checkForUpdates();\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [source, getSnapshot, subscribe]);\n  return currentSnapshot;\n};\n\nconst VERSION = Symbol();\nconst LISTENERS = Symbol();\nconst SNAPSHOT = Symbol();\nconst PROMISE_RESULT = Symbol();\nconst PROMISE_ERROR = Symbol();\nconst refSet = new WeakSet();\n\nconst ref = o => {\n  refSet.add(o);\n  return o;\n};\n\nconst isSupportedObject = x => typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n\nconst proxyCache = new WeakMap();\nlet globalVersion = 1;\nconst snapshotCache = new WeakMap();\n\nconst proxy = (initialObject = {}) => {\n  if (!isSupportedObject(initialObject)) {\n    throw new Error('unsupported object type');\n  }\n\n  if (proxyCache.has(initialObject)) {\n    return proxyCache.get(initialObject);\n  }\n\n  let version = globalVersion;\n  const listeners = new Set();\n\n  const notifyUpdate = nextVersion => {\n    if (!nextVersion) {\n      nextVersion = ++globalVersion;\n    }\n\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach(listener => listener(nextVersion));\n    }\n  };\n\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const p = new Proxy(baseObject, {\n    get(target, prop, receiver) {\n      if (prop === VERSION) {\n        return version;\n      }\n\n      if (prop === LISTENERS) {\n        return listeners;\n      }\n\n      if (prop === SNAPSHOT) {\n        const cache = snapshotCache.get(receiver);\n\n        if (cache && cache.version === version) {\n          return cache.snapshot;\n        }\n\n        const snapshot = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n        markToTrack(snapshot, true); // mark to track\n\n        snapshotCache.set(receiver, {\n          version,\n          snapshot\n        });\n        Reflect.ownKeys(target).forEach(key => {\n          const value = target[key];\n\n          if (refSet.has(value)) {\n            markToTrack(value, false); // mark not to track\n\n            snapshot[key] = value;\n          } else if (!isSupportedObject(value)) {\n            snapshot[key] = value;\n          } else if (value instanceof Promise) {\n            if (PROMISE_RESULT in value) {\n              snapshot[key] = value[PROMISE_RESULT];\n            } else {\n              const errorOrPromise = value[PROMISE_ERROR] || value;\n              Object.defineProperty(snapshot, key, {\n                get() {\n                  throw errorOrPromise;\n                }\n\n              });\n            }\n          } else if (value[VERSION]) {\n            snapshot[key] = value[SNAPSHOT];\n          } else {\n            snapshot[key] = value;\n          }\n        });\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          Object.freeze(snapshot);\n        }\n\n        return snapshot;\n      }\n\n      return target[prop];\n    },\n\n    deleteProperty(target, prop) {\n      const prevValue = target[prop];\n      const childListeners = prevValue && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      const deleted = Reflect.deleteProperty(target, prop);\n\n      if (deleted) {\n        notifyUpdate();\n      }\n\n      return deleted;\n    },\n\n    set(target, prop, value) {\n      const prevValue = target[prop];\n\n      if (Object.is(prevValue, value)) {\n        return true;\n      }\n\n      const childListeners = prevValue && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      if (refSet.has(value) || !isSupportedObject(value)) {\n        target[prop] = value;\n      } else if (value instanceof Promise) {\n        target[prop] = value.then(v => {\n          target[prop][PROMISE_RESULT] = v;\n          notifyUpdate();\n        }).catch(e => {\n          target[prop][PROMISE_ERROR] = e;\n          notifyUpdate();\n        });\n      } else {\n        value = getUntrackedObject(value) || value;\n\n        if (value[LISTENERS]) {\n          target[prop] = value;\n        } else {\n          target[prop] = proxy(value);\n        }\n\n        target[prop][LISTENERS].add(notifyUpdate);\n      }\n\n      notifyUpdate();\n      return true;\n    }\n\n  });\n  proxyCache.set(initialObject, p);\n  Reflect.ownKeys(initialObject).forEach(key => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n\n    if (desc.get) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      p[key] = initialObject[key];\n    }\n  });\n  return p;\n};\n\nconst getVersion = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[VERSION])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[VERSION];\n};\n\nconst subscribe = (p, callback, notifyInSync) => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[LISTENERS])) {\n    throw new Error('Please use proxy object');\n  }\n\n  let pendingVersion = 0;\n\n  const listener = nextVersion => {\n    if (notifyInSync) {\n      callback();\n      return;\n    }\n\n    pendingVersion = nextVersion;\n    Promise.resolve().then(() => {\n      if (nextVersion === pendingVersion) {\n        callback();\n      }\n    });\n  };\n\n  p[LISTENERS].add(listener);\n  return () => {\n    p[LISTENERS].delete(listener);\n  };\n};\n\nconst snapshot = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[SNAPSHOT])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[SNAPSHOT];\n};\n\nconst isSSR = typeof window === 'undefined' || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);\nconst useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = useRef();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(pathList.current);\n};\n\nconst mutableSourceCache = new WeakMap();\n\nconst getMutableSource = p => {\n  if (!mutableSourceCache.has(p)) {\n    mutableSourceCache.set(p, createMutableSource(p, getVersion));\n  }\n\n  return mutableSourceCache.get(p);\n};\n\nconst useProxy = (p, options) => {\n  const _useReducer = useReducer(c => c + 1, 0),\n        _useReducer2 = _slicedToArray(_useReducer, 2),\n        forceUpdate = _useReducer2[1];\n\n  const affected = new WeakMap();\n  const lastAffected = useRef();\n  const prevSnapshot = useRef();\n  const lastSnapshot = useRef();\n  useIsomorphicLayoutEffect(() => {\n    lastSnapshot.current = prevSnapshot.current = snapshot(p);\n  }, [p]);\n  useIsomorphicLayoutEffect(() => {\n    lastAffected.current = affected;\n\n    if (prevSnapshot.current !== lastSnapshot.current && isDeepChanged(prevSnapshot.current, lastSnapshot.current, affected, new WeakMap())) {\n      prevSnapshot.current = lastSnapshot.current;\n      forceUpdate();\n    }\n  });\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const sub = useCallback((p, cb) => subscribe(p, () => {\n    const nextSnapshot = snapshot(p);\n    lastSnapshot.current = nextSnapshot;\n\n    try {\n      if (lastAffected.current && !isDeepChanged(prevSnapshot.current, nextSnapshot, lastAffected.current, new WeakMap())) {\n        // not changed\n        return;\n      }\n    } catch (e) {// ignore if a promise or something is thrown\n    }\n\n    prevSnapshot.current = nextSnapshot;\n    cb();\n  }, notifyInSync), [notifyInSync]);\n  const currSnapshot = useMutableSource(getMutableSource(p), snapshot, sub);\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAffectedDebugValue(currSnapshot, affected);\n  }\n\n  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n\n  return createDeepProxy(currSnapshot, affected, proxyCache);\n};\n\nexport { proxy, ref, snapshot, subscribe, useProxy };","map":{"version":3,"sources":["/Users/artemis/Desktop/r3f-basic-demo-forked (1)/node_modules/valtio/index.js"],"names":["useRef","useState","useEffect","useReducer","useCallback","useMemo","useLayoutEffect","useDebugValue","markToTrack","getUntrackedObject","isDeepChanged","createDeepProxy","affectedToPathList","TARGET","Symbol","GET_VERSION","createMutableSource","target","getVersion","useMutableSource","source","getSnapshot","subscribe","lastVersion","currentVersion","state","setState","currentSnapshot","current","didUnsubscribe","checkForUpdates","nextVersion","nextSnapshot","prev","unsubscribe","VERSION","LISTENERS","SNAPSHOT","PROMISE_RESULT","PROMISE_ERROR","refSet","WeakSet","ref","o","add","isSupportedObject","x","Array","isArray","iterator","WeakMap","Error","Number","Date","String","RegExp","ArrayBuffer","proxyCache","globalVersion","snapshotCache","proxy","initialObject","has","get","version","listeners","Set","notifyUpdate","forEach","listener","baseObject","Object","create","getPrototypeOf","p","Proxy","prop","receiver","cache","snapshot","set","Reflect","ownKeys","key","value","Promise","errorOrPromise","defineProperty","process","env","NODE_ENV","freeze","deleteProperty","prevValue","childListeners","delete","deleted","is","then","v","catch","e","desc","getOwnPropertyDescriptor","callback","notifyInSync","pendingVersion","resolve","isSSR","window","test","navigator","userAgent","useIsomorphicLayoutEffect","useAffectedDebugValue","affected","pathList","mutableSourceCache","getMutableSource","useProxy","options","c","forceUpdate","lastAffected","prevSnapshot","lastSnapshot","sync","sub","cb","currSnapshot"],"mappings":";AAAA,SAASA,MAAT,EAAiBC,QAAjB,EAA2BC,SAA3B,EAAsCC,UAAtC,EAAkDC,WAAlD,EAA+DC,OAA/D,EAAwEC,eAAxE,EAAyFC,aAAzF,QAA8G,OAA9G;AACA,SAASC,WAAT,EAAsBC,kBAAtB,EAA0CC,aAA1C,EAAyDC,eAAzD,EAA0EC,kBAA1E,QAAoG,eAApG;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,MAAM,GAAGC,MAAM,EAArB;AACA,MAAMC,WAAW,GAAGD,MAAM,EAA1B;;AACA,MAAME,mBAAmB,GAAG,CAACC,MAAD,EAASC,UAAT,MAAyB;AACnD,GAACL,MAAD,GAAUI,MADyC;AAEnD,GAACF,WAAD,GAAeG;AAFoC,CAAzB,CAA5B;;AAIA,MAAMC,gBAAgB,GAAG,CAACC,MAAD,EAASC,WAAT,EAAsBC,SAAtB,KAAoC;AAC3D,QAAMC,WAAW,GAAGvB,MAAM,CAAC,CAAD,CAA1B;AACA,QAAMwB,cAAc,GAAGJ,MAAM,CAACL,WAAD,CAAN,CAAoBK,MAAM,CAACP,MAAD,CAA1B,CAAvB;;AAF2D,oBAGjCZ,QAAQ,CAAC,MAAM;AACzC;AACAmB,EAAAA,MAFyC;AAGzC;AACAC,EAAAA,WAJyC;AAKzC;AACAC,EAAAA,SANyC;AAOzC;AACAE,EAAAA,cARyC;AASzC;AACAH,EAAAA,WAAW,CAACD,MAAM,CAACP,MAAD,CAAP,CAV8B,CAAP,CAHyB;AAAA;AAAA,QAGpDY,KAHoD;AAAA,QAG7CC,QAH6C;;AAc3D,MAAIC,eAAe,GAAGF,KAAK,CAAC,CAAD,CAA3B;;AAEA,MAAIA,KAAK,CAAC,CAAD,CAAL,KAAaL,MAAb,IAAuBK,KAAK,CAAC,CAAD,CAAL,KAAaJ,WAApC,IAAmDI,KAAK,CAAC,CAAD,CAAL,KAAaH,SAAhE,IAA6EE,cAAc,KAAKC,KAAK,CAAC,CAAD,CAAxB,IAA+BD,cAAc,KAAKD,WAAW,CAACK,OAA/I,EAAwJ;AACtJD,IAAAA,eAAe,GAAGN,WAAW,CAACD,MAAM,CAACP,MAAD,CAAP,CAA7B;AACAa,IAAAA,QAAQ,CAAC;AACT;AACAN,IAAAA,MAFS;AAGT;AACAC,IAAAA,WAJS;AAKT;AACAC,IAAAA,SANS;AAOT;AACAE,IAAAA,cARS;AAST;AACAG,IAAAA,eAVS,CAAD,CAAR;AAWD;;AAEDzB,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI2B,cAAc,GAAG,KAArB;;AAEA,UAAMC,eAAe,GAAG,MAAM;AAC5B,UAAID,cAAJ,EAAoB;AAClB;AACD;;AAED,YAAME,WAAW,GAAGX,MAAM,CAACL,WAAD,CAAN,CAAoBK,MAAM,CAACP,MAAD,CAA1B,CAApB;AACAU,MAAAA,WAAW,CAACK,OAAZ,GAAsBG,WAAtB;AACA,YAAMC,YAAY,GAAGX,WAAW,CAACD,MAAM,CAACP,MAAD,CAAP,CAAhC;AACAa,MAAAA,QAAQ,CAACO,IAAI,IAAI;AACf,YAAIA,IAAI,CAAC,CAAD,CAAJ,KAAYb,MAAZ,IAAsBa,IAAI,CAAC,CAAD,CAAJ,KAAYZ,WAAlC,IAAiDY,IAAI,CAAC,CAAD,CAAJ,KAAYX,SAAjE,EAA4E;AAC1E,iBAAOW,IAAP;AACD;;AAED,YAAIA,IAAI,CAAC,CAAD,CAAJ,KAAYD,YAAhB,EAA8B;AAC5B,iBAAOC,IAAP;AACD;;AAED,eAAO;AACP;AACAA,QAAAA,IAAI,CAAC,CAAD,CAFG;AAGP;AACAA,QAAAA,IAAI,CAAC,CAAD,CAJG;AAKP;AACAA,QAAAA,IAAI,CAAC,CAAD,CANG;AAOP;AACAF,QAAAA,WARO;AASP;AACAC,QAAAA,YAVO,CAAP;AAWD,OApBO,CAAR;AAqBD,KA7BD;;AA+BA,UAAME,WAAW,GAAGZ,SAAS,CAACF,MAAM,CAACP,MAAD,CAAP,EAAiBiB,eAAjB,CAA7B;AACAA,IAAAA,eAAe;AACf,WAAO,MAAM;AACXD,MAAAA,cAAc,GAAG,IAAjB;AACAK,MAAAA,WAAW;AACZ,KAHD;AAID,GAxCQ,EAwCN,CAACd,MAAD,EAASC,WAAT,EAAsBC,SAAtB,CAxCM,CAAT;AAyCA,SAAOK,eAAP;AACD,CAzED;;AA2EA,MAAMQ,OAAO,GAAGrB,MAAM,EAAtB;AACA,MAAMsB,SAAS,GAAGtB,MAAM,EAAxB;AACA,MAAMuB,QAAQ,GAAGvB,MAAM,EAAvB;AACA,MAAMwB,cAAc,GAAGxB,MAAM,EAA7B;AACA,MAAMyB,aAAa,GAAGzB,MAAM,EAA5B;AACA,MAAM0B,MAAM,GAAG,IAAIC,OAAJ,EAAf;;AACA,MAAMC,GAAG,GAAGC,CAAC,IAAI;AACfH,EAAAA,MAAM,CAACI,GAAP,CAAWD,CAAX;AACA,SAAOA,CAAP;AACD,CAHD;;AAKA,MAAME,iBAAiB,GAAGC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,IAA/B,KAAwCC,KAAK,CAACC,OAAN,CAAcF,CAAd,KAAoB,CAACA,CAAC,CAAChC,MAAM,CAACmC,QAAR,CAA9D,KAAoF,EAAEH,CAAC,YAAYI,OAAf,CAApF,IAA+G,EAAEJ,CAAC,YAAYL,OAAf,CAA/G,IAA0I,EAAEK,CAAC,YAAYK,KAAf,CAA1I,IAAmK,EAAEL,CAAC,YAAYM,MAAf,CAAnK,IAA6L,EAAEN,CAAC,YAAYO,IAAf,CAA7L,IAAqN,EAAEP,CAAC,YAAYQ,MAAf,CAArN,IAA+O,EAAER,CAAC,YAAYS,MAAf,CAA/O,IAAyQ,EAAET,CAAC,YAAYU,WAAf,CAAxS;;AAEA,MAAMC,UAAU,GAAG,IAAIP,OAAJ,EAAnB;AACA,IAAIQ,aAAa,GAAG,CAApB;AACA,MAAMC,aAAa,GAAG,IAAIT,OAAJ,EAAtB;;AACA,MAAMU,KAAK,GAAG,CAACC,aAAa,GAAG,EAAjB,KAAwB;AACpC,MAAI,CAAChB,iBAAiB,CAACgB,aAAD,CAAtB,EAAuC;AACrC,UAAM,IAAIV,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,MAAIM,UAAU,CAACK,GAAX,CAAeD,aAAf,CAAJ,EAAmC;AACjC,WAAOJ,UAAU,CAACM,GAAX,CAAeF,aAAf,CAAP;AACD;;AAED,MAAIG,OAAO,GAAGN,aAAd;AACA,QAAMO,SAAS,GAAG,IAAIC,GAAJ,EAAlB;;AAEA,QAAMC,YAAY,GAAGpC,WAAW,IAAI;AAClC,QAAI,CAACA,WAAL,EAAkB;AAChBA,MAAAA,WAAW,GAAG,EAAE2B,aAAhB;AACD;;AAED,QAAIM,OAAO,KAAKjC,WAAhB,EAA6B;AAC3BiC,MAAAA,OAAO,GAAGjC,WAAV;AACAkC,MAAAA,SAAS,CAACG,OAAV,CAAkBC,QAAQ,IAAIA,QAAQ,CAACtC,WAAD,CAAtC;AACD;AACF,GATD;;AAWA,QAAMuC,UAAU,GAAGvB,KAAK,CAACC,OAAN,CAAca,aAAd,IAA+B,EAA/B,GAAoCU,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,cAAP,CAAsBZ,aAAtB,CAAd,CAAvD;AACA,QAAMa,CAAC,GAAG,IAAIC,KAAJ,CAAUL,UAAV,EAAsB;AAC9BP,IAAAA,GAAG,CAAC9C,MAAD,EAAS2D,IAAT,EAAeC,QAAf,EAAyB;AAC1B,UAAID,IAAI,KAAKzC,OAAb,EAAsB;AACpB,eAAO6B,OAAP;AACD;;AAED,UAAIY,IAAI,KAAKxC,SAAb,EAAwB;AACtB,eAAO6B,SAAP;AACD;;AAED,UAAIW,IAAI,KAAKvC,QAAb,EAAuB;AACrB,cAAMyC,KAAK,GAAGnB,aAAa,CAACI,GAAd,CAAkBc,QAAlB,CAAd;;AAEA,YAAIC,KAAK,IAAIA,KAAK,CAACd,OAAN,KAAkBA,OAA/B,EAAwC;AACtC,iBAAOc,KAAK,CAACC,QAAb;AACD;;AAED,cAAMA,QAAQ,GAAGhC,KAAK,CAACC,OAAN,CAAc/B,MAAd,IAAwB,EAAxB,GAA6BsD,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,cAAP,CAAsBxD,MAAtB,CAAd,CAA9C;AACAT,QAAAA,WAAW,CAACuE,QAAD,EAAW,IAAX,CAAX,CARqB,CAQQ;;AAE7BpB,QAAAA,aAAa,CAACqB,GAAd,CAAkBH,QAAlB,EAA4B;AAC1Bb,UAAAA,OAD0B;AAE1Be,UAAAA;AAF0B,SAA5B;AAIAE,QAAAA,OAAO,CAACC,OAAR,CAAgBjE,MAAhB,EAAwBmD,OAAxB,CAAgCe,GAAG,IAAI;AACrC,gBAAMC,KAAK,GAAGnE,MAAM,CAACkE,GAAD,CAApB;;AAEA,cAAI3C,MAAM,CAACsB,GAAP,CAAWsB,KAAX,CAAJ,EAAuB;AACrB5E,YAAAA,WAAW,CAAC4E,KAAD,EAAQ,KAAR,CAAX,CADqB,CACM;;AAE3BL,YAAAA,QAAQ,CAACI,GAAD,CAAR,GAAgBC,KAAhB;AACD,WAJD,MAIO,IAAI,CAACvC,iBAAiB,CAACuC,KAAD,CAAtB,EAA+B;AACpCL,YAAAA,QAAQ,CAACI,GAAD,CAAR,GAAgBC,KAAhB;AACD,WAFM,MAEA,IAAIA,KAAK,YAAYC,OAArB,EAA8B;AACnC,gBAAI/C,cAAc,IAAI8C,KAAtB,EAA6B;AAC3BL,cAAAA,QAAQ,CAACI,GAAD,CAAR,GAAgBC,KAAK,CAAC9C,cAAD,CAArB;AACD,aAFD,MAEO;AACL,oBAAMgD,cAAc,GAAGF,KAAK,CAAC7C,aAAD,CAAL,IAAwB6C,KAA/C;AACAb,cAAAA,MAAM,CAACgB,cAAP,CAAsBR,QAAtB,EAAgCI,GAAhC,EAAqC;AACnCpB,gBAAAA,GAAG,GAAG;AACJ,wBAAMuB,cAAN;AACD;;AAHkC,eAArC;AAMD;AACF,WAZM,MAYA,IAAIF,KAAK,CAACjD,OAAD,CAAT,EAAoB;AACzB4C,YAAAA,QAAQ,CAACI,GAAD,CAAR,GAAgBC,KAAK,CAAC/C,QAAD,CAArB;AACD,WAFM,MAEA;AACL0C,YAAAA,QAAQ,CAACI,GAAD,CAAR,GAAgBC,KAAhB;AACD;AACF,SA1BD;;AA4BA,YAAI,OAAOI,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA5D,EAA0E;AACxEnB,UAAAA,MAAM,CAACoB,MAAP,CAAcZ,QAAd;AACD;;AAED,eAAOA,QAAP;AACD;;AAED,aAAO9D,MAAM,CAAC2D,IAAD,CAAb;AACD,KA5D6B;;AA8D9BgB,IAAAA,cAAc,CAAC3E,MAAD,EAAS2D,IAAT,EAAe;AAC3B,YAAMiB,SAAS,GAAG5E,MAAM,CAAC2D,IAAD,CAAxB;AACA,YAAMkB,cAAc,GAAGD,SAAS,IAAIA,SAAS,CAACzD,SAAD,CAA7C;;AAEA,UAAI0D,cAAJ,EAAoB;AAClBA,QAAAA,cAAc,CAACC,MAAf,CAAsB5B,YAAtB;AACD;;AAED,YAAM6B,OAAO,GAAGf,OAAO,CAACW,cAAR,CAAuB3E,MAAvB,EAA+B2D,IAA/B,CAAhB;;AAEA,UAAIoB,OAAJ,EAAa;AACX7B,QAAAA,YAAY;AACb;;AAED,aAAO6B,OAAP;AACD,KA7E6B;;AA+E9BhB,IAAAA,GAAG,CAAC/D,MAAD,EAAS2D,IAAT,EAAeQ,KAAf,EAAsB;AACvB,YAAMS,SAAS,GAAG5E,MAAM,CAAC2D,IAAD,CAAxB;;AAEA,UAAIL,MAAM,CAAC0B,EAAP,CAAUJ,SAAV,EAAqBT,KAArB,CAAJ,EAAiC;AAC/B,eAAO,IAAP;AACD;;AAED,YAAMU,cAAc,GAAGD,SAAS,IAAIA,SAAS,CAACzD,SAAD,CAA7C;;AAEA,UAAI0D,cAAJ,EAAoB;AAClBA,QAAAA,cAAc,CAACC,MAAf,CAAsB5B,YAAtB;AACD;;AAED,UAAI3B,MAAM,CAACsB,GAAP,CAAWsB,KAAX,KAAqB,CAACvC,iBAAiB,CAACuC,KAAD,CAA3C,EAAoD;AAClDnE,QAAAA,MAAM,CAAC2D,IAAD,CAAN,GAAeQ,KAAf;AACD,OAFD,MAEO,IAAIA,KAAK,YAAYC,OAArB,EAA8B;AACnCpE,QAAAA,MAAM,CAAC2D,IAAD,CAAN,GAAeQ,KAAK,CAACc,IAAN,CAAWC,CAAC,IAAI;AAC7BlF,UAAAA,MAAM,CAAC2D,IAAD,CAAN,CAAatC,cAAb,IAA+B6D,CAA/B;AACAhC,UAAAA,YAAY;AACb,SAHc,EAGZiC,KAHY,CAGNC,CAAC,IAAI;AACZpF,UAAAA,MAAM,CAAC2D,IAAD,CAAN,CAAarC,aAAb,IAA8B8D,CAA9B;AACAlC,UAAAA,YAAY;AACb,SANc,CAAf;AAOD,OARM,MAQA;AACLiB,QAAAA,KAAK,GAAG3E,kBAAkB,CAAC2E,KAAD,CAAlB,IAA6BA,KAArC;;AAEA,YAAIA,KAAK,CAAChD,SAAD,CAAT,EAAsB;AACpBnB,UAAAA,MAAM,CAAC2D,IAAD,CAAN,GAAeQ,KAAf;AACD,SAFD,MAEO;AACLnE,UAAAA,MAAM,CAAC2D,IAAD,CAAN,GAAehB,KAAK,CAACwB,KAAD,CAApB;AACD;;AAEDnE,QAAAA,MAAM,CAAC2D,IAAD,CAAN,CAAaxC,SAAb,EAAwBQ,GAAxB,CAA4BuB,YAA5B;AACD;;AAEDA,MAAAA,YAAY;AACZ,aAAO,IAAP;AACD;;AApH6B,GAAtB,CAAV;AAuHAV,EAAAA,UAAU,CAACuB,GAAX,CAAenB,aAAf,EAA8Ba,CAA9B;AACAO,EAAAA,OAAO,CAACC,OAAR,CAAgBrB,aAAhB,EAA+BO,OAA/B,CAAuCe,GAAG,IAAI;AAC5C,UAAMmB,IAAI,GAAG/B,MAAM,CAACgC,wBAAP,CAAgC1C,aAAhC,EAA+CsB,GAA/C,CAAb;;AAEA,QAAImB,IAAI,CAACvC,GAAT,EAAc;AACZQ,MAAAA,MAAM,CAACgB,cAAP,CAAsBjB,UAAtB,EAAkCa,GAAlC,EAAuCmB,IAAvC;AACD,KAFD,MAEO;AACL5B,MAAAA,CAAC,CAACS,GAAD,CAAD,GAAStB,aAAa,CAACsB,GAAD,CAAtB;AACD;AACF,GARD;AASA,SAAOT,CAAP;AACD,CA1JD;;AA2JA,MAAMxD,UAAU,GAAGwD,CAAC,IAAI;AACtB,MAAI,OAAOc,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAxD,KAAyE,CAAChB,CAAD,IAAM,CAACA,CAAC,CAACvC,OAAD,CAAjF,CAAJ,EAAiG;AAC/F,UAAM,IAAIgB,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,SAAOuB,CAAC,CAACvC,OAAD,CAAR;AACD,CAND;;AAOA,MAAMb,SAAS,GAAG,CAACoD,CAAD,EAAI8B,QAAJ,EAAcC,YAAd,KAA+B;AAC/C,MAAI,OAAOjB,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAxD,KAAyE,CAAChB,CAAD,IAAM,CAACA,CAAC,CAACtC,SAAD,CAAjF,CAAJ,EAAmG;AACjG,UAAM,IAAIe,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,MAAIuD,cAAc,GAAG,CAArB;;AAEA,QAAMrC,QAAQ,GAAGtC,WAAW,IAAI;AAC9B,QAAI0E,YAAJ,EAAkB;AAChBD,MAAAA,QAAQ;AACR;AACD;;AAEDE,IAAAA,cAAc,GAAG3E,WAAjB;AACAsD,IAAAA,OAAO,CAACsB,OAAR,GAAkBT,IAAlB,CAAuB,MAAM;AAC3B,UAAInE,WAAW,KAAK2E,cAApB,EAAoC;AAClCF,QAAAA,QAAQ;AACT;AACF,KAJD;AAKD,GAZD;;AAcA9B,EAAAA,CAAC,CAACtC,SAAD,CAAD,CAAaQ,GAAb,CAAiByB,QAAjB;AACA,SAAO,MAAM;AACXK,IAAAA,CAAC,CAACtC,SAAD,CAAD,CAAa2D,MAAb,CAAoB1B,QAApB;AACD,GAFD;AAGD,CAzBD;;AA0BA,MAAMU,QAAQ,GAAGL,CAAC,IAAI;AACpB,MAAI,OAAOc,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAxD,KAAyE,CAAChB,CAAD,IAAM,CAACA,CAAC,CAACrC,QAAD,CAAjF,CAAJ,EAAkG;AAChG,UAAM,IAAIc,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,SAAOuB,CAAC,CAACrC,QAAD,CAAR;AACD,CAND;;AAQA,MAAMuE,KAAK,GAAG,OAAOC,MAAP,KAAkB,WAAlB,IAAiC,sBAAsBC,IAAtB,CAA2BD,MAAM,CAACE,SAAP,IAAoBF,MAAM,CAACE,SAAP,CAAiBC,SAAhE,CAA/C;AACA,MAAMC,yBAAyB,GAAGL,KAAK,GAAG1G,SAAH,GAAeI,eAAtD;;AAEA,MAAM4G,qBAAqB,GAAG,CAACzF,KAAD,EAAQ0F,QAAR,KAAqB;AACjD,QAAMC,QAAQ,GAAGpH,MAAM,EAAvB;AACAE,EAAAA,SAAS,CAAC,MAAM;AACdkH,IAAAA,QAAQ,CAACxF,OAAT,GAAmBhB,kBAAkB,CAACa,KAAD,EAAQ0F,QAAR,CAArC;AACD,GAFQ,CAAT;AAGA5G,EAAAA,aAAa,CAAC6G,QAAQ,CAACxF,OAAV,CAAb;AACD,CAND;;AAQA,MAAMyF,kBAAkB,GAAG,IAAInE,OAAJ,EAA3B;;AAEA,MAAMoE,gBAAgB,GAAG5C,CAAC,IAAI;AAC5B,MAAI,CAAC2C,kBAAkB,CAACvD,GAAnB,CAAuBY,CAAvB,CAAL,EAAgC;AAC9B2C,IAAAA,kBAAkB,CAACrC,GAAnB,CAAuBN,CAAvB,EAA0B1D,mBAAmB,CAAC0D,CAAD,EAAIxD,UAAJ,CAA7C;AACD;;AAED,SAAOmG,kBAAkB,CAACtD,GAAnB,CAAuBW,CAAvB,CAAP;AACD,CAND;;AAQA,MAAM6C,QAAQ,GAAG,CAAC7C,CAAD,EAAI8C,OAAJ,KAAgB;AAAA,sBACPrH,UAAU,CAACsH,CAAC,IAAIA,CAAC,GAAG,CAAV,EAAa,CAAb,CADH;AAAA;AAAA,QACtBC,WADsB;;AAE/B,QAAMP,QAAQ,GAAG,IAAIjE,OAAJ,EAAjB;AACA,QAAMyE,YAAY,GAAG3H,MAAM,EAA3B;AACA,QAAM4H,YAAY,GAAG5H,MAAM,EAA3B;AACA,QAAM6H,YAAY,GAAG7H,MAAM,EAA3B;AACAiH,EAAAA,yBAAyB,CAAC,MAAM;AAC9BY,IAAAA,YAAY,CAACjG,OAAb,GAAuBgG,YAAY,CAAChG,OAAb,GAAuBmD,QAAQ,CAACL,CAAD,CAAtD;AACD,GAFwB,EAEtB,CAACA,CAAD,CAFsB,CAAzB;AAGAuC,EAAAA,yBAAyB,CAAC,MAAM;AAC9BU,IAAAA,YAAY,CAAC/F,OAAb,GAAuBuF,QAAvB;;AAEA,QAAIS,YAAY,CAAChG,OAAb,KAAyBiG,YAAY,CAACjG,OAAtC,IAAiDlB,aAAa,CAACkH,YAAY,CAAChG,OAAd,EAAuBiG,YAAY,CAACjG,OAApC,EAA6CuF,QAA7C,EAAuD,IAAIjE,OAAJ,EAAvD,CAAlE,EAAyI;AACvI0E,MAAAA,YAAY,CAAChG,OAAb,GAAuBiG,YAAY,CAACjG,OAApC;AACA8F,MAAAA,WAAW;AACZ;AACF,GAPwB,CAAzB;AAQA,QAAMjB,YAAY,GAAGe,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACM,IAAxD;AACA,QAAMC,GAAG,GAAG3H,WAAW,CAAC,CAACsE,CAAD,EAAIsD,EAAJ,KAAW1G,SAAS,CAACoD,CAAD,EAAI,MAAM;AACpD,UAAM1C,YAAY,GAAG+C,QAAQ,CAACL,CAAD,CAA7B;AACAmD,IAAAA,YAAY,CAACjG,OAAb,GAAuBI,YAAvB;;AAEA,QAAI;AACF,UAAI2F,YAAY,CAAC/F,OAAb,IAAwB,CAAClB,aAAa,CAACkH,YAAY,CAAChG,OAAd,EAAuBI,YAAvB,EAAqC2F,YAAY,CAAC/F,OAAlD,EAA2D,IAAIsB,OAAJ,EAA3D,CAA1C,EAAqH;AACnH;AACA;AACD;AACF,KALD,CAKE,OAAOmD,CAAP,EAAU,CAAC;AACZ;;AAEDuB,IAAAA,YAAY,CAAChG,OAAb,GAAuBI,YAAvB;AACAgG,IAAAA,EAAE;AACH,GAd2C,EAczCvB,YAdyC,CAArB,EAcL,CAACA,YAAD,CAdK,CAAvB;AAeA,QAAMwB,YAAY,GAAG9G,gBAAgB,CAACmG,gBAAgB,CAAC5C,CAAD,CAAjB,EAAsBK,QAAtB,EAAgCgD,GAAhC,CAArC;;AAEA,MAAI,OAAOvC,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA5D,EAA0E;AACxE;AACAwB,IAAAA,qBAAqB,CAACe,YAAD,EAAed,QAAf,CAArB;AACD;;AAED,QAAM1D,UAAU,GAAGpD,OAAO,CAAC,MAAM,IAAI6C,OAAJ,EAAP,EAAsB,EAAtB,CAA1B,CAxC+B,CAwCsB;;AAErD,SAAOvC,eAAe,CAACsH,YAAD,EAAed,QAAf,EAAyB1D,UAAzB,CAAtB;AACD,CA3CD;;AA6CA,SAASG,KAAT,EAAgBlB,GAAhB,EAAqBqC,QAArB,EAA+BzD,SAA/B,EAA0CiG,QAA1C","sourcesContent":["import { useRef, useState, useEffect, useReducer, useCallback, useMemo, useLayoutEffect, useDebugValue } from 'react';\nimport { markToTrack, getUntrackedObject, isDeepChanged, createDeepProxy, affectedToPathList } from 'proxy-compare';\n\n/*\nexport {\n  unstable_createMutableSource as createMutableSource,\n  unstable_useMutableSource as useMutableSource,\n} from 'react'\n*/\nconst TARGET = Symbol();\nconst GET_VERSION = Symbol();\nconst createMutableSource = (target, getVersion) => ({\n  [TARGET]: target,\n  [GET_VERSION]: getVersion\n});\nconst useMutableSource = (source, getSnapshot, subscribe) => {\n  const lastVersion = useRef(0);\n  const currentVersion = source[GET_VERSION](source[TARGET]);\n  const [state, setState] = useState(() => [\n  /* [0] */\n  source,\n  /* [1] */\n  getSnapshot,\n  /* [2] */\n  subscribe,\n  /* [3] */\n  currentVersion,\n  /* [4] */\n  getSnapshot(source[TARGET])]);\n  let currentSnapshot = state[4];\n\n  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe || currentVersion !== state[3] && currentVersion !== lastVersion.current) {\n    currentSnapshot = getSnapshot(source[TARGET]);\n    setState([\n    /* [0] */\n    source,\n    /* [1] */\n    getSnapshot,\n    /* [2] */\n    subscribe,\n    /* [3] */\n    currentVersion,\n    /* [4] */\n    currentSnapshot]);\n  }\n\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      if (didUnsubscribe) {\n        return;\n      }\n\n      const nextVersion = source[GET_VERSION](source[TARGET]);\n      lastVersion.current = nextVersion;\n      const nextSnapshot = getSnapshot(source[TARGET]);\n      setState(prev => {\n        if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {\n          return prev;\n        }\n\n        if (prev[4] === nextSnapshot) {\n          return prev;\n        }\n\n        return [\n        /* [0] */\n        prev[0],\n        /* [1] */\n        prev[1],\n        /* [2] */\n        prev[2],\n        /* [3] */\n        nextVersion,\n        /* [4] */\n        nextSnapshot];\n      });\n    };\n\n    const unsubscribe = subscribe(source[TARGET], checkForUpdates);\n    checkForUpdates();\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [source, getSnapshot, subscribe]);\n  return currentSnapshot;\n};\n\nconst VERSION = Symbol();\nconst LISTENERS = Symbol();\nconst SNAPSHOT = Symbol();\nconst PROMISE_RESULT = Symbol();\nconst PROMISE_ERROR = Symbol();\nconst refSet = new WeakSet();\nconst ref = o => {\n  refSet.add(o);\n  return o;\n};\n\nconst isSupportedObject = x => typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n\nconst proxyCache = new WeakMap();\nlet globalVersion = 1;\nconst snapshotCache = new WeakMap();\nconst proxy = (initialObject = {}) => {\n  if (!isSupportedObject(initialObject)) {\n    throw new Error('unsupported object type');\n  }\n\n  if (proxyCache.has(initialObject)) {\n    return proxyCache.get(initialObject);\n  }\n\n  let version = globalVersion;\n  const listeners = new Set();\n\n  const notifyUpdate = nextVersion => {\n    if (!nextVersion) {\n      nextVersion = ++globalVersion;\n    }\n\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach(listener => listener(nextVersion));\n    }\n  };\n\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const p = new Proxy(baseObject, {\n    get(target, prop, receiver) {\n      if (prop === VERSION) {\n        return version;\n      }\n\n      if (prop === LISTENERS) {\n        return listeners;\n      }\n\n      if (prop === SNAPSHOT) {\n        const cache = snapshotCache.get(receiver);\n\n        if (cache && cache.version === version) {\n          return cache.snapshot;\n        }\n\n        const snapshot = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n        markToTrack(snapshot, true); // mark to track\n\n        snapshotCache.set(receiver, {\n          version,\n          snapshot\n        });\n        Reflect.ownKeys(target).forEach(key => {\n          const value = target[key];\n\n          if (refSet.has(value)) {\n            markToTrack(value, false); // mark not to track\n\n            snapshot[key] = value;\n          } else if (!isSupportedObject(value)) {\n            snapshot[key] = value;\n          } else if (value instanceof Promise) {\n            if (PROMISE_RESULT in value) {\n              snapshot[key] = value[PROMISE_RESULT];\n            } else {\n              const errorOrPromise = value[PROMISE_ERROR] || value;\n              Object.defineProperty(snapshot, key, {\n                get() {\n                  throw errorOrPromise;\n                }\n\n              });\n            }\n          } else if (value[VERSION]) {\n            snapshot[key] = value[SNAPSHOT];\n          } else {\n            snapshot[key] = value;\n          }\n        });\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          Object.freeze(snapshot);\n        }\n\n        return snapshot;\n      }\n\n      return target[prop];\n    },\n\n    deleteProperty(target, prop) {\n      const prevValue = target[prop];\n      const childListeners = prevValue && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      const deleted = Reflect.deleteProperty(target, prop);\n\n      if (deleted) {\n        notifyUpdate();\n      }\n\n      return deleted;\n    },\n\n    set(target, prop, value) {\n      const prevValue = target[prop];\n\n      if (Object.is(prevValue, value)) {\n        return true;\n      }\n\n      const childListeners = prevValue && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      if (refSet.has(value) || !isSupportedObject(value)) {\n        target[prop] = value;\n      } else if (value instanceof Promise) {\n        target[prop] = value.then(v => {\n          target[prop][PROMISE_RESULT] = v;\n          notifyUpdate();\n        }).catch(e => {\n          target[prop][PROMISE_ERROR] = e;\n          notifyUpdate();\n        });\n      } else {\n        value = getUntrackedObject(value) || value;\n\n        if (value[LISTENERS]) {\n          target[prop] = value;\n        } else {\n          target[prop] = proxy(value);\n        }\n\n        target[prop][LISTENERS].add(notifyUpdate);\n      }\n\n      notifyUpdate();\n      return true;\n    }\n\n  });\n  proxyCache.set(initialObject, p);\n  Reflect.ownKeys(initialObject).forEach(key => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n\n    if (desc.get) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      p[key] = initialObject[key];\n    }\n  });\n  return p;\n};\nconst getVersion = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[VERSION])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[VERSION];\n};\nconst subscribe = (p, callback, notifyInSync) => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[LISTENERS])) {\n    throw new Error('Please use proxy object');\n  }\n\n  let pendingVersion = 0;\n\n  const listener = nextVersion => {\n    if (notifyInSync) {\n      callback();\n      return;\n    }\n\n    pendingVersion = nextVersion;\n    Promise.resolve().then(() => {\n      if (nextVersion === pendingVersion) {\n        callback();\n      }\n    });\n  };\n\n  p[LISTENERS].add(listener);\n  return () => {\n    p[LISTENERS].delete(listener);\n  };\n};\nconst snapshot = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[SNAPSHOT])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[SNAPSHOT];\n};\n\nconst isSSR = typeof window === 'undefined' || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);\nconst useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = useRef();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(pathList.current);\n};\n\nconst mutableSourceCache = new WeakMap();\n\nconst getMutableSource = p => {\n  if (!mutableSourceCache.has(p)) {\n    mutableSourceCache.set(p, createMutableSource(p, getVersion));\n  }\n\n  return mutableSourceCache.get(p);\n};\n\nconst useProxy = (p, options) => {\n  const [, forceUpdate] = useReducer(c => c + 1, 0);\n  const affected = new WeakMap();\n  const lastAffected = useRef();\n  const prevSnapshot = useRef();\n  const lastSnapshot = useRef();\n  useIsomorphicLayoutEffect(() => {\n    lastSnapshot.current = prevSnapshot.current = snapshot(p);\n  }, [p]);\n  useIsomorphicLayoutEffect(() => {\n    lastAffected.current = affected;\n\n    if (prevSnapshot.current !== lastSnapshot.current && isDeepChanged(prevSnapshot.current, lastSnapshot.current, affected, new WeakMap())) {\n      prevSnapshot.current = lastSnapshot.current;\n      forceUpdate();\n    }\n  });\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const sub = useCallback((p, cb) => subscribe(p, () => {\n    const nextSnapshot = snapshot(p);\n    lastSnapshot.current = nextSnapshot;\n\n    try {\n      if (lastAffected.current && !isDeepChanged(prevSnapshot.current, nextSnapshot, lastAffected.current, new WeakMap())) {\n        // not changed\n        return;\n      }\n    } catch (e) {// ignore if a promise or something is thrown\n    }\n\n    prevSnapshot.current = nextSnapshot;\n    cb();\n  }, notifyInSync), [notifyInSync]);\n  const currSnapshot = useMutableSource(getMutableSource(p), snapshot, sub);\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAffectedDebugValue(currSnapshot, affected);\n  }\n\n  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n\n  return createDeepProxy(currSnapshot, affected, proxyCache);\n};\n\nexport { proxy, ref, snapshot, subscribe, useProxy };\n"]},"metadata":{},"sourceType":"module"}