{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbTarget, DbTargetDocument, DbTargetGlobal } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n\nvar IndexedDbQueryCache =\n/** @class */\nfunction () {\n  function IndexedDbQueryCache(serializer) {\n    this.serializer = serializer;\n    /**\n     * The last received snapshot version. We store this seperately from the\n     * metadata to avoid the extra conversion to/from DbTimestamp.\n     */\n\n    this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n    /**\n     * A cached copy of the metadata for the query cache.\n     */\n\n    this.metadata = new DbTargetGlobal(\n    /*highestTargetId=*/\n    0,\n    /*lastListenSequenceNumber=*/\n    0, SnapshotVersion.MIN.toTimestamp());\n    /** The garbage collector to notify about potential garbage keys. */\n\n    this.garbageCollector = null;\n  }\n\n  IndexedDbQueryCache.prototype.start = function (transaction) {\n    var _this = this;\n\n    return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function (metadata) {\n      if (metadata !== null) {\n        _this.metadata = metadata;\n        var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n        _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n      }\n\n      return PersistencePromise.resolve();\n    });\n  };\n\n  IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n    return this.metadata.highestTargetId;\n  };\n\n  IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n    return this.lastRemoteSnapshotVersion;\n  };\n\n  IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n    return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n  };\n\n  IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n    var _this = this;\n\n    var targetId = queryData.targetId;\n    var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n\n    if (targetId > this.metadata.highestTargetId) {\n      this.metadata.highestTargetId = targetId;\n      return addedQueryPromise.next(function () {\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);\n      });\n    } else {\n      return addedQueryPromise;\n    }\n  };\n\n  IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n    return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {\n      targetsStore(transaction).delete(queryData.targetId);\n    });\n  };\n\n  IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n    var _this = this; // Iterating by the canonicalId may yield more than one result because\n    // canonicalId values are not required to be unique per target. This query\n    // depends on the queryTargets index to be efficent.\n\n\n    var canonicalId = query.canonicalId();\n    var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n    var result = null;\n    return targetsStore(transaction).iterate({\n      range: range,\n      index: DbTarget.queryTargetsIndexName\n    }, function (key, value, control) {\n      var found = _this.serializer.fromDbTarget(value); // After finding a potential match, check that the query is\n      // actually equal to the requested query.\n\n\n      if (query.equals(found.query)) {\n        result = found;\n        control.done();\n      }\n    }).next(function () {\n      return result;\n    });\n  };\n\n  IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // Indexeddb.\n    var promises = [];\n    var store = documentTargetStore(txn);\n    keys.forEach(function (key) {\n      var path = EncodedResourcePath.encode(key.path);\n      promises.push(store.put(new DbTargetDocument(targetId, path)));\n    });\n    return PersistencePromise.waitFor(promises);\n  };\n\n  IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n    var _this = this; // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // IndexedDb.\n\n\n    var promises = [];\n    var store = documentTargetStore(txn);\n    keys.forEach(function (key) {\n      var path = EncodedResourcePath.encode(key.path);\n      promises.push(store.delete([targetId, path]));\n\n      if (_this.garbageCollector !== null) {\n        _this.garbageCollector.addPotentialGarbageKey(key);\n      }\n    });\n    return PersistencePromise.waitFor(promises);\n  };\n\n  IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n    var store = documentTargetStore(txn);\n    var range = IDBKeyRange.bound([targetId], [targetId + 1],\n    /*lowerOpen=*/\n    false,\n    /*upperOpen=*/\n    true);\n    return this.notifyGCForRemovedKeys(txn, range).next(function () {\n      return store.delete(range);\n    });\n  };\n\n  IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n    var _this = this;\n\n    var store = documentTargetStore(txn);\n\n    if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n      // In order to generate garbage events properly, we need to read these\n      // keys before deleting.\n      return store.iterate({\n        range: range,\n        keysOnly: true\n      }, function (key, _, control) {\n        var path = EncodedResourcePath.decode(key[1]);\n        var docKey = new DocumentKey(path); // Paranoid assertion in case the the collector is set to null\n        // during the iteration.\n\n        assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n\n        _this.garbageCollector.addPotentialGarbageKey(docKey);\n      });\n    } else {\n      return PersistencePromise.resolve();\n    }\n  };\n\n  IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n    var promises = [];\n    var range = IDBKeyRange.bound([targetId], [targetId + 1],\n    /*lowerOpen=*/\n    false,\n    /*upperOpen=*/\n    true);\n    var store = documentTargetStore(txn);\n    var result = documentKeySet();\n    return store.iterate({\n      range: range,\n      keysOnly: true\n    }, function (key, _, control) {\n      var path = EncodedResourcePath.decode(key[1]);\n      var docKey = new DocumentKey(path);\n      result = result.add(docKey);\n    }).next(function () {\n      return result;\n    });\n  };\n\n  IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n    this.garbageCollector = gc;\n  };\n\n  IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n    assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n    var path = EncodedResourcePath.encode(key.path);\n    var range = IDBKeyRange.bound([path], [immediateSuccessor(path)],\n    /*lowerOpen=*/\n    false,\n    /*upperOpen=*/\n    true);\n    var count = 0;\n    return documentTargetStore(txn).iterate({\n      index: DbTargetDocument.documentTargetsIndex,\n      keysOnly: true,\n      range: range\n    }, function (key, _, control) {\n      count++;\n      control.done();\n    }).next(function () {\n      return count > 0;\n    });\n  };\n\n  return IndexedDbQueryCache;\n}();\n\nexport { IndexedDbQueryCache };\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\n\nfunction targetsStore(txn) {\n  return getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\n\n\nfunction globalTargetStore(txn) {\n  return getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\n\n\nfunction documentTargetStore(txn) {\n  return getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\n\n\nfunction getStore(txn, store) {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}","map":{"version":3,"sources":["../src/local/indexeddb_query_cache.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { TargetId } from '../core/types';\nimport { DocumentKeySet, documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\n\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { GarbageCollector } from './garbage_collector';\nimport {\n  DbQuery,\n  DbTarget,\n  DbTargetDocument,\n  DbTargetDocumentKey,\n  DbTargetGlobal,\n  DbTargetGlobalKey,\n  DbTargetKey,\n  DbTimestamp\n} from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData } from './query_data';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\nexport class IndexedDbQueryCache implements QueryCache {\n  constructor(private serializer: LocalSerializer) {}\n\n  /**\n   * The last received snapshot version. We store this seperately from the\n   * metadata to avoid the extra conversion to/from DbTimestamp.\n   */\n  private lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n\n  /**\n   * A cached copy of the metadata for the query cache.\n   */\n  private metadata = new DbTargetGlobal(\n    /*highestTargetId=*/ 0,\n    /*lastListenSequenceNumber=*/ 0,\n    SnapshotVersion.MIN.toTimestamp()\n  );\n\n  /** The garbage collector to notify about potential garbage keys. */\n  private garbageCollector: GarbageCollector | null = null;\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    return globalTargetStore(transaction)\n      .get(DbTargetGlobal.key)\n      .next(metadata => {\n        if (metadata !== null) {\n          this.metadata = metadata;\n          const lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n          this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(\n            new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos)\n          );\n        }\n        return PersistencePromise.resolve();\n      });\n  }\n\n  getHighestTargetId(): TargetId {\n    return this.metadata.highestTargetId;\n  }\n\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.lastRemoteSnapshotVersion;\n  }\n\n  setLastRemoteSnapshotVersion(\n    transaction: PersistenceTransaction,\n    snapshotVersion: SnapshotVersion\n  ): PersistencePromise<void> {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n    return globalTargetStore(transaction).put(\n      DbTargetGlobal.key,\n      this.metadata\n    );\n  }\n\n  addQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    const targetId = queryData.targetId;\n    const addedQueryPromise = targetsStore(transaction).put(\n      this.serializer.toDbTarget(queryData)\n    );\n    if (targetId > this.metadata.highestTargetId) {\n      this.metadata.highestTargetId = targetId;\n      return addedQueryPromise.next(() =>\n        globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata)\n      );\n    } else {\n      return addedQueryPromise;\n    }\n  }\n\n  removeQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    return this.removeMatchingKeysForTargetId(\n      transaction,\n      queryData.targetId\n    ).next(() => {\n      targetsStore(transaction).delete(queryData.targetId);\n    });\n  }\n\n  getQueryData(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<QueryData | null> {\n    // Iterating by the canonicalId may yield more than one result because\n    // canonicalId values are not required to be unique per target. This query\n    // depends on the queryTargets index to be efficent.\n    const canonicalId = query.canonicalId();\n    const range = IDBKeyRange.bound(\n      [canonicalId, Number.NEGATIVE_INFINITY],\n      [canonicalId, Number.POSITIVE_INFINITY]\n    );\n    let result: QueryData | null = null;\n    return targetsStore(transaction)\n      .iterate(\n        { range, index: DbTarget.queryTargetsIndexName },\n        (key, value, control) => {\n          const found = this.serializer.fromDbTarget(value);\n          // After finding a potential match, check that the query is\n          // actually equal to the requested query.\n          if (query.equals(found.query)) {\n            result = found;\n            control.done();\n          }\n        }\n      )\n      .next(() => result);\n  }\n\n  addMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // Indexeddb.\n    const promises: Array<PersistencePromise<void>> = [];\n    const store = documentTargetStore(txn);\n    keys.forEach(key => {\n      const path = EncodedResourcePath.encode(key.path);\n      promises.push(store.put(new DbTargetDocument(targetId, path)));\n    });\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // IndexedDb.\n    const promises: Array<PersistencePromise<void>> = [];\n    const store = documentTargetStore(txn);\n    keys.forEach(key => {\n      const path = EncodedResourcePath.encode(key.path);\n      promises.push(store.delete([targetId, path]));\n      if (this.garbageCollector !== null) {\n        this.garbageCollector.addPotentialGarbageKey(key);\n      }\n    });\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    const store = documentTargetStore(txn);\n    const range = IDBKeyRange.bound(\n      [targetId],\n      [targetId + 1],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    return this.notifyGCForRemovedKeys(txn, range).next(() =>\n      store.delete(range)\n    );\n  }\n\n  private notifyGCForRemovedKeys(\n    txn: PersistenceTransaction,\n    range: IDBKeyRange\n  ): PersistencePromise<void> {\n    const store = documentTargetStore(txn);\n    if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n      // In order to generate garbage events properly, we need to read these\n      // keys before deleting.\n      return store.iterate({ range, keysOnly: true }, (key, _, control) => {\n        const path = EncodedResourcePath.decode(key[1]);\n        const docKey = new DocumentKey(path);\n        // Paranoid assertion in case the the collector is set to null\n        // during the iteration.\n        assert(\n          this.garbageCollector !== null,\n          'GarbageCollector for query cache set to null during key removal.'\n        );\n        this.garbageCollector!.addPotentialGarbageKey(docKey);\n      });\n    } else {\n      return PersistencePromise.resolve();\n    }\n  }\n\n  getMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<DocumentKeySet> {\n    const promises: Array<PersistencePromise<void>> = [];\n    const range = IDBKeyRange.bound(\n      [targetId],\n      [targetId + 1],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    const store = documentTargetStore(txn);\n    let result = documentKeySet();\n\n    return store\n      .iterate({ range, keysOnly: true }, (key, _, control) => {\n        const path = EncodedResourcePath.decode(key[1]);\n        const docKey = new DocumentKey(path);\n        result = result.add(docKey);\n      })\n      .next(() => result);\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.garbageCollector = gc;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    assert(\n      txn !== null,\n      'Persistence Transaction cannot be null for query cache containsKey'\n    );\n    const path = EncodedResourcePath.encode(key.path);\n    const range = IDBKeyRange.bound(\n      [path],\n      [immediateSuccessor(path)],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    let count = 0;\n    return documentTargetStore(txn!)\n      .iterate(\n        {\n          index: DbTargetDocument.documentTargetsIndex,\n          keysOnly: true,\n          range\n        },\n        (key, _, control) => {\n          count++;\n          control.done();\n        }\n      )\n      .next(() => count > 0);\n  }\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetKey, DbTarget> {\n  return getStore<DbTargetKey, DbTarget>(txn, DbTarget.store);\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetGlobalKey, DbTargetGlobal> {\n  return getStore<DbTargetGlobalKey, DbTargetGlobal>(txn, DbTargetGlobal.store);\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetDocumentKey, DbTargetDocument> {\n  return getStore<DbTargetDocumentKey, DbTargetDocument>(\n    txn,\n    DbTargetDocument.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore<KeyType extends IDBValidKey, ValueType>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<KeyType, ValueType> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<KeyType, ValueType>(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}