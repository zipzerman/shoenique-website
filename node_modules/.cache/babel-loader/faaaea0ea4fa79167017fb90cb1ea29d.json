{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Timestamp } from '../core/timestamp';\nimport { ObjectValue } from '../model/field_value';\nimport { ArrayValue, BlobValue, BooleanValue, DoubleValue, GeoPointValue, IntegerValue, NullValue, RefValue, StringValue, TimestampValue } from '../model/field_value';\nimport { FieldMask, FieldTransform, PatchMutation, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\nimport { Blob } from './blob';\nimport { FieldPath as ExternalFieldPath, fromDotSeparatedString } from './field_path';\nimport { DeleteFieldValueImpl, FieldValueImpl, ServerTimestampFieldValueImpl } from './field_value';\nimport { GeoPoint } from './geo_point';\nvar RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\n\nvar ParsedSetData =\n/** @class */\nfunction () {\n  function ParsedSetData(data, fieldMask, fieldTransforms) {\n    this.data = data;\n    this.fieldMask = fieldMask;\n    this.fieldTransforms = fieldTransforms;\n  }\n\n  ParsedSetData.prototype.toMutations = function (key, precondition) {\n    var mutations = [];\n\n    if (this.fieldMask !== null) {\n      mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition));\n    } else {\n      mutations.push(new SetMutation(key, this.data, precondition));\n    }\n\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n\n    return mutations;\n  };\n\n  return ParsedSetData;\n}();\n\nexport { ParsedSetData };\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\n\nvar ParsedUpdateData =\n/** @class */\nfunction () {\n  function ParsedUpdateData(data, fieldMask, fieldTransforms) {\n    this.data = data;\n    this.fieldMask = fieldMask;\n    this.fieldTransforms = fieldTransforms;\n  }\n\n  ParsedUpdateData.prototype.toMutations = function (key, precondition) {\n    var mutations = [new PatchMutation(key, this.data, this.fieldMask, precondition)];\n\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n\n    return mutations;\n  };\n\n  return ParsedUpdateData;\n}();\n\nexport { ParsedUpdateData };\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\n\nvar UserDataSource;\n\n(function (UserDataSource) {\n  UserDataSource[UserDataSource[\"Set\"] = 0] = \"Set\";\n  UserDataSource[UserDataSource[\"Update\"] = 1] = \"Update\";\n  UserDataSource[UserDataSource[\"MergeSet\"] = 2] = \"MergeSet\";\n  UserDataSource[UserDataSource[\"QueryValue\"] = 3] = \"QueryValue\"; // from a where clause or cursor bound\n})(UserDataSource || (UserDataSource = {}));\n\nfunction isWrite(dataSource) {\n  switch (dataSource) {\n    case UserDataSource.Set: // fall through\n\n    case UserDataSource.MergeSet: // fall through\n\n    case UserDataSource.Update:\n      return true;\n\n    case UserDataSource.QueryValue:\n      return false;\n\n    default:\n      throw fail(\"Unexpected case for UserDataSource: \" + dataSource);\n  }\n}\n/** A \"context\" object passed around while parsing user data. */\n\n\nvar ParseContext =\n/** @class */\nfunction () {\n  /**\n   * Initializes a ParseContext with the given source and path.\n   *\n   * @param dataSource Indicates what kind of API method this data came from.\n   * @param methodName The name of the method the user called to create this\n   *     ParseContext.\n   * @param path A path within the object being parsed. This could be an empty\n   *     path (in which case the context represents the root of the data being\n   *     parsed), or a nonempty path (indicating the context represents a nested\n   *     location within the data).\n   * @param arrayElement Whether or not this context corresponds to an element\n   *     of an array.\n   * @param fieldTransforms A mutable list of field transforms encountered while\n   *     parsing the data.\n   * @param fieldMask A mutable list of field paths encountered while parsing\n   *     the data.\n   *\n   * TODO(b/34871131): We don't support array paths right now, so path can be\n   * null to indicate the context represents any location within an array (in\n   * which case certain features will not work and errors will be somewhat\n   * compromised).\n   */\n  function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {\n    this.dataSource = dataSource;\n    this.methodName = methodName;\n    this.path = path;\n    this.arrayElement = arrayElement; // Minor hack: If fieldTransforms is undefined, we assume this is an\n    // external call and we need to validate the entire path.\n\n    if (fieldTransforms === undefined) {\n      this.validatePath();\n    }\n\n    this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n    this.fieldTransforms = fieldTransforms || [];\n    this.fieldMask = fieldMask || [];\n  }\n\n  ParseContext.prototype.childContextForField = function (field) {\n    var childPath = this.path == null ? null : this.path.child(field);\n    var context = new ParseContext(this.dataSource, this.methodName, childPath,\n    /*arrayElement=*/\n    false, this.fieldTransforms, this.fieldMask);\n    context.validatePathSegment(field);\n    return context;\n  };\n\n  ParseContext.prototype.childContextForFieldPath = function (field) {\n    var childPath = this.path == null ? null : this.path.child(field);\n    var context = new ParseContext(this.dataSource, this.methodName, childPath,\n    /*arrayElement=*/\n    false, this.fieldTransforms, this.fieldMask);\n    context.validatePath();\n    return context;\n  };\n\n  ParseContext.prototype.childContextForArray = function (index) {\n    // TODO(b/34871131): We don't support array paths right now; so make path\n    // null.\n    return new ParseContext(this.dataSource, this.methodName,\n    /*path=*/\n    null,\n    /*arrayElement=*/\n    true, this.fieldTransforms, this.fieldMask);\n  };\n\n  ParseContext.prototype.createError = function (reason) {\n    var fieldDescription = this.path === null || this.path.isEmpty() ? '' : \" (found in field \" + this.path.toString() + \")\";\n    return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" + reason + fieldDescription);\n  };\n\n  ParseContext.prototype.validatePath = function () {\n    // TODO(b/34871131): Remove null check once we have proper paths for fields\n    // within arrays.\n    if (this.path === null) {\n      return;\n    }\n\n    for (var i = 0; i < this.path.length; i++) {\n      this.validatePathSegment(this.path.get(i));\n    }\n  };\n\n  ParseContext.prototype.validatePathSegment = function (segment) {\n    if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n      throw this.createError('Document fields cannot begin and end with __');\n    }\n  };\n\n  ParseContext.prototype.isWrite = function () {\n    return this.dataSource === UserDataSource.Set || this.dataSource === UserDataSource.Update;\n  };\n\n  return ParseContext;\n}();\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\n\n\nvar DocumentKeyReference =\n/** @class */\nfunction () {\n  function DocumentKeyReference(databaseId, key) {\n    this.databaseId = databaseId;\n    this.key = key;\n  }\n\n  return DocumentKeyReference;\n}();\n\nexport { DocumentKeyReference };\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\n\nvar UserDataConverter =\n/** @class */\nfunction () {\n  function UserDataConverter(preConverter) {\n    this.preConverter = preConverter;\n  }\n  /** Parse document data from a non-merge set() call.*/\n\n\n  UserDataConverter.prototype.parseSetData = function (methodName, input) {\n    var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    var updateData = this.parseData(input, context);\n    return new ParsedSetData(updateData,\n    /* fieldMask= */\n    null, context.fieldTransforms);\n  };\n  /** Parse document data from a set() call with '{merge:true}'. */\n\n\n  UserDataConverter.prototype.parseMergeData = function (methodName, input) {\n    var context = new ParseContext(UserDataSource.MergeSet, methodName, FieldPath.EMPTY_PATH);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    var updateData = this.parseData(input, context);\n    var fieldMask = new FieldMask(context.fieldMask);\n    return new ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n  };\n  /** Parse update data from an update() call. */\n\n\n  UserDataConverter.prototype.parseUpdateData = function (methodName, input) {\n    var _this = this;\n\n    var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    var fieldMaskPaths = [];\n    var updateData = ObjectValue.EMPTY;\n    objUtils.forEach(input, function (key, value) {\n      var path = fieldPathFromDotSeparatedString(methodName, key);\n      var childContext = context.childContextForFieldPath(path);\n      value = _this.runPreConverter(value, childContext);\n\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        var parsedValue = _this.parseData(value, childContext);\n\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    });\n    var mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  };\n  /** Parse update data from a list of field/value arguments. */\n\n\n  UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {\n    var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n    var keys = [fieldPathFromArgument(methodName, field)];\n    var values = [value];\n\n    if (moreFieldsAndValues.length % 2 !== 0) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() needs to be called with an even number \" + 'of arguments that alternate between field names and values.');\n    }\n\n    for (var i = 0; i < moreFieldsAndValues.length; i += 2) {\n      keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n      values.push(moreFieldsAndValues[i + 1]);\n    }\n\n    var fieldMaskPaths = [];\n    var updateData = ObjectValue.EMPTY;\n\n    for (var i = 0; i < keys.length; ++i) {\n      var path = keys[i];\n      var childContext = context.childContextForFieldPath(path);\n      var value_1 = this.runPreConverter(values[i], childContext);\n\n      if (value_1 instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        var parsedValue = this.parseData(value_1, childContext);\n\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    }\n\n    var mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  };\n  /**\n   * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n   * bound).\n   */\n\n\n  UserDataConverter.prototype.parseQueryValue = function (methodName, input) {\n    var context = new ParseContext(UserDataSource.QueryValue, methodName, FieldPath.EMPTY_PATH);\n    var parsed = this.parseData(input, context);\n    assert(parsed != null, 'Parsed data should not be null.');\n    assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');\n    return parsed;\n  };\n  /** Sends data through this.preConverter, handling any thrown errors. */\n\n\n  UserDataConverter.prototype.runPreConverter = function (input, context) {\n    try {\n      return this.preConverter(input);\n    } catch (e) {\n      var message = errorMessage(e);\n      throw context.createError(message);\n    }\n  };\n  /**\n   * Internal helper for parsing user data.\n   *\n   * @param input Data to be parsed.\n   * @param context A context object representing the current path being parsed,\n   * the source of the data being parsed, etc.\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n\n\n  UserDataConverter.prototype.parseData = function (input, context) {\n    input = this.runPreConverter(input, context);\n\n    if (input instanceof Array) {\n      // TODO(b/34871131): Include the path containing the array in the error\n      // message.\n      if (context.arrayElement) {\n        throw context.createError('Nested arrays are not supported');\n      } // If context.path is null we are already inside an array and we don't\n      // support field mask paths more granular than the top-level array.\n\n\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n\n      return this.parseArray(input, context);\n    } else if (looksLikeJsonObject(input)) {\n      validatePlainObject('Unsupported field value:', context, input);\n      return this.parseObject(input, context);\n    } else {\n      // If context.path is null, we are inside an array and we should have\n      // already added the root of the array to the field mask.\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n\n      return this.parseScalarValue(input, context);\n    }\n  };\n\n  UserDataConverter.prototype.parseArray = function (array, context) {\n    var result = [];\n    var entryIndex = 0;\n\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var entry = array_1[_i];\n      var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));\n\n      if (parsedEntry == null) {\n        // Just include nulls in the array for fields being replaced with a\n        // sentinel.\n        parsedEntry = NullValue.INSTANCE;\n      }\n\n      result.push(parsedEntry);\n      entryIndex++;\n    }\n\n    return new ArrayValue(result);\n  };\n\n  UserDataConverter.prototype.parseObject = function (obj, context) {\n    var _this = this;\n\n    var result = new SortedMap(primitiveComparator);\n    objUtils.forEach(obj, function (key, val) {\n      var parsedValue = _this.parseData(val, context.childContextForField(key));\n\n      if (parsedValue != null) {\n        result = result.insert(key, parsedValue);\n      }\n    });\n    return new ObjectValue(result);\n  };\n  /**\n   * Helper to parse a scalar value (i.e. not an Object or Array)\n   *\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n\n\n  UserDataConverter.prototype.parseScalarValue = function (value, context) {\n    if (value === null) {\n      return NullValue.INSTANCE;\n    } else if (typeof value === 'number') {\n      if (typeUtils.isSafeInteger(value)) {\n        return new IntegerValue(value);\n      } else {\n        return new DoubleValue(value);\n      }\n    } else if (typeof value === 'boolean') {\n      return BooleanValue.of(value);\n    } else if (typeof value === 'string') {\n      return new StringValue(value);\n    } else if (value instanceof Date) {\n      return new TimestampValue(Timestamp.fromDate(value));\n    } else if (value instanceof GeoPoint) {\n      return new GeoPointValue(value);\n    } else if (value instanceof Blob) {\n      return new BlobValue(value);\n    } else if (value instanceof DocumentKeyReference) {\n      return new RefValue(value.databaseId, value.key);\n    } else if (value instanceof FieldValueImpl) {\n      if (value instanceof DeleteFieldValueImpl) {\n        if (context.dataSource == UserDataSource.MergeSet) {\n          return null;\n        } else if (context.dataSource === UserDataSource.Update) {\n          assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' + ' been handled.');\n          throw context.createError('FieldValue.delete() can only appear at the top level ' + 'of your update data');\n        } else {\n          // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n          throw context.createError('FieldValue.delete() can only be used with update() and set() with {merge:true}');\n        }\n      } else if (value instanceof ServerTimestampFieldValueImpl) {\n        if (!isWrite(context.dataSource)) {\n          throw context.createError('FieldValue.serverTimestamp() can only be used with set()' + ' and update()');\n        }\n\n        if (context.path === null) {\n          throw context.createError('FieldValue.serverTimestamp() is not currently' + ' supported inside arrays');\n        }\n\n        context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance)); // Return null so this value is omitted from the parsed result.\n\n        return null;\n      } else {\n        return fail('Unknown FieldValue type: ' + value);\n      }\n    } else {\n      throw context.createError(\"Unsupported field value: \" + valueDescription(value));\n    }\n  };\n\n  return UserDataConverter;\n}();\n\nexport { UserDataConverter };\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\n\nfunction looksLikeJsonObject(input) {\n  return typeof input === 'object' && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof GeoPoint) && !(input instanceof Blob) && !(input instanceof DocumentKeyReference) && !(input instanceof FieldValueImpl);\n}\n\nfunction validatePlainObject(message, context, input) {\n  if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n    var description = valueDescription(input);\n\n    if (description === 'an object') {\n      // Massage the error if it was an object.\n      throw context.createError(message + ' a custom object');\n    } else {\n      throw context.createError(message + ' ' + description);\n    }\n  }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\n\n\nexport function fieldPathFromArgument(methodName, path) {\n  if (path instanceof ExternalFieldPath) {\n    return path._internalPath;\n  } else if (typeof path === 'string') {\n    return fieldPathFromDotSeparatedString(methodName, path);\n  } else {\n    var message = 'Field path arguments must be of type string or FieldPath.';\n    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n  }\n}\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\n\nfunction fieldPathFromDotSeparatedString(methodName, path) {\n  try {\n    return fromDotSeparatedString(path)._internalPath;\n  } catch (e) {\n    var message = errorMessage(e);\n    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n  }\n}\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\n\n\nfunction errorMessage(error) {\n  return error instanceof Error ? error.message : error.toString();\n}","map":{"version":3,"sources":["../src/api/user_data_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from 'firestore';\n\nimport { DatabaseId } from '../core/database_info';\nimport { Timestamp } from '../core/timestamp';\nimport { DocumentKey } from '../model/document_key';\nimport { FieldValue, ObjectValue } from '../model/field_value';\nimport {\n  ArrayValue,\n  BlobValue,\n  BooleanValue,\n  DoubleValue,\n  GeoPointValue,\n  IntegerValue,\n  NullValue,\n  RefValue,\n  StringValue,\n  TimestampValue\n} from '../model/field_value';\nimport {\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  PatchMutation,\n  Precondition,\n  ServerTimestampTransform,\n  SetMutation,\n  TransformMutation\n} from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { AnyJs, primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { Dict } from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\n\nimport { Blob } from './blob';\nimport {\n  FieldPath as ExternalFieldPath,\n  fromDotSeparatedString\n} from './field_path';\nimport {\n  DeleteFieldValueImpl,\n  FieldValueImpl,\n  ServerTimestampFieldValueImpl\n} from './field_value';\nimport { GeoPoint } from './geo_point';\n\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n\n/** The result of parsing document data (e.g. for a setData call). */\nexport class ParsedSetData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask | null,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [] as Mutation[];\n    if (this.fieldMask !== null) {\n      mutations.push(\n        new PatchMutation(key, this.data, this.fieldMask, precondition)\n      );\n    } else {\n      mutations.push(new SetMutation(key, this.data, precondition));\n    }\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nexport class ParsedUpdateData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [\n      new PatchMutation(key, this.data, this.fieldMask, precondition)\n    ] as Mutation[];\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nenum UserDataSource {\n  Set,\n  Update,\n  MergeSet,\n  QueryValue // from a where clause or cursor bound\n}\n\nfunction isWrite(dataSource: UserDataSource) {\n  switch (dataSource) {\n    case UserDataSource.Set: // fall through\n    case UserDataSource.MergeSet: // fall through\n    case UserDataSource.Update:\n      return true;\n    case UserDataSource.QueryValue:\n      return false;\n    default:\n      throw fail(`Unexpected case for UserDataSource: ${dataSource}`);\n  }\n}\n\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContext {\n  readonly fieldTransforms: FieldTransform[];\n  readonly fieldMask: FieldPath[];\n  /**\n   * Initializes a ParseContext with the given source and path.\n   *\n   * @param dataSource Indicates what kind of API method this data came from.\n   * @param methodName The name of the method the user called to create this\n   *     ParseContext.\n   * @param path A path within the object being parsed. This could be an empty\n   *     path (in which case the context represents the root of the data being\n   *     parsed), or a nonempty path (indicating the context represents a nested\n   *     location within the data).\n   * @param arrayElement Whether or not this context corresponds to an element\n   *     of an array.\n   * @param fieldTransforms A mutable list of field transforms encountered while\n   *     parsing the data.\n   * @param fieldMask A mutable list of field paths encountered while parsing\n   *     the data.\n   *\n   * TODO(b/34871131): We don't support array paths right now, so path can be\n   * null to indicate the context represents any location within an array (in\n   * which case certain features will not work and errors will be somewhat\n   * compromised).\n   */\n  constructor(\n    readonly dataSource: UserDataSource,\n    readonly methodName: string,\n    readonly path: FieldPath | null,\n    readonly arrayElement?: boolean,\n    fieldTransforms?: FieldTransform[],\n    fieldMask?: FieldPath[]\n  ) {\n    // Minor hack: If fieldTransforms is undefined, we assume this is an\n    // external call and we need to validate the entire path.\n    if (fieldTransforms === undefined) {\n      this.validatePath();\n    }\n    this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n    this.fieldTransforms = fieldTransforms || [];\n    this.fieldMask = fieldMask || [];\n  }\n\n  childContextForField(field: string): ParseContext {\n    const childPath = this.path == null ? null : this.path.child(field);\n    const context = new ParseContext(\n      this.dataSource,\n      this.methodName,\n      childPath,\n      /*arrayElement=*/ false,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n    context.validatePathSegment(field);\n    return context;\n  }\n\n  childContextForFieldPath(field: FieldPath): ParseContext {\n    const childPath = this.path == null ? null : this.path.child(field);\n    const context = new ParseContext(\n      this.dataSource,\n      this.methodName,\n      childPath,\n      /*arrayElement=*/ false,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n    context.validatePath();\n    return context;\n  }\n\n  childContextForArray(index: number): ParseContext {\n    // TODO(b/34871131): We don't support array paths right now; so make path\n    // null.\n    return new ParseContext(\n      this.dataSource,\n      this.methodName,\n      /*path=*/ null,\n      /*arrayElement=*/ true,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n  }\n\n  createError(reason: string): Error {\n    const fieldDescription =\n      this.path === null || this.path.isEmpty()\n        ? ''\n        : ` (found in field ${this.path.toString()})`;\n    return new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${this.methodName}() called with invalid data. ` +\n        reason +\n        fieldDescription\n    );\n  }\n\n  private validatePath() {\n    // TODO(b/34871131): Remove null check once we have proper paths for fields\n    // within arrays.\n    if (this.path === null) {\n      return;\n    }\n    for (let i = 0; i < this.path.length; i++) {\n      this.validatePathSegment(this.path.get(i));\n    }\n  }\n\n  private validatePathSegment(segment: string) {\n    if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n      throw this.createError('Document fields cannot begin and end with __');\n    }\n  }\n\n  private isWrite(): boolean {\n    return (\n      this.dataSource === UserDataSource.Set ||\n      this.dataSource === UserDataSource.Update\n    );\n  }\n}\n/**\n * An interface that allows arbitrary pre-converting of user data. This\n * abstraction allows for, e.g.:\n *  * The public API to convert DocumentReference objects to DocRef objects,\n *    avoiding a circular dependency between user_data_converter.ts and\n *    database.ts\n *  * Tests to convert test-only sentinels (e.g. '<DELETE>') into types\n *    compatible with UserDataConverter.\n *\n * Returns the converted value (can return back the input to act as a no-op).\n *\n * It can also throw an Error which will be wrapped into a friendly message.\n */\nexport type DataPreConverter = (input: AnyJs) => AnyJs;\n\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nexport class DocumentKeyReference {\n  constructor(public databaseId: DatabaseId, public key: DocumentKey) {}\n}\n\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nexport class UserDataConverter {\n  constructor(private preConverter: DataPreConverter) {}\n\n  /** Parse document data from a non-merge set() call.*/\n  parseSetData(methodName: string, input: AnyJs): ParsedSetData {\n    const context = new ParseContext(\n      UserDataSource.Set,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    let updateData = this.parseData(input, context);\n\n    return new ParsedSetData(\n      updateData as ObjectValue,\n      /* fieldMask= */ null,\n      context.fieldTransforms\n    );\n  }\n\n  /** Parse document data from a set() call with '{merge:true}'. */\n  parseMergeData(methodName: string, input: AnyJs): ParsedSetData {\n    const context = new ParseContext(\n      UserDataSource.MergeSet,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    let updateData = this.parseData(input, context);\n    const fieldMask = new FieldMask(context.fieldMask);\n    return new ParsedSetData(\n      updateData as ObjectValue,\n      fieldMask,\n      context.fieldTransforms\n    );\n  }\n\n  /** Parse update data from an update() call. */\n  parseUpdateData(methodName: string, input: AnyJs): ParsedUpdateData {\n    const context = new ParseContext(\n      UserDataSource.Update,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    const fieldMaskPaths = [] as FieldPath[];\n    let updateData = ObjectValue.EMPTY;\n    objUtils.forEach(input as Dict<AnyJs>, (key, value) => {\n      const path = fieldPathFromDotSeparatedString(methodName, key);\n\n      const childContext = context.childContextForFieldPath(path);\n      value = this.runPreConverter(value, childContext);\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = this.parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    });\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  }\n\n  /** Parse update data from a list of field/value arguments. */\n  parseUpdateVarargs(\n    methodName: string,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    moreFieldsAndValues: AnyJs[]\n  ): ParsedUpdateData {\n    const context = new ParseContext(\n      UserDataSource.Update,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    const keys = [fieldPathFromArgument(methodName, field)];\n    const values = [value];\n\n    if (moreFieldsAndValues.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function ${methodName}() needs to be called with an even number ` +\n          'of arguments that alternate between field names and values.'\n      );\n    }\n\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n      keys.push(\n        fieldPathFromArgument(methodName, moreFieldsAndValues[i] as\n          | string\n          | ExternalFieldPath)\n      );\n      values.push(moreFieldsAndValues[i + 1]);\n    }\n\n    const fieldMaskPaths = [] as FieldPath[];\n    let updateData = ObjectValue.EMPTY;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const path = keys[i];\n      const childContext = context.childContextForFieldPath(path);\n      const value = this.runPreConverter(values[i], childContext);\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = this.parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    }\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  }\n\n  /**\n   * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n   * bound).\n   */\n  parseQueryValue(methodName: string, input: AnyJs): FieldValue {\n    const context = new ParseContext(\n      UserDataSource.QueryValue,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    const parsed = this.parseData(input, context);\n    assert(parsed != null, 'Parsed data should not be null.');\n    assert(\n      context.fieldTransforms.length === 0,\n      'Field transforms should have been disallowed.'\n    );\n    return parsed!;\n  }\n\n  /** Sends data through this.preConverter, handling any thrown errors. */\n  private runPreConverter(input: AnyJs, context: ParseContext): AnyJs {\n    try {\n      return this.preConverter(input);\n    } catch (e) {\n      const message = errorMessage(e);\n      throw context.createError(message);\n    }\n  }\n\n  /**\n   * Internal helper for parsing user data.\n   *\n   * @param input Data to be parsed.\n   * @param context A context object representing the current path being parsed,\n   * the source of the data being parsed, etc.\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n  private parseData(input: AnyJs, context: ParseContext): FieldValue | null {\n    input = this.runPreConverter(input, context);\n    if (input instanceof Array) {\n      // TODO(b/34871131): Include the path containing the array in the error\n      // message.\n      if (context.arrayElement) {\n        throw context.createError('Nested arrays are not supported');\n      }\n      // If context.path is null we are already inside an array and we don't\n      // support field mask paths more granular than the top-level array.\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n      return this.parseArray(input as AnyJs[], context);\n    } else if (looksLikeJsonObject(input)) {\n      validatePlainObject('Unsupported field value:', context, input);\n      return this.parseObject(input as Dict<AnyJs>, context);\n    } else {\n      // If context.path is null, we are inside an array and we should have\n      // already added the root of the array to the field mask.\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n      return this.parseScalarValue(input, context);\n    }\n  }\n\n  private parseArray(array: AnyJs[], context: ParseContext): FieldValue {\n    const result = [] as FieldValue[];\n    let entryIndex = 0;\n    for (const entry of array) {\n      let parsedEntry = this.parseData(\n        entry,\n        context.childContextForArray(entryIndex)\n      );\n      if (parsedEntry == null) {\n        // Just include nulls in the array for fields being replaced with a\n        // sentinel.\n        parsedEntry = NullValue.INSTANCE;\n      }\n      result.push(parsedEntry);\n      entryIndex++;\n    }\n    return new ArrayValue(result);\n  }\n\n  private parseObject(obj: Dict<AnyJs>, context: ParseContext): FieldValue {\n    let result = new SortedMap<string, FieldValue>(primitiveComparator);\n    objUtils.forEach(obj, (key: string, val: AnyJs) => {\n      const parsedValue = this.parseData(\n        val,\n        context.childContextForField(key)\n      );\n      if (parsedValue != null) {\n        result = result.insert(key, parsedValue);\n      }\n    });\n    return new ObjectValue(result);\n  }\n\n  /**\n   * Helper to parse a scalar value (i.e. not an Object or Array)\n   *\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n  private parseScalarValue(\n    value: AnyJs,\n    context: ParseContext\n  ): FieldValue | null {\n    if (value === null) {\n      return NullValue.INSTANCE;\n    } else if (typeof value === 'number') {\n      if (typeUtils.isSafeInteger(value)) {\n        return new IntegerValue(value);\n      } else {\n        return new DoubleValue(value);\n      }\n    } else if (typeof value === 'boolean') {\n      return BooleanValue.of(value);\n    } else if (typeof value === 'string') {\n      return new StringValue(value);\n    } else if (value instanceof Date) {\n      return new TimestampValue(Timestamp.fromDate(value));\n    } else if (value instanceof GeoPoint) {\n      return new GeoPointValue(value);\n    } else if (value instanceof Blob) {\n      return new BlobValue(value);\n    } else if (value instanceof DocumentKeyReference) {\n      return new RefValue(value.databaseId, value.key);\n    } else if (value instanceof FieldValueImpl) {\n      if (value instanceof DeleteFieldValueImpl) {\n        if (context.dataSource == UserDataSource.MergeSet) {\n          return null;\n        } else if (context.dataSource === UserDataSource.Update) {\n          assert(\n            context.path == null || context.path.length > 0,\n            'FieldValue.delete() at the top level should have already' +\n              ' been handled.'\n          );\n          throw context.createError(\n            'FieldValue.delete() can only appear at the top level ' +\n              'of your update data'\n          );\n        } else {\n          // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n          throw context.createError(\n            'FieldValue.delete() can only be used with update() and set() with {merge:true}'\n          );\n        }\n      } else if (value instanceof ServerTimestampFieldValueImpl) {\n        if (!isWrite(context.dataSource)) {\n          throw context.createError(\n            'FieldValue.serverTimestamp() can only be used with set()' +\n              ' and update()'\n          );\n        }\n        if (context.path === null) {\n          throw context.createError(\n            'FieldValue.serverTimestamp() is not currently' +\n              ' supported inside arrays'\n          );\n        }\n        context.fieldTransforms.push(\n          new FieldTransform(context.path, ServerTimestampTransform.instance)\n        );\n\n        // Return null so this value is omitted from the parsed result.\n        return null;\n      } else {\n        return fail('Unknown FieldValue type: ' + value);\n      }\n    } else {\n      throw context.createError(\n        `Unsupported field value: ${valueDescription(value)}`\n      );\n    }\n  }\n}\n\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input: AnyJs): boolean {\n  return (\n    typeof input === 'object' &&\n    input !== null &&\n    !(input instanceof Array) &&\n    !(input instanceof Date) &&\n    !(input instanceof GeoPoint) &&\n    !(input instanceof Blob) &&\n    !(input instanceof DocumentKeyReference) &&\n    !(input instanceof FieldValueImpl)\n  );\n}\n\nfunction validatePlainObject(\n  message: string,\n  context: ParseContext,\n  input: AnyJs\n) {\n  if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n    const description = valueDescription(input);\n    if (description === 'an object') {\n      // Massage the error if it was an object.\n      throw context.createError(message + ' a custom object');\n    } else {\n      throw context.createError(message + ' ' + description);\n    }\n  }\n}\n\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(\n  methodName: string,\n  path: string | ExternalFieldPath\n): FieldPath {\n  if (path instanceof ExternalFieldPath) {\n    return path._internalPath;\n  } else if (typeof path === 'string') {\n    return fieldPathFromDotSeparatedString(methodName, path);\n  } else {\n    const message = 'Field path arguments must be of type string or FieldPath.';\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(\n  methodName: string,\n  path: string\n): FieldPath {\n  try {\n    return fromDotSeparatedString(path)._internalPath;\n  } catch (e) {\n    const message = errorMessage(e);\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error: Error | object): string {\n  return error instanceof Error ? error.message : error.toString();\n}\n"]},"metadata":{},"sourceType":"module"}