{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AutoId } from '../util/misc';\nimport { IndexedDbMutationQueue } from './indexeddb_mutation_queue';\nimport { IndexedDbQueryCache } from './indexeddb_query_cache';\nimport { IndexedDbRemoteDocumentCache } from './indexeddb_remote_document_cache';\nimport { ALL_STORES, DbOwner } from './indexeddb_schema';\nimport { createOrUpgradeDb, SCHEMA_VERSION } from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDb } from './simple_db';\nvar LOG_TAG = 'IndexedDbPersistence';\n/** If the owner lease is older than 5 seconds, try to take ownership. */\n\nvar OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\n\nvar OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\n\nvar ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\n\nvar EXISTING_OWNER_ERROR_MSG = 'There is another tab open with offline' + ' persistence enabled. Only one such tab is allowed at a time. The' + ' other tab must be closed or persistence must be disabled.';\nvar UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' + ' IndexedDB or is known to have an incomplete implementation. Offline' + ' persistence has been disabled.';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\n\nvar IndexedDbPersistence =\n/** @class */\nfunction () {\n  function IndexedDbPersistence(prefix, serializer) {\n    this.ownerId = this.generateOwnerId();\n    this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n    this.serializer = new LocalSerializer(serializer);\n    this.localStoragePrefix = prefix;\n  }\n\n  IndexedDbPersistence.prototype.start = function () {\n    var _this = this;\n\n    if (!IndexedDbPersistence.isAvailable()) {\n      this.persistenceError = new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n      return Promise.reject(this.persistenceError);\n    }\n\n    assert(!this.started, 'IndexedDbPersistence double-started!');\n    this.started = true;\n    return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb).then(function (db) {\n      _this.simpleDb = db;\n    }).then(function () {\n      return _this.tryAcquireOwnerLease();\n    }).then(function () {\n      _this.scheduleOwnerLeaseRefreshes();\n\n      _this.attachWindowUnloadHook();\n    });\n  };\n\n  IndexedDbPersistence.prototype.shutdown = function () {\n    var _this = this;\n\n    assert(this.started, 'IndexedDbPersistence shutdown without start!');\n    this.started = false;\n    this.detachWindowUnloadHook();\n    this.stopOwnerLeaseRefreshes();\n    return this.releaseOwnerLease().then(function () {\n      _this.simpleDb.close();\n    });\n  };\n\n  IndexedDbPersistence.prototype.getMutationQueue = function (user) {\n    return IndexedDbMutationQueue.forUser(user, this.serializer);\n  };\n\n  IndexedDbPersistence.prototype.getQueryCache = function () {\n    return new IndexedDbQueryCache(this.serializer);\n  };\n\n  IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {\n    return new IndexedDbRemoteDocumentCache(this.serializer);\n  };\n\n  IndexedDbPersistence.prototype.runTransaction = function (action, operation) {\n    var _this = this;\n\n    if (this.persistenceError) {\n      return Promise.reject(this.persistenceError);\n    }\n\n    log.debug(LOG_TAG, 'Starting transaction:', action); // Do all transactions as readwrite against all object stores, since we\n    // are the only reader/writer.\n\n    return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {\n      // Verify that we still have the owner lease as part of every transaction.\n      return _this.ensureOwnerLease(txn).next(function () {\n        return operation(txn);\n      });\n    });\n  };\n\n  IndexedDbPersistence.isAvailable = function () {\n    return SimpleDb.isAvailable();\n  };\n  /**\n   * Generates a string used as a prefix when storing data in IndexedDB and\n   * LocalStorage.\n   */\n\n\n  IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    var database = databaseInfo.databaseId.projectId;\n\n    if (!databaseInfo.databaseId.isDefaultDatabase) {\n      database += '.' + databaseInfo.databaseId.database;\n    }\n\n    return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n  };\n  /**\n   * Acquires the owner lease if there's no valid owner. Else returns a rejected\n   * promise.\n   */\n\n\n  IndexedDbPersistence.prototype.tryAcquireOwnerLease = function () {\n    var _this = this; // NOTE: Don't use this.runTransaction, since it requires us to already\n    // have the lease.\n\n\n    return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n      var store = txn.store(DbOwner.store);\n      return store.get('owner').next(function (dbOwner) {\n        if (!_this.validOwner(dbOwner)) {\n          var newDbOwner = new DbOwner(_this.ownerId, Date.now());\n          log.debug(LOG_TAG, 'No valid owner. Acquiring owner lease. Current owner:', dbOwner, 'New owner:', newDbOwner);\n          return store.put('owner', newDbOwner);\n        } else {\n          log.debug(LOG_TAG, 'Valid owner already. Failing. Current owner:', dbOwner);\n          _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n          return PersistencePromise.reject(_this.persistenceError);\n        }\n      });\n    });\n  };\n  /** Checks the owner lease and deletes it if we are the current owner. */\n\n\n  IndexedDbPersistence.prototype.releaseOwnerLease = function () {\n    var _this = this; // NOTE: Don't use this.runTransaction, since it requires us to already\n    // have the lease.\n\n\n    return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n      var store = txn.store(DbOwner.store);\n      return store.get('owner').next(function (dbOwner) {\n        if (dbOwner !== null && dbOwner.ownerId === _this.ownerId) {\n          log.debug(LOG_TAG, 'Releasing owner lease.');\n          return store.delete('owner');\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n    });\n  };\n  /**\n   * Checks the owner lease and returns a rejected promise if we are not the\n   * current owner. This should be included in every transaction to guard\n   * against losing the owner lease.\n   */\n\n\n  IndexedDbPersistence.prototype.ensureOwnerLease = function (txn) {\n    var _this = this;\n\n    var store = txn.store(DbOwner.store);\n    return store.get('owner').next(function (dbOwner) {\n      if (dbOwner === null || dbOwner.ownerId !== _this.ownerId) {\n        _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n        return PersistencePromise.reject(_this.persistenceError);\n      } else {\n        return PersistencePromise.resolve();\n      }\n    });\n  };\n  /**\n   * Returns true if the provided owner exists, has a recent timestamp, and\n   * isn't zombied.\n   *\n   * NOTE: To determine if the owner is zombied, this method reads from\n   * LocalStorage which could be mildly expensive.\n   */\n\n\n  IndexedDbPersistence.prototype.validOwner = function (dbOwner) {\n    var now = Date.now();\n    var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n    var maxAcceptable = now;\n\n    if (dbOwner === null) {\n      return false; // no owner.\n    } else if (dbOwner.leaseTimestampMs < minAcceptable) {\n      return false; // owner lease has expired.\n    } else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n      log.error('Persistence owner-lease is in the future. Discarding.', dbOwner);\n      return false;\n    } else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n      return false; // owner's tab closed.\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Schedules a recurring timer to update the owner lease timestamp to prevent\n   * other tabs from taking the lease.\n   */\n\n\n  IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function () {\n    var _this = this; // NOTE: This doesn't need to be scheduled on the async queue and doing so\n    // would increase the chances of us not refreshing on time if the queue is\n    // backed up for some reason.\n\n\n    this.ownerLeaseRefreshHandle = setInterval(function () {\n      var txResult = _this.runTransaction('Refresh owner timestamp', function (txn) {\n        // NOTE: We don't need to validate the current owner contents, since\n        // runTransaction does that automatically.\n        var store = txn.store(DbOwner.store);\n        return store.put('owner', new DbOwner(_this.ownerId, Date.now()));\n      });\n\n      txResult.catch(function (reason) {\n        // Probably means we lost the lease. Report the error and stop trying to\n        // refresh the lease.\n        log.error(reason);\n\n        _this.stopOwnerLeaseRefreshes();\n      });\n    }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n  };\n\n  IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function () {\n    if (this.ownerLeaseRefreshHandle) {\n      clearInterval(this.ownerLeaseRefreshHandle);\n      this.ownerLeaseRefreshHandle = null;\n    }\n  };\n  /**\n   * Attaches a window.unload handler that will synchronously write our\n   * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n   * by tabs trying to acquire the lease to determine that the lease should be\n   * acquired immediately even if the timestamp is recent. This is particularly\n   * important for the refresh case (so the tab correctly re-acquires the owner\n   * lease). LocalStorage is used for this rather than IndexedDb because it is\n   * a synchronous API and so can be used reliably from an unload handler.\n   */\n\n\n  IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {\n    var _this = this;\n\n    this.windowUnloadHandler = function () {\n      // Record that we're zombied.\n      _this.setZombiedOwnerId(_this.ownerId); // Attempt graceful shutdown (including releasing our owner lease), but\n      // there's no guarantee it will complete.\n\n\n      _this.shutdown();\n    };\n\n    window.addEventListener('unload', this.windowUnloadHandler);\n  };\n\n  IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {\n    if (this.windowUnloadHandler) {\n      window.removeEventListener('unload', this.windowUnloadHandler);\n      this.windowUnloadHandler = null;\n    }\n  };\n  /**\n   * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n   * zombied due to their tab closing) from LocalStorage, or null if no such\n   * record exists.\n   */\n\n\n  IndexedDbPersistence.prototype.getZombiedOwnerId = function () {\n    try {\n      var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());\n      log.debug(LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n      return zombiedOwnerId;\n    } catch (e) {\n      // Gracefully handle if LocalStorage isn't available / working.\n      log.error(LOG_TAG, 'Failed to get zombie owner id.', e);\n      return null;\n    }\n  };\n  /**\n   * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n   * or, if passed null, deletes any recorded zombied owner.\n   */\n\n\n  IndexedDbPersistence.prototype.setZombiedOwnerId = function (zombieOwnerId) {\n    try {\n      if (zombieOwnerId === null) {\n        window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n      } else {\n        window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);\n      }\n    } catch (e) {\n      // Gracefully handle if LocalStorage isn't available / working.\n      log.error(LOG_TAG, 'Failed to set zombie owner id.', e);\n    }\n  };\n\n  IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function () {\n    return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n  };\n\n  IndexedDbPersistence.prototype.generateOwnerId = function () {\n    // For convenience, just use an AutoId.\n    return AutoId.newId();\n  };\n  /**\n   * The name of the main (and currently only) IndexedDB database. this name is\n   * appended to the prefix provided to the IndexedDbPersistence constructor.\n   */\n\n\n  IndexedDbPersistence.MAIN_DATABASE = 'main';\n  return IndexedDbPersistence;\n}();\n\nexport { IndexedDbPersistence };","map":{"version":3,"sources":["../src/local/indexeddb_persistence.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { DatabaseInfo } from '../core/database_info';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AutoId } from '../util/misc';\n\nimport { IndexedDbMutationQueue } from './indexeddb_mutation_queue';\nimport { IndexedDbQueryCache } from './indexeddb_query_cache';\nimport { IndexedDbRemoteDocumentCache } from './indexeddb_remote_document_cache';\nimport { ALL_STORES, DbOwner, DbOwnerKey } from './indexeddb_schema';\nimport { createOrUpgradeDb, SCHEMA_VERSION } from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { MutationQueue } from './mutation_queue';\nimport { Persistence } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { SimpleDb, SimpleDbTransaction } from './simple_db';\n\nconst LOG_TAG = 'IndexedDbPersistence';\n\n/** If the owner lease is older than 5 seconds, try to take ownership. */\nconst OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\nconst OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\nconst ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\nconst EXISTING_OWNER_ERROR_MSG =\n  'There is another tab open with offline' +\n  ' persistence enabled. Only one such tab is allowed at a time. The' +\n  ' other tab must be closed or persistence must be disabled.';\nconst UNSUPPORTED_PLATFORM_ERROR_MSG =\n  'This platform is either missing' +\n  ' IndexedDB or is known to have an incomplete implementation. Offline' +\n  ' persistence has been disabled.';\n\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\nexport class IndexedDbPersistence implements Persistence {\n  /**\n   * The name of the main (and currently only) IndexedDB database. this name is\n   * appended to the prefix provided to the IndexedDbPersistence constructor.\n   */\n  static MAIN_DATABASE = 'main';\n\n  private simpleDb: SimpleDb;\n  private started: boolean;\n  private dbName: string;\n  private localStoragePrefix: string;\n  private ownerId: string = this.generateOwnerId();\n\n  /**\n   * Set to an Error object if we encounter an unrecoverable error. All further\n   * transactions will be failed with this error.\n   */\n  private persistenceError: Error | null;\n  /** The setInterval() handle tied to refreshing the owner lease. */\n  // tslint:disable-next-line:no-any setTimeout() type differs on browser / node\n  private ownerLeaseRefreshHandle: any;\n  /** Our window.unload handler, if registered. */\n  private windowUnloadHandler: (() => void) | null;\n\n  private serializer: LocalSerializer;\n\n  constructor(prefix: string, serializer: JsonProtoSerializer) {\n    this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n    this.serializer = new LocalSerializer(serializer);\n    this.localStoragePrefix = prefix;\n  }\n\n  start(): Promise<void> {\n    if (!IndexedDbPersistence.isAvailable()) {\n      this.persistenceError = new FirestoreError(\n        Code.UNIMPLEMENTED,\n        UNSUPPORTED_PLATFORM_ERROR_MSG\n      );\n      return Promise.reject(this.persistenceError);\n    }\n\n    assert(!this.started, 'IndexedDbPersistence double-started!');\n    this.started = true;\n\n    return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb)\n      .then(db => {\n        this.simpleDb = db;\n      })\n      .then(() => this.tryAcquireOwnerLease())\n      .then(() => {\n        this.scheduleOwnerLeaseRefreshes();\n        this.attachWindowUnloadHook();\n      });\n  }\n\n  shutdown(): Promise<void> {\n    assert(this.started, 'IndexedDbPersistence shutdown without start!');\n    this.started = false;\n    this.detachWindowUnloadHook();\n    this.stopOwnerLeaseRefreshes();\n    return this.releaseOwnerLease().then(() => {\n      this.simpleDb.close();\n    });\n  }\n\n  getMutationQueue(user: User): MutationQueue {\n    return IndexedDbMutationQueue.forUser(user, this.serializer);\n  }\n\n  getQueryCache(): QueryCache {\n    return new IndexedDbQueryCache(this.serializer);\n  }\n\n  getRemoteDocumentCache(): RemoteDocumentCache {\n    return new IndexedDbRemoteDocumentCache(this.serializer);\n  }\n\n  runTransaction<T>(\n    action: string,\n    operation: (transaction: SimpleDbTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    if (this.persistenceError) {\n      return Promise.reject(this.persistenceError);\n    }\n\n    log.debug(LOG_TAG, 'Starting transaction:', action);\n\n    // Do all transactions as readwrite against all object stores, since we\n    // are the only reader/writer.\n    return this.simpleDb.runTransaction('readwrite', ALL_STORES, txn => {\n      // Verify that we still have the owner lease as part of every transaction.\n      return this.ensureOwnerLease(txn).next(() => operation(txn));\n    });\n  }\n\n  static isAvailable(): boolean {\n    return SimpleDb.isAvailable();\n  }\n\n  /**\n   * Generates a string used as a prefix when storing data in IndexedDB and\n   * LocalStorage.\n   */\n  static buildStoragePrefix(databaseInfo: DatabaseInfo): string {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    let database = databaseInfo.databaseId.projectId;\n    if (!databaseInfo.databaseId.isDefaultDatabase) {\n      database += '.' + databaseInfo.databaseId.database;\n    }\n\n    return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n  }\n\n  /**\n   * Acquires the owner lease if there's no valid owner. Else returns a rejected\n   * promise.\n   */\n  private tryAcquireOwnerLease(): Promise<void> {\n    // NOTE: Don't use this.runTransaction, since it requires us to already\n    // have the lease.\n    return this.simpleDb.runTransaction('readwrite', [DbOwner.store], txn => {\n      const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n      return store.get('owner').next(dbOwner => {\n        if (!this.validOwner(dbOwner)) {\n          const newDbOwner = new DbOwner(this.ownerId, Date.now());\n          log.debug(\n            LOG_TAG,\n            'No valid owner. Acquiring owner lease. Current owner:',\n            dbOwner,\n            'New owner:',\n            newDbOwner\n          );\n          return store.put('owner', newDbOwner);\n        } else {\n          log.debug(\n            LOG_TAG,\n            'Valid owner already. Failing. Current owner:',\n            dbOwner\n          );\n          this.persistenceError = new FirestoreError(\n            Code.FAILED_PRECONDITION,\n            EXISTING_OWNER_ERROR_MSG\n          );\n          return PersistencePromise.reject<void>(this.persistenceError);\n        }\n      });\n    });\n  }\n\n  /** Checks the owner lease and deletes it if we are the current owner. */\n  private releaseOwnerLease(): Promise<void> {\n    // NOTE: Don't use this.runTransaction, since it requires us to already\n    // have the lease.\n    return this.simpleDb.runTransaction('readwrite', [DbOwner.store], txn => {\n      const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n      return store.get('owner').next(dbOwner => {\n        if (dbOwner !== null && dbOwner.ownerId === this.ownerId) {\n          log.debug(LOG_TAG, 'Releasing owner lease.');\n          return store.delete('owner');\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks the owner lease and returns a rejected promise if we are not the\n   * current owner. This should be included in every transaction to guard\n   * against losing the owner lease.\n   */\n  private ensureOwnerLease(txn: SimpleDbTransaction): PersistencePromise<void> {\n    const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n    return store.get('owner').next(dbOwner => {\n      if (dbOwner === null || dbOwner.ownerId !== this.ownerId) {\n        this.persistenceError = new FirestoreError(\n          Code.FAILED_PRECONDITION,\n          EXISTING_OWNER_ERROR_MSG\n        );\n        return PersistencePromise.reject<void>(this.persistenceError);\n      } else {\n        return PersistencePromise.resolve();\n      }\n    });\n  }\n\n  /**\n   * Returns true if the provided owner exists, has a recent timestamp, and\n   * isn't zombied.\n   *\n   * NOTE: To determine if the owner is zombied, this method reads from\n   * LocalStorage which could be mildly expensive.\n   */\n  private validOwner(dbOwner: DbOwner | null): boolean {\n    const now = Date.now();\n    const minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n    const maxAcceptable = now;\n    if (dbOwner === null) {\n      return false; // no owner.\n    } else if (dbOwner.leaseTimestampMs < minAcceptable) {\n      return false; // owner lease has expired.\n    } else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n      log.error(\n        'Persistence owner-lease is in the future. Discarding.',\n        dbOwner\n      );\n      return false;\n    } else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n      return false; // owner's tab closed.\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Schedules a recurring timer to update the owner lease timestamp to prevent\n   * other tabs from taking the lease.\n   */\n  private scheduleOwnerLeaseRefreshes(): void {\n    // NOTE: This doesn't need to be scheduled on the async queue and doing so\n    // would increase the chances of us not refreshing on time if the queue is\n    // backed up for some reason.\n    this.ownerLeaseRefreshHandle = setInterval(() => {\n      const txResult = this.runTransaction('Refresh owner timestamp', txn => {\n        // NOTE: We don't need to validate the current owner contents, since\n        // runTransaction does that automatically.\n        const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n        return store.put('owner', new DbOwner(this.ownerId, Date.now()));\n      });\n\n      txResult.catch(reason => {\n        // Probably means we lost the lease. Report the error and stop trying to\n        // refresh the lease.\n        log.error(reason);\n        this.stopOwnerLeaseRefreshes();\n      });\n    }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n  }\n\n  private stopOwnerLeaseRefreshes(): void {\n    if (this.ownerLeaseRefreshHandle) {\n      clearInterval(this.ownerLeaseRefreshHandle);\n      this.ownerLeaseRefreshHandle = null;\n    }\n  }\n\n  /**\n   * Attaches a window.unload handler that will synchronously write our\n   * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n   * by tabs trying to acquire the lease to determine that the lease should be\n   * acquired immediately even if the timestamp is recent. This is particularly\n   * important for the refresh case (so the tab correctly re-acquires the owner\n   * lease). LocalStorage is used for this rather than IndexedDb because it is\n   * a synchronous API and so can be used reliably from an unload handler.\n   */\n  private attachWindowUnloadHook(): void {\n    this.windowUnloadHandler = () => {\n      // Record that we're zombied.\n      this.setZombiedOwnerId(this.ownerId);\n\n      // Attempt graceful shutdown (including releasing our owner lease), but\n      // there's no guarantee it will complete.\n      this.shutdown();\n    };\n    window.addEventListener('unload', this.windowUnloadHandler);\n  }\n\n  private detachWindowUnloadHook(): void {\n    if (this.windowUnloadHandler) {\n      window.removeEventListener('unload', this.windowUnloadHandler);\n      this.windowUnloadHandler = null;\n    }\n  }\n\n  /**\n   * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n   * zombied due to their tab closing) from LocalStorage, or null if no such\n   * record exists.\n   */\n  private getZombiedOwnerId(): string | null {\n    try {\n      const zombiedOwnerId = window.localStorage.getItem(\n        this.zombiedOwnerLocalStorageKey()\n      );\n      log.debug(LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n      return zombiedOwnerId;\n    } catch (e) {\n      // Gracefully handle if LocalStorage isn't available / working.\n      log.error(LOG_TAG, 'Failed to get zombie owner id.', e);\n      return null;\n    }\n  }\n\n  /**\n   * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n   * or, if passed null, deletes any recorded zombied owner.\n   */\n  private setZombiedOwnerId(zombieOwnerId: string | null) {\n    try {\n      if (zombieOwnerId === null) {\n        window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n      } else {\n        window.localStorage.setItem(\n          this.zombiedOwnerLocalStorageKey(),\n          zombieOwnerId\n        );\n      }\n    } catch (e) {\n      // Gracefully handle if LocalStorage isn't available / working.\n      log.error(LOG_TAG, 'Failed to set zombie owner id.', e);\n    }\n  }\n\n  private zombiedOwnerLocalStorageKey(): string {\n    return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n  }\n\n  private generateOwnerId(): string {\n    // For convenience, just use an AutoId.\n    return AutoId.newId();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}