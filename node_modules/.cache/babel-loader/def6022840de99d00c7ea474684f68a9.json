{"ast":null,"code":"import { Box3, InstancedInterleavedBuffer, InterleavedBufferAttribute, Line3, MathUtils, Matrix4, Mesh, Sphere, Vector3, Vector4 } from '../../../build/three.module.js';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nvar LineSegments2 = function LineSegments2(geometry, material) {\n  if (geometry === undefined) geometry = new LineSegmentsGeometry();\n  if (material === undefined) material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n  Mesh.call(this, geometry, material);\n  this.type = 'LineSegments2';\n};\n\nLineSegments2.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n    var start = new Vector3();\n    var end = new Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.count);\n\n      for (var i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  raycast: function () {\n    var start = new Vector4();\n    var end = new Vector4();\n    var ssOrigin = new Vector4();\n    var ssOrigin3 = new Vector3();\n    var mvMatrix = new Matrix4();\n    var line = new Line3();\n    var closestPoint = new Vector3();\n    var box = new Box3();\n    var sphere = new Sphere();\n    var clipToWorldVector = new Vector4();\n    return function raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      var ray = raycaster.ray;\n      var camera = raycaster.camera;\n      var projectionMatrix = camera.projectionMatrix;\n      var matrixWorld = this.matrixWorld;\n      var geometry = this.geometry;\n      var material = this.material;\n      var resolution = material.resolution;\n      var lineWidth = material.linewidth + threshold;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n      var near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n      // width in clip space\n\n      var ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n      // check if we intersect the sphere bounds\n\n      if (geometry.boundingSphere === null) {\n        geometry.computeBoundingSphere();\n      }\n\n      sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n      var distanceToSphere = Math.max(camera.near, sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n      clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n      clipToWorldVector.multiplyScalar(1.0 / clipToWorldVector.w);\n      clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n      var sphereMargin = Math.abs(ssMaxWidth / clipToWorldVector.w) * 0.5;\n      sphere.radius += sphereMargin;\n\n      if (raycaster.ray.intersectsSphere(sphere) === false) {\n        return;\n      } //\n      // check if we intersect the box bounds\n\n\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n\n      box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n      var distanceToBox = Math.max(camera.near, box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n      clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n      clipToWorldVector.multiplyScalar(1.0 / clipToWorldVector.w);\n      clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n      var boxMargin = Math.abs(ssMaxWidth / clipToWorldVector.w) * 0.5;\n      box.max.x += boxMargin;\n      box.max.y += boxMargin;\n      box.max.z += boxMargin;\n      box.min.x -= boxMargin;\n      box.min.y -= boxMargin;\n      box.min.z -= boxMargin;\n\n      if (raycaster.ray.intersectsBox(box) === false) {\n        return;\n      } //\n      // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n\n\n      ray.at(1, ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n      ssOrigin.w = 1;\n      ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      ssOrigin.applyMatrix4(projectionMatrix);\n      ssOrigin.multiplyScalar(1 / ssOrigin.w); // screen space\n\n      ssOrigin.x *= resolution.x / 2;\n      ssOrigin.y *= resolution.y / 2;\n      ssOrigin.z = 0;\n      ssOrigin3.copy(ssOrigin);\n      mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n      for (var i = 0, l = instanceStart.count; i < l; i++) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        start.w = 1;\n        end.w = 1; // camera space\n\n        start.applyMatrix4(mvMatrix);\n        end.applyMatrix4(mvMatrix); // skip the segment if it's entirely behind the camera\n\n        var isBehindCameraNear = start.z > near && end.z > near;\n\n        if (isBehindCameraNear) {\n          continue;\n        } // trim the segment if it extends behind camera near\n\n\n        if (start.z > near) {\n          const deltaDist = start.z - end.z;\n          const t = (start.z - near) / deltaDist;\n          start.lerp(end, t);\n        } else if (end.z > near) {\n          const deltaDist = end.z - start.z;\n          const t = (end.z - near) / deltaDist;\n          end.lerp(start, t);\n        } // clip space\n\n\n        start.applyMatrix4(projectionMatrix);\n        end.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n        start.multiplyScalar(1 / start.w);\n        end.multiplyScalar(1 / end.w); // screen space\n\n        start.x *= resolution.x / 2;\n        start.y *= resolution.y / 2;\n        end.x *= resolution.x / 2;\n        end.y *= resolution.y / 2; // create 2d segment\n\n        line.start.copy(start);\n        line.start.z = 0;\n        line.end.copy(end);\n        line.end.z = 0; // get closest point on ray to segment\n\n        var param = line.closestPointToPointParameter(ssOrigin3, true);\n        line.at(param, closestPoint); // check if the intersection point is within clip space\n\n        var zPos = MathUtils.lerp(start.z, end.z, param);\n        var isInClipSpace = zPos >= -1 && zPos <= 1;\n        var isInside = ssOrigin3.distanceTo(closestPoint) < lineWidth * 0.5;\n\n        if (isInClipSpace && isInside) {\n          line.start.fromBufferAttribute(instanceStart, i);\n          line.end.fromBufferAttribute(instanceEnd, i);\n          line.start.applyMatrix4(matrixWorld);\n          line.end.applyMatrix4(matrixWorld);\n          var pointOnLine = new Vector3();\n          var point = new Vector3();\n          ray.distanceSqToSegment(line.start, line.end, point, pointOnLine);\n          intersects.push({\n            point: point,\n            pointOnLine: pointOnLine,\n            distance: ray.origin.distanceTo(point),\n            object: this,\n            face: null,\n            faceIndex: i,\n            uv: null,\n            uv2: null\n          });\n        }\n      }\n    };\n  }()\n});\nexport { LineSegments2 };","map":{"version":3,"sources":["C:/Users/junecsnp/Desktop/JuneWeb+Shoe/node_modules/three/examples/jsm/lines/LineSegments2.js"],"names":["Box3","InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Sphere","Vector3","Vector4","LineSegmentsGeometry","LineMaterial","LineSegments2","geometry","material","undefined","color","Math","random","call","type","prototype","Object","assign","create","constructor","isLineSegments2","computeLineDistances","start","end","instanceStart","attributes","instanceEnd","lineDistances","Float32Array","count","i","j","l","fromBufferAttribute","distanceTo","instanceDistanceBuffer","setAttribute","raycast","ssOrigin","ssOrigin3","mvMatrix","line","closestPoint","box","sphere","clipToWorldVector","raycaster","intersects","camera","console","error","threshold","params","Line2","ray","projectionMatrix","matrixWorld","resolution","lineWidth","linewidth","near","ssMaxWidth","max","width","height","boundingSphere","computeBoundingSphere","copy","applyMatrix4","distanceToSphere","distanceToPoint","origin","set","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","radius","intersectsSphere","boundingBox","computeBoundingBox","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2"],"mappings":"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","sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from '../../../build/three.module.js';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nvar LineSegments2 = function ( geometry, material ) {\n\n\tif ( geometry === undefined ) geometry = new LineSegmentsGeometry();\n\tif ( material === undefined ) material = new LineMaterial( { color: Math.random() * 0xffffff } );\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'LineSegments2';\n\n};\n\nLineSegments2.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: LineSegments2,\n\n\tisLineSegments2: true,\n\n\tcomputeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\t\t\tvar lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\t\tfor ( var i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );\n\n\t\t\t}\n\n\t\t\tvar instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() ),\n\n\traycast: ( function () {\n\n\t\tvar start = new Vector4();\n\t\tvar end = new Vector4();\n\n\t\tvar ssOrigin = new Vector4();\n\t\tvar ssOrigin3 = new Vector3();\n\t\tvar mvMatrix = new Matrix4();\n\t\tvar line = new Line3();\n\t\tvar closestPoint = new Vector3();\n\n\t\tvar box = new Box3();\n\t\tvar sphere = new Sphere();\n\t\tvar clipToWorldVector = new Vector4();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tif ( raycaster.camera === null ) {\n\n\t\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t\t}\n\n\t\t\tvar threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t\tvar ray = raycaster.ray;\n\t\t\tvar camera = raycaster.camera;\n\t\t\tvar projectionMatrix = camera.projectionMatrix;\n\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar resolution = material.resolution;\n\t\t\tvar lineWidth = material.linewidth + threshold;\n\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t\t// camera forward is negative\n\t\t\tvar near = - camera.near;\n\n\t\t\t// clip space is [ - 1, 1 ] so multiply by two to get the full\n\t\t\t// width in clip space\n\t\t\tvar ssMaxWidth = 2.0 * Math.max( lineWidth / resolution.width, lineWidth / resolution.height );\n\n\t\t\t//\n\n\t\t\t// check if we intersect the sphere bounds\n\t\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tsphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\t\t\tvar distanceToSphere = Math.max( camera.near, sphere.distanceToPoint( ray.origin ) );\n\n\t\t\t// get the w component to scale the world space line width\n\t\t\tclipToWorldVector.set( 0, 0, - distanceToSphere, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t\t\tclipToWorldVector.multiplyScalar( 1.0 / clipToWorldVector.w );\n\t\t\tclipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\t// increase the sphere bounds by the worst case line screen space width\n\t\t\tvar sphereMargin = Math.abs( ssMaxWidth / clipToWorldVector.w ) * 0.5;\n\t\t\tsphere.radius += sphereMargin;\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\t// check if we intersect the box bounds\n\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tbox.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\t\t\tvar distanceToBox = Math.max( camera.near, box.distanceToPoint( ray.origin ) );\n\n\t\t\t// get the w component to scale the world space line width\n\t\t\tclipToWorldVector.set( 0, 0, - distanceToBox, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t\t\tclipToWorldVector.multiplyScalar( 1.0 / clipToWorldVector.w );\n\t\t\tclipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\t// increase the sphere bounds by the worst case line screen space width\n\t\t\tvar boxMargin = Math.abs( ssMaxWidth / clipToWorldVector.w ) * 0.5;\n\t\t\tbox.max.x += boxMargin;\n\t\t\tbox.max.y += boxMargin;\n\t\t\tbox.max.z += boxMargin;\n\t\t\tbox.min.x -= boxMargin;\n\t\t\tbox.min.y -= boxMargin;\n\t\t\tbox.min.z -= boxMargin;\n\n\t\t\tif ( raycaster.ray.intersectsBox( box ) === false ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t\t// applying the projection matrix.\n\t\t\tray.at( 1, ssOrigin );\n\n\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\tssOrigin.w = 1;\n\t\t\tssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t\tssOrigin.applyMatrix4( projectionMatrix );\n\t\t\tssOrigin.multiplyScalar( 1 / ssOrigin.w );\n\n\t\t\t// screen space\n\t\t\tssOrigin.x *= resolution.x / 2;\n\t\t\tssOrigin.y *= resolution.y / 2;\n\t\t\tssOrigin.z = 0;\n\n\t\t\tssOrigin3.copy( ssOrigin );\n\n\t\t\tmvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\t\tfor ( var i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\tstart.w = 1;\n\t\t\t\tend.w = 1;\n\n\t\t\t\t// camera space\n\t\t\t\tstart.applyMatrix4( mvMatrix );\n\t\t\t\tend.applyMatrix4( mvMatrix );\n\n\t\t\t\t// skip the segment if it's entirely behind the camera\n\t\t\t\tvar isBehindCameraNear = start.z > near && end.z > near;\n\t\t\t\tif ( isBehindCameraNear ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// trim the segment if it extends behind camera near\n\t\t\t\tif ( start.z > near ) {\n\n\t\t\t\t\tconst deltaDist = start.z - end.z;\n\t\t\t\t\tconst t = ( start.z - near ) / deltaDist;\n\t\t\t\t\tstart.lerp( end, t );\n\n\t\t\t\t} else if ( end.z > near ) {\n\n\t\t\t\t\tconst deltaDist = end.z - start.z;\n\t\t\t\t\tconst t = ( end.z - near ) / deltaDist;\n\t\t\t\t\tend.lerp( start, t );\n\n\t\t\t\t}\n\n\t\t\t\t// clip space\n\t\t\t\tstart.applyMatrix4( projectionMatrix );\n\t\t\t\tend.applyMatrix4( projectionMatrix );\n\n\t\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t\tstart.multiplyScalar( 1 / start.w );\n\t\t\t\tend.multiplyScalar( 1 / end.w );\n\n\t\t\t\t// screen space\n\t\t\t\tstart.x *= resolution.x / 2;\n\t\t\t\tstart.y *= resolution.y / 2;\n\n\t\t\t\tend.x *= resolution.x / 2;\n\t\t\t\tend.y *= resolution.y / 2;\n\n\t\t\t\t// create 2d segment\n\t\t\t\tline.start.copy( start );\n\t\t\t\tline.start.z = 0;\n\n\t\t\t\tline.end.copy( end );\n\t\t\t\tline.end.z = 0;\n\n\t\t\t\t// get closest point on ray to segment\n\t\t\t\tvar param = line.closestPointToPointParameter( ssOrigin3, true );\n\t\t\t\tline.at( param, closestPoint );\n\n\t\t\t\t// check if the intersection point is within clip space\n\t\t\t\tvar zPos = MathUtils.lerp( start.z, end.z, param );\n\t\t\t\tvar isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\t\tvar isInside = ssOrigin3.distanceTo( closestPoint ) < lineWidth * 0.5;\n\n\t\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t\tline.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t\tline.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t\tline.start.applyMatrix4( matrixWorld );\n\t\t\t\t\tline.end.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar pointOnLine = new Vector3();\n\t\t\t\t\tvar point = new Vector3();\n\n\t\t\t\t\tray.distanceSqToSegment( line.start, line.end, point, pointOnLine );\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tpoint: point,\n\t\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\t\tobject: this,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\t\tuv: null,\n\t\t\t\t\t\tuv2: null,\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() )\n\n} );\n\nexport { LineSegments2 };\n"]},"metadata":{},"sourceType":"module"}