{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Blob } from '../api/blob';\nimport { GeoPoint } from '../api/geo_point';\nimport { DatabaseId } from '../core/database_info';\nimport { Bound, Direction, NanFilter, NullFilter, OrderBy, Query, RelationFilter, RelationOp } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { QueryPurpose } from '../local/query_data';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport * as fieldValue from '../model/field_value';\nimport { DeleteMutation, FieldMask, FieldTransform, MutationResult, PatchMutation, Precondition, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as obj from '../util/obj';\nimport * as typeUtils from '../util/types';\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode, mapRpcCodeFromCode } from './rpc_error';\nimport { DocumentWatchChange, ExistenceFilterChange, WatchTargetChange, WatchTargetChangeState } from './watch_change';\n\nvar DIRECTIONS = function () {\n  var dirs = {};\n  dirs[Direction.ASCENDING.name] = 'ASCENDING';\n  dirs[Direction.DESCENDING.name] = 'DESCENDING';\n  return dirs;\n}();\n\nvar OPERATORS = function () {\n  var ops = {};\n  ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';\n  ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n  ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n  ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n  ops[RelationOp.EQUAL.name] = 'EQUAL';\n  return ops;\n}();\n\nfunction assertPresent(value, description) {\n  assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');\n}\n\nfunction parseInt64(value) {\n  // TODO(bjornick): Handle int64 greater than 53 bits.\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return parseInt(value, 10);\n  } else {\n    return fail(\"can't parse \" + value);\n  }\n}\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\n\n\nvar JsonProtoSerializer =\n/** @class */\nfunction () {\n  function JsonProtoSerializer(databaseId, options) {\n    this.databaseId = databaseId;\n    this.options = options;\n  }\n\n  JsonProtoSerializer.prototype.emptyByteString = function () {\n    if (this.options.useProto3Json) {\n      return '';\n    } else {\n      return new Uint8Array(0);\n    }\n  };\n\n  JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {\n    // byteStrings can be either string or UInt8Array, but the typings say\n    // it's always a string. Cast as string to avoid type check failing\n    return byteString;\n  };\n\n  JsonProtoSerializer.prototype.fromRpcStatus = function (status) {\n    var code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n  };\n  /**\n   * Returns a value for a number (or undefined) that's appropriate to put into\n   * a google.protobuf.Int32Value proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"number\" because that's what\n   * our generated proto interfaces say Int32Value must be. But GRPC actually\n   * expects a { value: <number> } struct.\n   */\n\n\n  JsonProtoSerializer.prototype.toInt32Value = function (val) {\n    if (!typeUtils.isNullOrUndefined(val)) {\n      return {\n        value: val\n      };\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Returns a number (or null) from a google.protobuf.Int32Value proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as accepting \"number\" because that's what\n   * our generated proto interfaces say Int32Value must be, but it actually\n   * accepts { value: number } to match our serialization in toInt32Value().\n   */\n\n\n  JsonProtoSerializer.prototype.fromInt32Value = function (val) {\n    var result;\n\n    if (typeof val === 'object') {\n      result = val.value;\n    } else {\n      // We accept raw numbers (without the {value: ... } wrapper) for\n      // compatibility with legacy persisted data.\n      result = val;\n    }\n\n    return typeUtils.isNullOrUndefined(result) ? null : result;\n  };\n  /**\n   * Returns a value for a Date that's appropriate to put into a proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"string\" because that's what\n   * our generated proto interfaces say dates must be. But it's easier and safer\n   * to actually return a Timestamp proto.\n   */\n\n\n  JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {\n    return {\n      seconds: timestamp.seconds,\n      nanos: timestamp.nanos // tslint:disable-next-line:no-any\n\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromTimestamp = function (date) {\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n      // TODO(b/37282237): Use strings for Proto3 timestamps\n      // assert(this.options.useProto3Json,\n      //   'The timestamp string format requires Proto3.');\n      return Timestamp.fromISOString(date);\n    } else {\n      assert(!!date, 'Cannot deserialize null or undefined timestamp.'); // TODO(b/37282237): Use strings for Proto3 timestamps\n      // assert(!this.options.useProto3Json,\n      //   'The timestamp instance format requires Proto JS.');\n\n      var seconds = parseInt64(date.seconds || '0');\n      var nanos = date.nanos || 0;\n      return new Timestamp(seconds, nanos);\n    }\n  };\n  /**\n   * Returns a value for bytes that's appropriate to put in a proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"string\" because that's what\n   * our generated proto interfaces say bytes must be. But it should return\n   * an Uint8Array in Node.\n   */\n\n\n  JsonProtoSerializer.prototype.toBytes = function (bytes) {\n    if (this.options.useProto3Json) {\n      return bytes.toBase64();\n    } else {\n      // The typings say it's a string, but it needs to be a Uint8Array in Node.\n      return this.unsafeCastProtoByteString(bytes.toUint8Array());\n    }\n  };\n  /**\n   * Parse the blob from the protos into the internal Blob class. Note that the\n   * typings assume all blobs are strings, but they are actually Uint8Arrays\n   * on Node.\n   */\n\n\n  JsonProtoSerializer.prototype.fromBlob = function (blob) {\n    if (typeof blob === 'string') {\n      assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');\n      return Blob.fromBase64String(blob);\n    } else {\n      assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');\n      return Blob.fromUint8Array(blob);\n    }\n  };\n\n  JsonProtoSerializer.prototype.toVersion = function (version) {\n    return this.toTimestamp(version.toTimestamp());\n  };\n\n  JsonProtoSerializer.prototype.fromVersion = function (version) {\n    assert(!!version, \"Trying to deserialize version that isn't set\");\n    return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n  };\n\n  JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {\n    return this.fullyQualifiedPrefixPath(databaseId).child('documents').child(path).canonicalString();\n  };\n\n  JsonProtoSerializer.prototype.fromResourceName = function (name) {\n    var resource = ResourcePath.fromString(name);\n    assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());\n    return resource;\n  };\n\n  JsonProtoSerializer.prototype.toName = function (key) {\n    return this.toResourceName(this.databaseId, key.path);\n  };\n\n  JsonProtoSerializer.prototype.fromName = function (name) {\n    var resource = this.fromResourceName(name);\n    assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' + resource.get(1) + ' vs ' + this.databaseId.projectId);\n    assert(!resource.get(3) && !this.databaseId.database || resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' + resource.get(3) + ' vs ' + this.databaseId.database);\n    return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n  };\n\n  JsonProtoSerializer.prototype.toQueryPath = function (path) {\n    if (path.length === 0) {\n      // If the path is empty, the backend requires we leave off the /documents\n      // at the end.\n      return this.encodedDatabaseId;\n    }\n\n    return this.toResourceName(this.databaseId, path);\n  };\n\n  JsonProtoSerializer.prototype.fromQueryPath = function (name) {\n    var resourceName = this.fromResourceName(name);\n\n    if (resourceName.length === 4) {\n      return ResourcePath.EMPTY_PATH;\n    }\n\n    return this.extractLocalPathFromResourceName(resourceName);\n  };\n\n  Object.defineProperty(JsonProtoSerializer.prototype, \"encodedDatabaseId\", {\n    get: function get() {\n      var path = new ResourcePath(['projects', this.databaseId.projectId, 'databases', this.databaseId.database]);\n      return path.canonicalString();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {\n    return new ResourcePath(['projects', databaseId.projectId, 'databases', databaseId.database]);\n  };\n\n  JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {\n    assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());\n    return resourceName.popFirst(5);\n  };\n\n  JsonProtoSerializer.prototype.isValidResourceName = function (path) {\n    // Resource names have at least 4 components (project ID, database ID)\n    return path.length >= 4 && path.get(0) === 'projects' && path.get(2) === 'databases';\n  };\n\n  JsonProtoSerializer.prototype.toValue = function (val) {\n    if (val instanceof fieldValue.NullValue) {\n      return {\n        nullValue: 'NULL_VALUE'\n      };\n    } else if (val instanceof fieldValue.BooleanValue) {\n      return {\n        booleanValue: val.value()\n      };\n    } else if (val instanceof fieldValue.IntegerValue) {\n      return {\n        integerValue: '' + val.value()\n      };\n    } else if (val instanceof fieldValue.DoubleValue) {\n      var doubleValue = val.value();\n\n      if (this.options.useProto3Json) {\n        // Proto 3 let's us encode NaN and Infinity as string values as\n        // expected by the backend. This is currently not checked by our unit\n        // tests because they rely on protobuf.js.\n        if (isNaN(doubleValue)) {\n          return {\n            doubleValue: 'NaN'\n          };\n        } else if (doubleValue === Infinity) {\n          return {\n            doubleValue: 'Infinity'\n          };\n        } else if (doubleValue === -Infinity) {\n          return {\n            doubleValue: '-Infinity'\n          };\n        }\n      }\n\n      return {\n        doubleValue: val.value()\n      };\n    } else if (val instanceof fieldValue.StringValue) {\n      return {\n        stringValue: val.value()\n      };\n    } else if (val instanceof fieldValue.ObjectValue) {\n      return {\n        mapValue: this.toMapValue(val)\n      };\n    } else if (val instanceof fieldValue.ArrayValue) {\n      return {\n        arrayValue: this.toArrayValue(val)\n      };\n    } else if (val instanceof fieldValue.TimestampValue) {\n      return {\n        timestampValue: this.toTimestamp(val.internalValue)\n      };\n    } else if (val instanceof fieldValue.GeoPointValue) {\n      return {\n        geoPointValue: {\n          latitude: val.value().latitude,\n          longitude: val.value().longitude\n        }\n      };\n    } else if (val instanceof fieldValue.BlobValue) {\n      return {\n        bytesValue: this.toBytes(val.value())\n      };\n    } else if (val instanceof fieldValue.RefValue) {\n      return {\n        referenceValue: this.toResourceName(val.databaseId, val.key.path)\n      };\n    } else {\n      return fail('Unknown FieldValue ' + JSON.stringify(val));\n    }\n  };\n\n  JsonProtoSerializer.prototype.fromValue = function (obj) {\n    var _this = this; // tslint:disable-next-line:no-any\n\n\n    var type = obj['value_type'];\n\n    if (hasTag(obj, type, 'nullValue')) {\n      return fieldValue.NullValue.INSTANCE;\n    } else if (hasTag(obj, type, 'booleanValue')) {\n      return fieldValue.BooleanValue.of(obj.booleanValue);\n    } else if (hasTag(obj, type, 'integerValue')) {\n      return new fieldValue.IntegerValue(parseInt64(obj.integerValue));\n    } else if (hasTag(obj, type, 'doubleValue')) {\n      if (this.options.useProto3Json) {\n        // Proto 3 uses the string values 'NaN' and 'Infinity'.\n        if (obj.doubleValue === 'NaN') {\n          return fieldValue.DoubleValue.NAN;\n        } else if (obj.doubleValue === 'Infinity') {\n          return fieldValue.DoubleValue.POSITIVE_INFINITY;\n        } else if (obj.doubleValue === '-Infinity') {\n          return fieldValue.DoubleValue.NEGATIVE_INFINITY;\n        }\n      }\n\n      return new fieldValue.DoubleValue(obj.doubleValue);\n    } else if (hasTag(obj, type, 'stringValue')) {\n      return new fieldValue.StringValue(obj.stringValue);\n    } else if (hasTag(obj, type, 'mapValue')) {\n      return this.fromFields(obj.mapValue.fields || {});\n    } else if (hasTag(obj, type, 'arrayValue')) {\n      // \"values\" is not present if the array is empty\n      assertPresent(obj.arrayValue, 'arrayValue');\n      var values = obj.arrayValue.values || [];\n      return new fieldValue.ArrayValue(values.map(function (v) {\n        return _this.fromValue(v);\n      }));\n    } else if (hasTag(obj, type, 'timestampValue')) {\n      assertPresent(obj.timestampValue, 'timestampValue');\n      return new fieldValue.TimestampValue(this.fromTimestamp(obj.timestampValue));\n    } else if (hasTag(obj, type, 'geoPointValue')) {\n      assertPresent(obj.geoPointValue, 'geoPointValue');\n      var latitude = obj.geoPointValue.latitude || 0;\n      var longitude = obj.geoPointValue.longitude || 0;\n      return new fieldValue.GeoPointValue(new GeoPoint(latitude, longitude));\n    } else if (hasTag(obj, type, 'bytesValue')) {\n      assertPresent(obj.bytesValue, 'bytesValue');\n      var blob = this.fromBlob(obj.bytesValue);\n      return new fieldValue.BlobValue(blob);\n    } else if (hasTag(obj, type, 'referenceValue')) {\n      assertPresent(obj.referenceValue, 'referenceValue');\n      var resourceName = this.fromResourceName(obj.referenceValue);\n      var dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));\n      var key = new DocumentKey(this.extractLocalPathFromResourceName(resourceName));\n      return new fieldValue.RefValue(dbId, key);\n    } else {\n      return fail('Unknown Value proto ' + JSON.stringify(obj));\n    }\n  };\n  /** Creates an api.Document from key and fields (but no create/update time) */\n\n\n  JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {\n    return {\n      name: this.toName(key),\n      fields: this.toFields(fields)\n    };\n  };\n\n  JsonProtoSerializer.prototype.toDocument = function (document) {\n    assert(!document.hasLocalMutations, \"Can't serialize documents with mutations.\");\n    return {\n      name: this.toName(document.key),\n      fields: this.toFields(document.data),\n      updateTime: this.toTimestamp(document.version.toTimestamp())\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromDocument = function (document) {\n    return new Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), {\n      hasLocalMutations: false\n    });\n  };\n\n  JsonProtoSerializer.prototype.toFields = function (fields) {\n    var _this = this;\n\n    var result = {};\n    fields.forEach(function (key, value) {\n      result[key] = _this.toValue(value);\n    });\n    return result;\n  };\n\n  JsonProtoSerializer.prototype.fromFields = function (object) {\n    var _this = this; // Proto map<string, Value> gets mapped to Object, so cast it.\n\n\n    var map = object;\n    var result = fieldValue.ObjectValue.EMPTY;\n    obj.forEach(map, function (key, value) {\n      result = result.set(new FieldPath([key]), _this.fromValue(value));\n    });\n    return result;\n  };\n\n  JsonProtoSerializer.prototype.toMapValue = function (map) {\n    return {\n      fields: this.toFields(map)\n    };\n  };\n\n  JsonProtoSerializer.prototype.toArrayValue = function (array) {\n    var _this = this;\n\n    var result = [];\n    array.forEach(function (value) {\n      result.push(_this.toValue(value));\n    });\n    return {\n      values: result\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromFound = function (doc) {\n    assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');\n    assertPresent(doc.found.name, 'doc.found.name');\n    assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n    var key = this.fromName(doc.found.name);\n    var version = this.fromVersion(doc.found.updateTime);\n    var fields = this.fromFields(doc.found.fields || {});\n    return new Document(key, version, fields, {\n      hasLocalMutations: false\n    });\n  };\n\n  JsonProtoSerializer.prototype.fromMissing = function (result) {\n    assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');\n    assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');\n    var key = this.fromName(result.missing);\n    var version = this.fromVersion(result.readTime);\n    return new NoDocument(key, version);\n  };\n\n  JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {\n    // tslint:disable-next-line:no-any\n    var type = result['result'];\n\n    if (hasTag(result, type, 'found')) {\n      return this.fromFound(result);\n    } else if (hasTag(result, type, 'missing')) {\n      return this.fromMissing(result);\n    }\n\n    return fail('invalid batch get response: ' + JSON.stringify(result));\n  };\n\n  JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {\n    switch (state) {\n      case WatchTargetChangeState.Added:\n        return 'ADD';\n\n      case WatchTargetChangeState.Current:\n        return 'CURRENT';\n\n      case WatchTargetChangeState.NoChange:\n        return 'NO_CHANGE';\n\n      case WatchTargetChangeState.Removed:\n        return 'REMOVE';\n\n      case WatchTargetChangeState.Reset:\n        return 'RESET';\n\n      default:\n        return fail('Unknown WatchTargetChangeState: ' + state);\n    }\n  };\n\n  JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {\n    if (watchChange instanceof ExistenceFilterChange) {\n      return {\n        filter: {\n          count: watchChange.existenceFilter.count,\n          targetId: watchChange.targetId\n        }\n      };\n    }\n\n    if (watchChange instanceof DocumentWatchChange) {\n      if (watchChange.newDoc instanceof Document) {\n        var doc = watchChange.newDoc;\n        return {\n          documentChange: {\n            document: {\n              name: this.toName(doc.key),\n              fields: this.toFields(doc.data),\n              updateTime: this.toVersion(doc.version)\n            },\n            targetIds: watchChange.updatedTargetIds,\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      } else if (watchChange.newDoc instanceof NoDocument) {\n        var doc = watchChange.newDoc;\n        return {\n          documentDelete: {\n            document: this.toName(doc.key),\n            readTime: this.toVersion(doc.version),\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      } else if (watchChange.newDoc === null) {\n        return {\n          documentRemove: {\n            document: this.toName(watchChange.key),\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      }\n    }\n\n    if (watchChange instanceof WatchTargetChange) {\n      var cause = undefined;\n\n      if (watchChange.cause) {\n        cause = {\n          code: mapRpcCodeFromCode(watchChange.cause.code),\n          message: watchChange.cause.message\n        };\n      }\n\n      return {\n        targetChange: {\n          targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n          targetIds: watchChange.targetIds,\n          resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n          cause: cause\n        }\n      };\n    }\n\n    return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n  };\n\n  JsonProtoSerializer.prototype.fromWatchChange = function (change) {\n    // tslint:disable-next-line:no-any\n    var type = change['response_type'];\n    var watchChange;\n\n    if (hasTag(change, type, 'targetChange')) {\n      assertPresent(change.targetChange, 'targetChange'); // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n      // if unset\n\n      var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n      var targetIds = change.targetChange.targetIds || [];\n      var resumeToken = change.targetChange.resumeToken || this.emptyByteString();\n      var causeProto = change.targetChange.cause;\n      var cause = causeProto && this.fromRpcStatus(causeProto);\n      watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n    } else if (hasTag(change, type, 'documentChange')) {\n      assertPresent(change.documentChange, 'documentChange');\n      assertPresent(change.documentChange.document, 'documentChange.name');\n      assertPresent(change.documentChange.document.name, 'documentChange.document.name');\n      assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');\n      var entityChange = change.documentChange;\n      var key = this.fromName(entityChange.document.name);\n      var version = this.fromVersion(entityChange.document.updateTime);\n      var fields = this.fromFields(entityChange.document.fields || {});\n      var doc = new Document(key, version, fields, {\n        hasLocalMutations: false\n      });\n      var updatedTargetIds = entityChange.targetIds || [];\n      var removedTargetIds = entityChange.removedTargetIds || [];\n      watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n    } else if (hasTag(change, type, 'documentDelete')) {\n      assertPresent(change.documentDelete, 'documentDelete');\n      assertPresent(change.documentDelete.document, 'documentDelete.document');\n      var docDelete = change.documentDelete;\n      var key = this.fromName(docDelete.document);\n      var version = docDelete.readTime ? this.fromVersion(docDelete.readTime) : SnapshotVersion.forDeletedDoc();\n      var doc = new NoDocument(key, version);\n      var removedTargetIds = docDelete.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    } else if (hasTag(change, type, 'documentRemove')) {\n      assertPresent(change.documentRemove, 'documentRemove');\n      assertPresent(change.documentRemove.document, 'documentRemove');\n      var docRemove = change.documentRemove;\n      var key = this.fromName(docRemove.document);\n      var removedTargetIds = docRemove.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    } else if (hasTag(change, type, 'filter')) {\n      // TODO(dimond): implement existence filter parsing with strategy.\n      assertPresent(change.filter, 'filter');\n      assertPresent(change.filter.targetId, 'filter.targetId');\n      var filter = change.filter;\n      var count = filter.count || 0;\n      var existenceFilter = new ExistenceFilter(count);\n      var targetId = filter.targetId;\n      watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    } else {\n      return fail('Unknown change type ' + JSON.stringify(change));\n    }\n\n    return watchChange;\n  };\n\n  JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {\n    if (state === 'NO_CHANGE') {\n      return WatchTargetChangeState.NoChange;\n    } else if (state === 'ADD') {\n      return WatchTargetChangeState.Added;\n    } else if (state === 'REMOVE') {\n      return WatchTargetChangeState.Removed;\n    } else if (state === 'CURRENT') {\n      return WatchTargetChangeState.Current;\n    } else if (state === 'RESET') {\n      return WatchTargetChangeState.Reset;\n    } else {\n      return fail('Got unexpected TargetChange.state: ' + state);\n    }\n  };\n\n  JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    // tslint:disable-next-line:no-any\n    var type = change['response_type'];\n\n    if (!hasTag(change, type, 'targetChange')) {\n      return SnapshotVersion.MIN;\n    }\n\n    var targetChange = change.targetChange;\n\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n      return SnapshotVersion.MIN;\n    }\n\n    if (!targetChange.readTime) {\n      return SnapshotVersion.MIN;\n    }\n\n    return this.fromVersion(targetChange.readTime);\n  };\n\n  JsonProtoSerializer.prototype.toMutation = function (mutation) {\n    var _this = this;\n\n    var result;\n\n    if (mutation instanceof SetMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.value)\n      };\n    } else if (mutation instanceof DeleteMutation) {\n      result = {\n        delete: this.toName(mutation.key)\n      };\n    } else if (mutation instanceof PatchMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.data),\n        updateMask: this.toDocumentMask(mutation.fieldMask)\n      };\n    } else if (mutation instanceof TransformMutation) {\n      result = {\n        transform: {\n          document: this.toName(mutation.key),\n          fieldTransforms: mutation.fieldTransforms.map(function (transform) {\n            return _this.toFieldTransform(transform);\n          })\n        }\n      };\n    } else {\n      return fail('Unknown mutation type ' + mutation.type);\n    }\n\n    if (!mutation.precondition.isNone) {\n      result.currentDocument = this.toPrecondition(mutation.precondition);\n    }\n\n    return result;\n  };\n\n  JsonProtoSerializer.prototype.fromMutation = function (proto) {\n    var _this = this;\n\n    var precondition = proto.currentDocument ? this.fromPrecondition(proto.currentDocument) : Precondition.NONE;\n\n    if (proto.update) {\n      assertPresent(proto.update.name, 'name');\n      var key = this.fromName(proto.update.name);\n      var value = this.fromFields(proto.update.fields || {});\n\n      if (proto.updateMask) {\n        var fieldMask = this.fromDocumentMask(proto.updateMask);\n        return new PatchMutation(key, value, fieldMask, precondition);\n      } else {\n        return new SetMutation(key, value, precondition);\n      }\n    } else if (proto.delete) {\n      var key = this.fromName(proto.delete);\n      return new DeleteMutation(key, precondition);\n    } else if (proto.transform) {\n      var key = this.fromName(proto.transform.document);\n      var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {\n        return _this.fromFieldTransform(transform);\n      });\n      assert(precondition.exists === true, 'Transforms only support precondition \"exists == true\"');\n      return new TransformMutation(key, fieldTransforms);\n    } else {\n      return fail('unknown mutation proto: ' + JSON.stringify(proto));\n    }\n  };\n\n  JsonProtoSerializer.prototype.toPrecondition = function (precondition) {\n    assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n\n    if (precondition.updateTime !== undefined) {\n      return {\n        updateTime: this.toVersion(precondition.updateTime)\n      };\n    } else if (precondition.exists !== undefined) {\n      return {\n        exists: precondition.exists\n      };\n    } else {\n      return fail('Unknown precondition');\n    }\n  };\n\n  JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {\n    if (precondition.updateTime !== undefined) {\n      return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n    } else if (precondition.exists !== undefined) {\n      return Precondition.exists(precondition.exists);\n    } else {\n      return Precondition.NONE;\n    }\n  };\n\n  JsonProtoSerializer.prototype.fromWriteResult = function (proto) {\n    var _this = this; // NOTE: Deletes don't have an updateTime.\n\n\n    var version = proto.updateTime ? this.fromVersion(proto.updateTime) : null;\n    var transformResults = null;\n\n    if (proto.transformResults && proto.transformResults.length > 0) {\n      transformResults = proto.transformResults.map(function (result) {\n        return _this.fromValue(result);\n      });\n    }\n\n    return new MutationResult(version, transformResults);\n  };\n\n  JsonProtoSerializer.prototype.fromWriteResults = function (protos) {\n    var _this = this;\n\n    return (protos || []).map(function (proto) {\n      return _this.fromWriteResult(proto);\n    });\n  };\n\n  JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {\n    assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);\n    return {\n      fieldPath: fieldTransform.field.canonicalString(),\n      setToServerValue: 'REQUEST_TIME'\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {\n    assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));\n    var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);\n    return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n  };\n\n  JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {\n    return {\n      documents: [this.toQueryPath(query.path)]\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {\n    var count = documentsTarget.documents.length;\n    assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);\n    var name = documentsTarget.documents[0];\n    return Query.atPath(this.fromQueryPath(name));\n  };\n\n  JsonProtoSerializer.prototype.toQueryTarget = function (query) {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    var result = {\n      structuredQuery: {}\n    };\n\n    if (query.path.isEmpty()) {\n      result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);\n    } else {\n      var path = query.path;\n      assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');\n      result.parent = this.toQueryPath(path.popLast());\n      result.structuredQuery.from = [{\n        collectionId: path.lastSegment()\n      }];\n    }\n\n    var where = this.toFilter(query.filters);\n\n    if (where) {\n      result.structuredQuery.where = where;\n    }\n\n    var orderBy = this.toOrder(query.orderBy);\n\n    if (orderBy) {\n      result.structuredQuery.orderBy = orderBy;\n    }\n\n    var limit = this.toInt32Value(query.limit);\n\n    if (limit !== undefined) {\n      result.structuredQuery.limit = limit;\n    }\n\n    if (query.startAt) {\n      result.structuredQuery.startAt = this.toCursor(query.startAt);\n    }\n\n    if (query.endAt) {\n      result.structuredQuery.endAt = this.toCursor(query.endAt);\n    }\n\n    return result;\n  };\n\n  JsonProtoSerializer.prototype.fromQueryTarget = function (target) {\n    var path = this.fromQueryPath(target.parent);\n    var query = target.structuredQuery;\n    var fromCount = query.from ? query.from.length : 0;\n\n    if (fromCount > 0) {\n      assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');\n      var from = query.from[0];\n      path = path.child(from.collectionId);\n    }\n\n    var filterBy = [];\n\n    if (query.where) {\n      filterBy = this.fromFilter(query.where);\n    }\n\n    var orderBy = [];\n\n    if (query.orderBy) {\n      orderBy = this.fromOrder(query.orderBy);\n    }\n\n    var limit = null;\n\n    if (query.limit) {\n      limit = this.fromInt32Value(query.limit);\n    }\n\n    var startAt = null;\n\n    if (query.startAt) {\n      startAt = this.fromCursor(query.startAt);\n    }\n\n    var endAt = null;\n\n    if (query.endAt) {\n      endAt = this.fromCursor(query.endAt);\n    }\n\n    return new Query(path, orderBy, filterBy, limit, startAt, endAt);\n  };\n\n  JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {\n    var value = this.toLabel(queryData.purpose);\n\n    if (value == null) {\n      return null;\n    } else {\n      return {\n        'goog-listen-tags': value\n      };\n    }\n  };\n\n  JsonProtoSerializer.prototype.toLabel = function (purpose) {\n    switch (purpose) {\n      case QueryPurpose.Listen:\n        return null;\n\n      case QueryPurpose.ExistenceFilterMismatch:\n        return 'existence-filter-mismatch';\n\n      case QueryPurpose.LimboResolution:\n        return 'limbo-document';\n\n      default:\n        return fail('Unrecognized query purpose: ' + purpose);\n    }\n  };\n\n  JsonProtoSerializer.prototype.toTarget = function (queryData) {\n    var result;\n    var query = queryData.query;\n\n    if (query.isDocumentQuery()) {\n      result = {\n        documents: this.toDocumentsTarget(query)\n      };\n    } else {\n      result = {\n        query: this.toQueryTarget(query)\n      };\n    }\n\n    result.targetId = queryData.targetId;\n\n    if (queryData.resumeToken.length > 0) {\n      result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);\n    }\n\n    return result;\n  };\n\n  JsonProtoSerializer.prototype.toFilter = function (filters) {\n    var _this = this;\n\n    if (filters.length === 0) return;\n    var protos = filters.map(function (filter) {\n      return filter instanceof RelationFilter ? _this.toRelationFilter(filter) : _this.toUnaryFilter(filter);\n    });\n\n    if (protos.length === 1) {\n      return protos[0];\n    }\n\n    return {\n      compositeFilter: {\n        op: 'AND',\n        filters: protos\n      }\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromFilter = function (filter) {\n    var _this = this;\n\n    if (!filter) {\n      return [];\n    } else if (filter.unaryFilter !== undefined) {\n      return [this.fromUnaryFilter(filter)];\n    } else if (filter.fieldFilter !== undefined) {\n      return [this.fromRelationFilter(filter)];\n    } else if (filter.compositeFilter !== undefined) {\n      return filter.compositeFilter.filters.map(function (f) {\n        return _this.fromFilter(f);\n      }).reduce(function (accum, current) {\n        return accum.concat(current);\n      });\n    } else {\n      return fail('Unknown filter: ' + JSON.stringify(filter));\n    }\n  };\n\n  JsonProtoSerializer.prototype.toOrder = function (orderBys) {\n    var _this = this;\n\n    if (orderBys.length === 0) return;\n    return orderBys.map(function (order) {\n      return _this.toPropertyOrder(order);\n    });\n  };\n\n  JsonProtoSerializer.prototype.fromOrder = function (orderBys) {\n    var _this = this;\n\n    return orderBys.map(function (order) {\n      return _this.fromPropertyOrder(order);\n    });\n  };\n\n  JsonProtoSerializer.prototype.toCursor = function (cursor) {\n    var _this = this;\n\n    return {\n      before: cursor.before,\n      values: cursor.position.map(function (component) {\n        return _this.toValue(component);\n      })\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromCursor = function (cursor) {\n    var _this = this;\n\n    var before = !!cursor.before;\n    var position = cursor.values.map(function (component) {\n      return _this.fromValue(component);\n    });\n    return new Bound(position, before);\n  }; // visible for testing\n\n\n  JsonProtoSerializer.prototype.toDirection = function (dir) {\n    return DIRECTIONS[dir.name];\n  }; // visible for testing\n\n\n  JsonProtoSerializer.prototype.fromDirection = function (dir) {\n    switch (dir) {\n      case 'ASCENDING':\n        return Direction.ASCENDING;\n\n      case 'DESCENDING':\n        return Direction.DESCENDING;\n\n      default:\n        return undefined;\n    }\n  }; // visible for testing\n\n\n  JsonProtoSerializer.prototype.toOperatorName = function (op) {\n    return OPERATORS[op.name];\n  };\n\n  JsonProtoSerializer.prototype.fromOperatorName = function (op) {\n    switch (op) {\n      case 'EQUAL':\n        return RelationOp.EQUAL;\n\n      case 'GREATER_THAN':\n        return RelationOp.GREATER_THAN;\n\n      case 'GREATER_THAN_OR_EQUAL':\n        return RelationOp.GREATER_THAN_OR_EQUAL;\n\n      case 'LESS_THAN':\n        return RelationOp.LESS_THAN;\n\n      case 'LESS_THAN_OR_EQUAL':\n        return RelationOp.LESS_THAN_OR_EQUAL;\n\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified relation');\n\n      default:\n        return fail('Unknown relation');\n    }\n  };\n\n  JsonProtoSerializer.prototype.toFieldPathReference = function (path) {\n    return {\n      fieldPath: path.canonicalString()\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {\n    return FieldPath.fromServerFormat(fieldReference.fieldPath);\n  }; // visible for testing\n\n\n  JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {\n    return {\n      field: this.toFieldPathReference(orderBy.field),\n      direction: this.toDirection(orderBy.dir)\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {\n    return new OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));\n  }; // visible for testing\n\n\n  JsonProtoSerializer.prototype.toRelationFilter = function (filter) {\n    if (filter instanceof RelationFilter) {\n      return {\n        fieldFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: this.toOperatorName(filter.op),\n          value: this.toValue(filter.value)\n        }\n      };\n    } else {\n      return fail('Unrecognized filter: ' + JSON.stringify(filter));\n    }\n  };\n\n  JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {\n    return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));\n  }; // visible for testing\n\n\n  JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {\n    if (filter instanceof NanFilter) {\n      return {\n        unaryFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: 'IS_NAN'\n        }\n      };\n    } else if (filter instanceof NullFilter) {\n      return {\n        unaryFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: 'IS_NULL'\n        }\n      };\n    } else {\n      return fail('Unrecognized filter: ' + JSON.stringify(filter));\n    }\n  };\n\n  JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {\n    switch (filter.unaryFilter.op) {\n      case 'IS_NAN':\n        var nanField = this.fromFieldPathReference(filter.unaryFilter.field);\n        return new NanFilter(nanField);\n\n      case 'IS_NULL':\n        var nullField = this.fromFieldPathReference(filter.unaryFilter.field);\n        return new NullFilter(nullField);\n\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified filter');\n\n      default:\n        return fail('Unknown filter');\n    }\n  };\n\n  JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {\n    return {\n      fieldPaths: fieldMask.fields.map(function (field) {\n        return field.canonicalString();\n      })\n    };\n  };\n\n  JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {\n    var paths = proto.fieldPaths || [];\n    var fields = paths.map(function (path) {\n      return FieldPath.fromServerFormat(path);\n    });\n    return new FieldMask(fields);\n  };\n\n  return JsonProtoSerializer;\n}();\n\nexport { JsonProtoSerializer };\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\n\nfunction hasTag(obj, type, tag) {\n  return type === tag || !type && tag in obj;\n}","map":{"version":3,"sources":["../src/remote/serializer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Blob } from '../api/blob';\nimport { GeoPoint } from '../api/geo_point';\nimport { DatabaseId } from '../core/database_info';\nimport {\n  Bound,\n  Direction,\n  Filter,\n  NanFilter,\n  NullFilter,\n  OrderBy,\n  Query,\n  RelationFilter,\n  RelationOp\n} from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport * as fieldValue from '../model/field_value';\nimport {\n  DeleteMutation,\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  MutationResult,\n  PatchMutation,\n  Precondition,\n  ServerTimestampTransform,\n  SetMutation,\n  TransformMutation\n} from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { AnyJs } from '../util/misc';\nimport * as obj from '../util/obj';\nimport * as typeUtils from '../util/types';\n\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode, mapRpcCodeFromCode } from './rpc_error';\nimport {\n  DocumentWatchChange,\n  ExistenceFilterChange,\n  WatchChange,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\nimport { ApiClientObjectMap } from '../protos/firestore_proto_api';\n\nconst DIRECTIONS = (() => {\n  const dirs: { [dir: string]: api.OrderDirection } = {};\n  dirs[Direction.ASCENDING.name] = 'ASCENDING';\n  dirs[Direction.DESCENDING.name] = 'DESCENDING';\n  return dirs;\n})();\n\nconst OPERATORS = (() => {\n  const ops: { [op: string]: api.FieldFilterOp } = {};\n  ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';\n  ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n  ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n  ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n  ops[RelationOp.EQUAL.name] = 'EQUAL';\n  return ops;\n})();\n\nfunction assertPresent(value: AnyJs, description: string) {\n  assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');\n}\n\nfunction parseInt64(value: number | string): number {\n  // TODO(bjornick): Handle int64 greater than 53 bits.\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return parseInt(value, 10);\n  } else {\n    return fail(\"can't parse \" + value);\n  }\n}\n\n// This is a supplement to the generated proto interfaces, which fail to account\n// for the fact that a timestamp may be encoded as either a string OR this.\ninterface TimestampProto {\n  seconds?: string;\n  nanos?: number;\n}\n\nexport interface SerializerOptions {\n  /**\n   * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n   * setting this flag to true, the serializer will use the Proto3 JSON format.\n   *\n   * For a description of the Proto3 JSON format check\n   * https://developers.google.com/protocol-buffers/docs/proto3#json\n   */\n  useProto3Json: boolean;\n}\n\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nexport class JsonProtoSerializer {\n  constructor(\n    private databaseId: DatabaseId,\n    private options: SerializerOptions\n  ) {}\n\n  private emptyByteString(): ProtoByteString {\n    if (this.options.useProto3Json) {\n      return '';\n    } else {\n      return new Uint8Array(0);\n    }\n  }\n\n  private unsafeCastProtoByteString(byteString: ProtoByteString): string {\n    // byteStrings can be either string or UInt8Array, but the typings say\n    // it's always a string. Cast as string to avoid type check failing\n    return byteString as string;\n  }\n\n  fromRpcStatus(status: api.Status): FirestoreError {\n    const code =\n      status.code === undefined\n        ? Code.UNKNOWN\n        : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n  }\n\n  /**\n   * Returns a value for a number (or undefined) that's appropriate to put into\n   * a google.protobuf.Int32Value proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"number\" because that's what\n   * our generated proto interfaces say Int32Value must be. But GRPC actually\n   * expects a { value: <number> } struct.\n   */\n  private toInt32Value(val: number | null): number | undefined {\n    if (!typeUtils.isNullOrUndefined(val)) {\n      return { value: val } as any;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Returns a number (or null) from a google.protobuf.Int32Value proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as accepting \"number\" because that's what\n   * our generated proto interfaces say Int32Value must be, but it actually\n   * accepts { value: number } to match our serialization in toInt32Value().\n   */\n  private fromInt32Value(val: number | undefined): number | null {\n    let result;\n    if (typeof val === 'object') {\n      result = (val as any).value;\n    } else {\n      // We accept raw numbers (without the {value: ... } wrapper) for\n      // compatibility with legacy persisted data.\n      result = val;\n    }\n    return typeUtils.isNullOrUndefined(result) ? null : result;\n  }\n\n  /**\n   * Returns a value for a Date that's appropriate to put into a proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"string\" because that's what\n   * our generated proto interfaces say dates must be. But it's easier and safer\n   * to actually return a Timestamp proto.\n   */\n  private toTimestamp(timestamp: Timestamp): string {\n    return {\n      seconds: timestamp.seconds,\n      nanos: timestamp.nanos\n      // tslint:disable-next-line:no-any\n    } as any;\n  }\n\n  private fromTimestamp(date: string | TimestampProto): Timestamp {\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n      // TODO(b/37282237): Use strings for Proto3 timestamps\n      // assert(this.options.useProto3Json,\n      //   'The timestamp string format requires Proto3.');\n      return Timestamp.fromISOString(date);\n    } else {\n      assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n      // TODO(b/37282237): Use strings for Proto3 timestamps\n      // assert(!this.options.useProto3Json,\n      //   'The timestamp instance format requires Proto JS.');\n      const seconds = parseInt64(date.seconds || '0');\n      const nanos = date.nanos || 0;\n      return new Timestamp(seconds, nanos);\n    }\n  }\n\n  /**\n   * Returns a value for bytes that's appropriate to put in a proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"string\" because that's what\n   * our generated proto interfaces say bytes must be. But it should return\n   * an Uint8Array in Node.\n   */\n  private toBytes(bytes: Blob): string {\n    if (this.options.useProto3Json) {\n      return bytes.toBase64();\n    } else {\n      // The typings say it's a string, but it needs to be a Uint8Array in Node.\n      return this.unsafeCastProtoByteString(bytes.toUint8Array());\n    }\n  }\n\n  /**\n   * Parse the blob from the protos into the internal Blob class. Note that the\n   * typings assume all blobs are strings, but they are actually Uint8Arrays\n   * on Node.\n   */\n  private fromBlob(blob: string | Uint8Array): Blob {\n    if (typeof blob === 'string') {\n      assert(\n        this.options.useProto3Json,\n        'Expected bytes to be passed in as Uint8Array, but got a string instead.'\n      );\n      return Blob.fromBase64String(blob);\n    } else {\n      assert(\n        !this.options.useProto3Json,\n        'Expected bytes to be passed in as string, but got something else instead.'\n      );\n      return Blob.fromUint8Array(blob);\n    }\n  }\n\n  toVersion(version: SnapshotVersion): string {\n    return this.toTimestamp(version.toTimestamp());\n  }\n\n  fromVersion(version: string): SnapshotVersion {\n    assert(!!version, \"Trying to deserialize version that isn't set\");\n    return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n  }\n\n  toResourceName(databaseId: DatabaseId, path: ResourcePath): string {\n    return this.fullyQualifiedPrefixPath(databaseId)\n      .child('documents')\n      .child(path)\n      .canonicalString();\n  }\n\n  fromResourceName(name: string): ResourcePath {\n    const resource = ResourcePath.fromString(name);\n    assert(\n      this.isValidResourceName(resource),\n      'Tried to deserialize invalid key ' + resource.toString()\n    );\n    return resource;\n  }\n\n  toName(key: DocumentKey): string {\n    return this.toResourceName(this.databaseId, key.path);\n  }\n\n  fromName(name: string): DocumentKey {\n    const resource = this.fromResourceName(name);\n    assert(\n      resource.get(1) === this.databaseId.projectId,\n      'Tried to deserialize key from different project: ' +\n        resource.get(1) +\n        ' vs ' +\n        this.databaseId.projectId\n    );\n    assert(\n      (!resource.get(3) && !this.databaseId.database) ||\n        resource.get(3) === this.databaseId.database,\n      'Tried to deserialize key from different database: ' +\n        resource.get(3) +\n        ' vs ' +\n        this.databaseId.database\n    );\n    return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n  }\n\n  toQueryPath(path: ResourcePath): string {\n    if (path.length === 0) {\n      // If the path is empty, the backend requires we leave off the /documents\n      // at the end.\n      return this.encodedDatabaseId;\n    }\n    return this.toResourceName(this.databaseId, path);\n  }\n\n  fromQueryPath(name: string): ResourcePath {\n    const resourceName = this.fromResourceName(name);\n    if (resourceName.length === 4) {\n      return ResourcePath.EMPTY_PATH;\n    }\n    return this.extractLocalPathFromResourceName(resourceName);\n  }\n\n  get encodedDatabaseId(): string {\n    const path = new ResourcePath([\n      'projects',\n      this.databaseId.projectId,\n      'databases',\n      this.databaseId.database\n    ]);\n    return path.canonicalString();\n  }\n\n  private fullyQualifiedPrefixPath(databaseId: DatabaseId): ResourcePath {\n    return new ResourcePath([\n      'projects',\n      databaseId.projectId,\n      'databases',\n      databaseId.database\n    ]);\n  }\n\n  private extractLocalPathFromResourceName(\n    resourceName: ResourcePath\n  ): ResourcePath {\n    assert(\n      resourceName.length > 4 && resourceName.get(4) === 'documents',\n      'tried to deserialize invalid key ' + resourceName.toString()\n    );\n    return resourceName.popFirst(5);\n  }\n\n  private isValidResourceName(path: ResourcePath): boolean {\n    // Resource names have at least 4 components (project ID, database ID)\n    return (\n      path.length >= 4 &&\n      path.get(0) === 'projects' &&\n      path.get(2) === 'databases'\n    );\n  }\n\n  toValue(val: fieldValue.FieldValue): api.Value {\n    if (val instanceof fieldValue.NullValue) {\n      return { nullValue: 'NULL_VALUE' };\n    } else if (val instanceof fieldValue.BooleanValue) {\n      return { booleanValue: val.value() };\n    } else if (val instanceof fieldValue.IntegerValue) {\n      return { integerValue: '' + val.value() };\n    } else if (val instanceof fieldValue.DoubleValue) {\n      const doubleValue = val.value();\n      if (this.options.useProto3Json) {\n        // Proto 3 let's us encode NaN and Infinity as string values as\n        // expected by the backend. This is currently not checked by our unit\n        // tests because they rely on protobuf.js.\n        if (isNaN(doubleValue)) {\n          return { doubleValue: 'NaN' } as {};\n        } else if (doubleValue === Infinity) {\n          return { doubleValue: 'Infinity' } as {};\n        } else if (doubleValue === -Infinity) {\n          return { doubleValue: '-Infinity' } as {};\n        }\n      }\n      return { doubleValue: val.value() };\n    } else if (val instanceof fieldValue.StringValue) {\n      return { stringValue: val.value() };\n    } else if (val instanceof fieldValue.ObjectValue) {\n      return { mapValue: this.toMapValue(val) };\n    } else if (val instanceof fieldValue.ArrayValue) {\n      return { arrayValue: this.toArrayValue(val) };\n    } else if (val instanceof fieldValue.TimestampValue) {\n      return {\n        timestampValue: this.toTimestamp(val.internalValue)\n      };\n    } else if (val instanceof fieldValue.GeoPointValue) {\n      return {\n        geoPointValue: {\n          latitude: val.value().latitude,\n          longitude: val.value().longitude\n        }\n      };\n    } else if (val instanceof fieldValue.BlobValue) {\n      return {\n        bytesValue: this.toBytes(val.value())\n      };\n    } else if (val instanceof fieldValue.RefValue) {\n      return {\n        referenceValue: this.toResourceName(val.databaseId, val.key.path)\n      };\n    } else {\n      return fail('Unknown FieldValue ' + JSON.stringify(val));\n    }\n  }\n\n  fromValue(obj: api.Value): fieldValue.FieldValue {\n    // tslint:disable-next-line:no-any\n    const type = (obj as any)['value_type'];\n    if (hasTag(obj, type, 'nullValue')) {\n      return fieldValue.NullValue.INSTANCE;\n    } else if (hasTag(obj, type, 'booleanValue')) {\n      return fieldValue.BooleanValue.of(obj.booleanValue!);\n    } else if (hasTag(obj, type, 'integerValue')) {\n      return new fieldValue.IntegerValue(parseInt64(obj.integerValue!));\n    } else if (hasTag(obj, type, 'doubleValue')) {\n      if (this.options.useProto3Json) {\n        // Proto 3 uses the string values 'NaN' and 'Infinity'.\n        if ((obj.doubleValue as {}) === 'NaN') {\n          return fieldValue.DoubleValue.NAN;\n        } else if ((obj.doubleValue as {}) === 'Infinity') {\n          return fieldValue.DoubleValue.POSITIVE_INFINITY;\n        } else if ((obj.doubleValue as {}) === '-Infinity') {\n          return fieldValue.DoubleValue.NEGATIVE_INFINITY;\n        }\n      }\n\n      return new fieldValue.DoubleValue(obj.doubleValue!);\n    } else if (hasTag(obj, type, 'stringValue')) {\n      return new fieldValue.StringValue(obj.stringValue!);\n    } else if (hasTag(obj, type, 'mapValue')) {\n      return this.fromFields(obj.mapValue!.fields || {});\n    } else if (hasTag(obj, type, 'arrayValue')) {\n      // \"values\" is not present if the array is empty\n      assertPresent(obj.arrayValue, 'arrayValue');\n      const values = obj.arrayValue!.values || [];\n      return new fieldValue.ArrayValue(values.map(v => this.fromValue(v)));\n    } else if (hasTag(obj, type, 'timestampValue')) {\n      assertPresent(obj.timestampValue, 'timestampValue');\n      return new fieldValue.TimestampValue(\n        this.fromTimestamp(obj.timestampValue!)\n      );\n    } else if (hasTag(obj, type, 'geoPointValue')) {\n      assertPresent(obj.geoPointValue, 'geoPointValue');\n      const latitude = obj.geoPointValue!.latitude || 0;\n      const longitude = obj.geoPointValue!.longitude || 0;\n      return new fieldValue.GeoPointValue(new GeoPoint(latitude, longitude));\n    } else if (hasTag(obj, type, 'bytesValue')) {\n      assertPresent(obj.bytesValue, 'bytesValue');\n      const blob = this.fromBlob(obj.bytesValue!);\n      return new fieldValue.BlobValue(blob);\n    } else if (hasTag(obj, type, 'referenceValue')) {\n      assertPresent(obj.referenceValue, 'referenceValue');\n      const resourceName = this.fromResourceName(obj.referenceValue!);\n      const dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));\n      const key = new DocumentKey(\n        this.extractLocalPathFromResourceName(resourceName)\n      );\n      return new fieldValue.RefValue(dbId, key);\n    } else {\n      return fail('Unknown Value proto ' + JSON.stringify(obj));\n    }\n  }\n\n  /** Creates an api.Document from key and fields (but no create/update time) */\n  toMutationDocument(\n    key: DocumentKey,\n    fields: fieldValue.ObjectValue\n  ): api.Document {\n    return {\n      name: this.toName(key),\n      fields: this.toFields(fields)\n    };\n  }\n\n  toDocument(document: Document): api.Document {\n    assert(\n      !document.hasLocalMutations,\n      \"Can't serialize documents with mutations.\"\n    );\n    return {\n      name: this.toName(document.key),\n      fields: this.toFields(document.data),\n      updateTime: this.toTimestamp(document.version.toTimestamp())\n    };\n  }\n\n  fromDocument(document: api.Document): Document {\n    return new Document(\n      this.fromName(document.name!),\n      this.fromVersion(document.updateTime!),\n      this.fromFields(document.fields || {}),\n      { hasLocalMutations: false }\n    );\n  }\n\n  toFields(fields: fieldValue.ObjectValue): { [key: string]: api.Value } {\n    const result: { [key: string]: api.Value } = {};\n    fields.forEach((key, value) => {\n      result[key] = this.toValue(value);\n    });\n    return result;\n  }\n\n  fromFields(object: {}): fieldValue.ObjectValue {\n    // Proto map<string, Value> gets mapped to Object, so cast it.\n    const map = object as { [key: string]: api.Value };\n    let result = fieldValue.ObjectValue.EMPTY;\n    obj.forEach(map, (key, value) => {\n      result = result.set(new FieldPath([key]), this.fromValue(value));\n    });\n    return result;\n  }\n\n  toMapValue(map: fieldValue.ObjectValue): api.MapValue {\n    return {\n      fields: this.toFields(map)\n    };\n  }\n\n  toArrayValue(array: fieldValue.ArrayValue): api.ArrayValue {\n    const result: api.Value[] = [];\n    array.forEach(value => {\n      result.push(this.toValue(value));\n    });\n    return { values: result };\n  }\n\n  private fromFound(doc: api.BatchGetDocumentsResponse): Document {\n    assert(\n      !!doc.found,\n      'Tried to deserialize a found document from a missing document.'\n    );\n    assertPresent(doc.found!.name, 'doc.found.name');\n    assertPresent(doc.found!.updateTime, 'doc.found.updateTime');\n    const key = this.fromName(doc.found!.name!);\n    const version = this.fromVersion(doc.found!.updateTime!);\n    const fields = this.fromFields(doc.found!.fields || {});\n    return new Document(key, version, fields, { hasLocalMutations: false });\n  }\n\n  private fromMissing(result: api.BatchGetDocumentsResponse): NoDocument {\n    assert(\n      !!result.missing,\n      'Tried to deserialize a missing document from a found document.'\n    );\n    assert(\n      !!result.readTime,\n      'Tried to deserialize a missing document without a read time.'\n    );\n    const key = this.fromName(result.missing!);\n    const version = this.fromVersion(result.readTime!);\n    return new NoDocument(key, version);\n  }\n\n  fromMaybeDocument(result: api.BatchGetDocumentsResponse): MaybeDocument {\n    // tslint:disable-next-line:no-any\n    const type = (result as any)['result'];\n    if (hasTag(result, type, 'found')) {\n      return this.fromFound(result);\n    } else if (hasTag(result, type, 'missing')) {\n      return this.fromMissing(result);\n    }\n    return fail('invalid batch get response: ' + JSON.stringify(result));\n  }\n\n  private toWatchTargetChangeState(\n    state: WatchTargetChangeState\n  ): api.TargetChangeTargetChangeType {\n    switch (state) {\n      case WatchTargetChangeState.Added:\n        return 'ADD';\n      case WatchTargetChangeState.Current:\n        return 'CURRENT';\n      case WatchTargetChangeState.NoChange:\n        return 'NO_CHANGE';\n      case WatchTargetChangeState.Removed:\n        return 'REMOVE';\n      case WatchTargetChangeState.Reset:\n        return 'RESET';\n      default:\n        return fail('Unknown WatchTargetChangeState: ' + state);\n    }\n  }\n\n  toTestWatchChange(watchChange: WatchChange): api.ListenResponse {\n    if (watchChange instanceof ExistenceFilterChange) {\n      return {\n        filter: {\n          count: watchChange.existenceFilter.count,\n          targetId: watchChange.targetId\n        }\n      };\n    }\n    if (watchChange instanceof DocumentWatchChange) {\n      if (watchChange.newDoc instanceof Document) {\n        const doc = watchChange.newDoc;\n        return {\n          documentChange: {\n            document: {\n              name: this.toName(doc.key),\n              fields: this.toFields(doc.data),\n              updateTime: this.toVersion(doc.version)\n            },\n            targetIds: watchChange.updatedTargetIds,\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      } else if (watchChange.newDoc instanceof NoDocument) {\n        const doc = watchChange.newDoc;\n        return {\n          documentDelete: {\n            document: this.toName(doc.key),\n            readTime: this.toVersion(doc.version),\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      } else if (watchChange.newDoc === null) {\n        return {\n          documentRemove: {\n            document: this.toName(watchChange.key),\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      }\n    }\n    if (watchChange instanceof WatchTargetChange) {\n      let cause: api.Status | undefined = undefined;\n      if (watchChange.cause) {\n        cause = {\n          code: mapRpcCodeFromCode(watchChange.cause.code),\n          message: watchChange.cause.message\n        };\n      }\n      return {\n        targetChange: {\n          targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n          targetIds: watchChange.targetIds,\n          resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n          cause\n        }\n      };\n    }\n    return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n  }\n\n  fromWatchChange(change: api.ListenResponse): WatchChange {\n    // tslint:disable-next-line:no-any\n    const type = (change as any)['response_type'];\n    let watchChange: WatchChange;\n    if (hasTag(change, type, 'targetChange')) {\n      assertPresent(change.targetChange, 'targetChange');\n      // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n      // if unset\n      const state = this.fromWatchTargetChangeState(\n        change.targetChange!.targetChangeType || 'NO_CHANGE'\n      );\n      const targetIds: TargetId[] = change.targetChange!.targetIds || [];\n      const resumeToken =\n        change.targetChange!.resumeToken || this.emptyByteString();\n      const causeProto = change.targetChange!.cause;\n      const cause = causeProto && this.fromRpcStatus(causeProto);\n      watchChange = new WatchTargetChange(\n        state,\n        targetIds,\n        resumeToken,\n        cause || null\n      );\n    } else if (hasTag(change, type, 'documentChange')) {\n      assertPresent(change.documentChange, 'documentChange');\n      assertPresent(change.documentChange!.document, 'documentChange.name');\n      assertPresent(\n        change.documentChange!.document!.name,\n        'documentChange.document.name'\n      );\n      assertPresent(\n        change.documentChange!.document!.updateTime,\n        'documentChange.document.updateTime'\n      );\n      const entityChange = change.documentChange!;\n      const key = this.fromName(entityChange.document!.name!);\n      const version = this.fromVersion(entityChange.document!.updateTime!);\n      const fields = this.fromFields(entityChange.document!.fields || {});\n      const doc = new Document(key, version, fields, {\n        hasLocalMutations: false\n      });\n      const updatedTargetIds = entityChange.targetIds || [];\n      const removedTargetIds = entityChange.removedTargetIds || [];\n      watchChange = new DocumentWatchChange(\n        updatedTargetIds,\n        removedTargetIds,\n        doc.key,\n        doc\n      );\n    } else if (hasTag(change, type, 'documentDelete')) {\n      assertPresent(change.documentDelete, 'documentDelete');\n      assertPresent(change.documentDelete!.document, 'documentDelete.document');\n      const docDelete = change.documentDelete!;\n      const key = this.fromName(docDelete.document!);\n      const version = docDelete.readTime\n        ? this.fromVersion(docDelete.readTime)\n        : SnapshotVersion.forDeletedDoc();\n      const doc = new NoDocument(key, version);\n      const removedTargetIds = docDelete.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    } else if (hasTag(change, type, 'documentRemove')) {\n      assertPresent(change.documentRemove, 'documentRemove');\n      assertPresent(change.documentRemove!.document, 'documentRemove');\n      const docRemove = change.documentRemove!;\n      const key = this.fromName(docRemove.document!);\n      const removedTargetIds = docRemove.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    } else if (hasTag(change, type, 'filter')) {\n      // TODO(dimond): implement existence filter parsing with strategy.\n      assertPresent(change.filter, 'filter');\n      assertPresent(change.filter!.targetId, 'filter.targetId');\n      const filter = change.filter;\n      const count = filter!.count || 0;\n      const existenceFilter = new ExistenceFilter(count);\n      const targetId = filter!.targetId!;\n      watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    } else {\n      return fail('Unknown change type ' + JSON.stringify(change));\n    }\n    return watchChange;\n  }\n\n  fromWatchTargetChangeState(\n    state: api.TargetChangeTargetChangeType\n  ): WatchTargetChangeState {\n    if (state === 'NO_CHANGE') {\n      return WatchTargetChangeState.NoChange;\n    } else if (state === 'ADD') {\n      return WatchTargetChangeState.Added;\n    } else if (state === 'REMOVE') {\n      return WatchTargetChangeState.Removed;\n    } else if (state === 'CURRENT') {\n      return WatchTargetChangeState.Current;\n    } else if (state === 'RESET') {\n      return WatchTargetChangeState.Reset;\n    } else {\n      return fail('Got unexpected TargetChange.state: ' + state);\n    }\n  }\n\n  versionFromListenResponse(change: api.ListenResponse): SnapshotVersion {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    // tslint:disable-next-line:no-any\n    const type = (change as any)['response_type'];\n    if (!hasTag(change, type, 'targetChange')) {\n      return SnapshotVersion.MIN;\n    }\n    const targetChange = change.targetChange!;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n      return SnapshotVersion.MIN;\n    }\n    if (!targetChange.readTime) {\n      return SnapshotVersion.MIN;\n    }\n    return this.fromVersion(targetChange.readTime);\n  }\n\n  toMutation(mutation: Mutation): api.Write {\n    let result: api.Write;\n    if (mutation instanceof SetMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.value)\n      };\n    } else if (mutation instanceof DeleteMutation) {\n      result = { delete: this.toName(mutation.key) };\n    } else if (mutation instanceof PatchMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.data),\n        updateMask: this.toDocumentMask(mutation.fieldMask)\n      };\n    } else if (mutation instanceof TransformMutation) {\n      result = {\n        transform: {\n          document: this.toName(mutation.key),\n          fieldTransforms: mutation.fieldTransforms.map(transform =>\n            this.toFieldTransform(transform)\n          )\n        }\n      };\n    } else {\n      return fail('Unknown mutation type ' + mutation.type);\n    }\n\n    if (!mutation.precondition.isNone) {\n      result.currentDocument = this.toPrecondition(mutation.precondition);\n    }\n\n    return result;\n  }\n\n  fromMutation(proto: api.Write): Mutation {\n    const precondition = proto.currentDocument\n      ? this.fromPrecondition(proto.currentDocument)\n      : Precondition.NONE;\n\n    if (proto.update) {\n      assertPresent(proto.update.name, 'name');\n      const key = this.fromName(proto.update.name!);\n      const value = this.fromFields(proto.update.fields || {});\n      if (proto.updateMask) {\n        const fieldMask = this.fromDocumentMask(proto.updateMask);\n        return new PatchMutation(key, value, fieldMask, precondition);\n      } else {\n        return new SetMutation(key, value, precondition);\n      }\n    } else if (proto.delete) {\n      const key = this.fromName(proto.delete);\n      return new DeleteMutation(key, precondition);\n    } else if (proto.transform) {\n      const key = this.fromName(proto.transform.document!);\n      const fieldTransforms = proto.transform.fieldTransforms!.map(transform =>\n        this.fromFieldTransform(transform)\n      );\n      assert(\n        precondition.exists === true,\n        'Transforms only support precondition \"exists == true\"'\n      );\n      return new TransformMutation(key, fieldTransforms);\n    } else {\n      return fail('unknown mutation proto: ' + JSON.stringify(proto));\n    }\n  }\n\n  private toPrecondition(precondition: Precondition): api.Precondition {\n    assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n    if (precondition.updateTime !== undefined) {\n      return {\n        updateTime: this.toVersion(precondition.updateTime)\n      };\n    } else if (precondition.exists !== undefined) {\n      return { exists: precondition.exists };\n    } else {\n      return fail('Unknown precondition');\n    }\n  }\n\n  private fromPrecondition(precondition: api.Precondition): Precondition {\n    if (precondition.updateTime !== undefined) {\n      return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n    } else if (precondition.exists !== undefined) {\n      return Precondition.exists(precondition.exists);\n    } else {\n      return Precondition.NONE;\n    }\n  }\n\n  private fromWriteResult(proto: api.WriteResult): MutationResult {\n    // NOTE: Deletes don't have an updateTime.\n    const version = proto.updateTime\n      ? this.fromVersion(proto.updateTime)\n      : null;\n    let transformResults: fieldValue.FieldValue[] | null = null;\n    if (proto.transformResults && proto.transformResults.length > 0) {\n      transformResults = proto.transformResults.map(result =>\n        this.fromValue(result)\n      );\n    }\n    return new MutationResult(version, transformResults);\n  }\n\n  fromWriteResults(protos: api.WriteResult[] | undefined): MutationResult[] {\n    return (protos || []).map(proto => this.fromWriteResult(proto));\n  }\n\n  private toFieldTransform(fieldTransform: FieldTransform): api.FieldTransform {\n    assert(\n      fieldTransform.transform instanceof ServerTimestampTransform,\n      'Unknown transform: ' + fieldTransform.transform\n    );\n    return {\n      fieldPath: fieldTransform.field.canonicalString(),\n      setToServerValue: 'REQUEST_TIME'\n    };\n  }\n\n  private fromFieldTransform(proto: api.FieldTransform): FieldTransform {\n    assert(\n      proto.setToServerValue! === 'REQUEST_TIME',\n      'Unknown transform proto: ' + JSON.stringify(proto)\n    );\n    const fieldPath = FieldPath.fromServerFormat(proto.fieldPath!);\n    return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n  }\n\n  toDocumentsTarget(query: Query): api.DocumentsTarget {\n    return { documents: [this.toQueryPath(query.path)] };\n  }\n\n  fromDocumentsTarget(documentsTarget: api.DocumentsTarget): Query {\n    const count = documentsTarget.documents!.length;\n    assert(\n      count === 1,\n      'DocumentsTarget contained other than 1 document: ' + count\n    );\n    const name = documentsTarget.documents![0];\n    return Query.atPath(this.fromQueryPath(name));\n  }\n\n  toQueryTarget(query: Query): api.QueryTarget {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const result: api.QueryTarget = { structuredQuery: {} };\n    if (query.path.isEmpty()) {\n      result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);\n    } else {\n      const path = query.path;\n      assert(\n        path.length % 2 !== 0,\n        'Document queries with filters are not supported.'\n      );\n      result.parent = this.toQueryPath(path.popLast());\n      result.structuredQuery!.from = [{ collectionId: path.lastSegment() }];\n    }\n\n    const where = this.toFilter(query.filters);\n    if (where) {\n      result.structuredQuery!.where = where;\n    }\n\n    const orderBy = this.toOrder(query.orderBy);\n    if (orderBy) {\n      result.structuredQuery!.orderBy = orderBy;\n    }\n\n    const limit = this.toInt32Value(query.limit);\n    if (limit !== undefined) {\n      result.structuredQuery!.limit = limit;\n    }\n\n    if (query.startAt) {\n      result.structuredQuery!.startAt = this.toCursor(query.startAt);\n    }\n    if (query.endAt) {\n      result.structuredQuery!.endAt = this.toCursor(query.endAt);\n    }\n\n    return result;\n  }\n\n  fromQueryTarget(target: api.QueryTarget): Query {\n    let path = this.fromQueryPath(target.parent!);\n\n    const query = target.structuredQuery!;\n    const fromCount = query.from ? query.from.length : 0;\n    if (fromCount > 0) {\n      assert(\n        fromCount === 1,\n        'StructuredQuery.from with more than one collection is not supported.'\n      );\n      const from = query.from![0];\n      path = path.child(from.collectionId!);\n    }\n\n    let filterBy: Filter[] = [];\n    if (query.where) {\n      filterBy = this.fromFilter(query.where);\n    }\n\n    let orderBy: OrderBy[] = [];\n    if (query.orderBy) {\n      orderBy = this.fromOrder(query.orderBy);\n    }\n\n    let limit: number | null = null;\n    if (query.limit) {\n      limit = this.fromInt32Value(query.limit);\n    }\n\n    let startAt: Bound | null = null;\n    if (query.startAt) {\n      startAt = this.fromCursor(query.startAt);\n    }\n\n    let endAt: Bound | null = null;\n    if (query.endAt) {\n      endAt = this.fromCursor(query.endAt);\n    }\n\n    return new Query(path, orderBy, filterBy, limit, startAt, endAt);\n  }\n\n  toListenRequestLabels(\n    queryData: QueryData\n  ): ApiClientObjectMap<string> | null {\n    const value = this.toLabel(queryData.purpose);\n    if (value == null) {\n      return null;\n    } else {\n      return {\n        'goog-listen-tags': value\n      };\n    }\n  }\n\n  private toLabel(purpose: QueryPurpose): string | null {\n    switch (purpose) {\n      case QueryPurpose.Listen:\n        return null;\n      case QueryPurpose.ExistenceFilterMismatch:\n        return 'existence-filter-mismatch';\n      case QueryPurpose.LimboResolution:\n        return 'limbo-document';\n      default:\n        return fail('Unrecognized query purpose: ' + purpose);\n    }\n  }\n\n  toTarget(queryData: QueryData): api.Target {\n    let result: api.Target;\n    const query = queryData.query;\n\n    if (query.isDocumentQuery()) {\n      result = { documents: this.toDocumentsTarget(query) };\n    } else {\n      result = { query: this.toQueryTarget(query) };\n    }\n\n    result.targetId = queryData.targetId;\n\n    if (queryData.resumeToken.length > 0) {\n      result.resumeToken = this.unsafeCastProtoByteString(\n        queryData.resumeToken\n      );\n    }\n\n    return result;\n  }\n\n  private toFilter(filters: Filter[]): api.Filter | undefined {\n    if (filters.length === 0) return;\n    const protos = filters.map(\n      filter =>\n        filter instanceof RelationFilter\n          ? this.toRelationFilter(filter)\n          : this.toUnaryFilter(filter)\n    );\n    if (protos.length === 1) {\n      return protos[0];\n    }\n    return { compositeFilter: { op: 'AND', filters: protos } };\n  }\n\n  private fromFilter(filter: api.Filter | undefined): Filter[] {\n    if (!filter) {\n      return [];\n    } else if (filter.unaryFilter !== undefined) {\n      return [this.fromUnaryFilter(filter)];\n    } else if (filter.fieldFilter !== undefined) {\n      return [this.fromRelationFilter(filter)];\n    } else if (filter.compositeFilter !== undefined) {\n      return filter.compositeFilter.filters!\n        .map(f => this.fromFilter(f))\n        .reduce((accum, current) => accum.concat(current));\n    } else {\n      return fail('Unknown filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  private toOrder(orderBys: OrderBy[]): api.Order[] | undefined {\n    if (orderBys.length === 0) return;\n    return orderBys.map(order => this.toPropertyOrder(order));\n  }\n\n  private fromOrder(orderBys: api.Order[]): OrderBy[] {\n    return orderBys.map(order => this.fromPropertyOrder(order));\n  }\n\n  private toCursor(cursor: Bound): api.Cursor {\n    return {\n      before: cursor.before,\n      values: cursor.position.map(component => this.toValue(component))\n    };\n  }\n\n  private fromCursor(cursor: api.Cursor): Bound {\n    const before = !!cursor.before;\n    const position = cursor.values!.map(component => this.fromValue(component));\n    return new Bound(position, before);\n  }\n\n  // visible for testing\n  toDirection(dir: Direction): api.OrderDirection {\n    return DIRECTIONS[dir.name];\n  }\n\n  // visible for testing\n  fromDirection(dir: api.OrderDirection | undefined): Direction | undefined {\n    switch (dir) {\n      case 'ASCENDING':\n        return Direction.ASCENDING;\n      case 'DESCENDING':\n        return Direction.DESCENDING;\n      default:\n        return undefined;\n    }\n  }\n\n  // visible for testing\n  toOperatorName(op: RelationOp): api.FieldFilterOp {\n    return OPERATORS[op.name];\n  }\n\n  fromOperatorName(op: api.FieldFilterOp): RelationOp {\n    switch (op) {\n      case 'EQUAL':\n        return RelationOp.EQUAL;\n      case 'GREATER_THAN':\n        return RelationOp.GREATER_THAN;\n      case 'GREATER_THAN_OR_EQUAL':\n        return RelationOp.GREATER_THAN_OR_EQUAL;\n      case 'LESS_THAN':\n        return RelationOp.LESS_THAN;\n      case 'LESS_THAN_OR_EQUAL':\n        return RelationOp.LESS_THAN_OR_EQUAL;\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified relation');\n      default:\n        return fail('Unknown relation');\n    }\n  }\n\n  toFieldPathReference(path: FieldPath): api.FieldReference {\n    return { fieldPath: path.canonicalString() };\n  }\n\n  fromFieldPathReference(fieldReference: api.FieldReference): FieldPath {\n    return FieldPath.fromServerFormat(fieldReference.fieldPath!);\n  }\n\n  // visible for testing\n  toPropertyOrder(orderBy: OrderBy): api.Order {\n    return {\n      field: this.toFieldPathReference(orderBy.field),\n      direction: this.toDirection(orderBy.dir)\n    };\n  }\n\n  fromPropertyOrder(orderBy: api.Order): OrderBy {\n    return new OrderBy(\n      this.fromFieldPathReference(orderBy.field!),\n      this.fromDirection(orderBy.direction)\n    );\n  }\n\n  // visible for testing\n  toRelationFilter(filter: Filter): api.Filter {\n    if (filter instanceof RelationFilter) {\n      return {\n        fieldFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: this.toOperatorName(filter.op),\n          value: this.toValue(filter.value)\n        }\n      };\n    } else {\n      return fail('Unrecognized filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  fromRelationFilter(filter: api.Filter): Filter {\n    return new RelationFilter(\n      this.fromFieldPathReference(filter.fieldFilter!.field!),\n      this.fromOperatorName(filter.fieldFilter!.op!),\n      this.fromValue(filter.fieldFilter!.value!)\n    );\n  }\n\n  // visible for testing\n  toUnaryFilter(filter: Filter): api.Filter {\n    if (filter instanceof NanFilter) {\n      return {\n        unaryFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: 'IS_NAN'\n        }\n      };\n    } else if (filter instanceof NullFilter) {\n      return {\n        unaryFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: 'IS_NULL'\n        }\n      };\n    } else {\n      return fail('Unrecognized filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  fromUnaryFilter(filter: api.Filter): Filter {\n    switch (filter.unaryFilter!.op!) {\n      case 'IS_NAN':\n        const nanField = this.fromFieldPathReference(\n          filter.unaryFilter!.field!\n        );\n        return new NanFilter(nanField);\n      case 'IS_NULL':\n        const nullField = this.fromFieldPathReference(\n          filter.unaryFilter!.field!\n        );\n        return new NullFilter(nullField);\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified filter');\n      default:\n        return fail('Unknown filter');\n    }\n  }\n\n  toDocumentMask(fieldMask: FieldMask): api.DocumentMask {\n    return {\n      fieldPaths: fieldMask.fields.map(field => field.canonicalString())\n    };\n  }\n\n  fromDocumentMask(proto: api.DocumentMask): FieldMask {\n    const paths = proto.fieldPaths || [];\n    const fields = paths.map(path => FieldPath.fromServerFormat(path));\n    return new FieldMask(fields);\n  }\n}\n\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj: {}, type: string, tag: string): boolean {\n  return type === tag || (!type && tag in obj);\n}\n"]},"metadata":{},"sourceType":"module"}