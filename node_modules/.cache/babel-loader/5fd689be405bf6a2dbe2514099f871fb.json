{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\nimport { Document, NoDocument } from './document';\nimport { ObjectValue, ServerTimestampValue } from './field_value';\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\n\nvar FieldMask =\n/** @class */\nfunction () {\n  function FieldMask(fields) {\n    this.fields = fields; // TODO(dimond): validation of FieldMask\n  }\n\n  FieldMask.prototype.equals = function (other) {\n    return misc.arrayEquals(this.fields, other.fields);\n  };\n\n  return FieldMask;\n}();\n\nexport { FieldMask };\n/** Transforms a value into a server-generated timestamp. */\n\nvar ServerTimestampTransform =\n/** @class */\nfunction () {\n  function ServerTimestampTransform() {}\n\n  ServerTimestampTransform.prototype.equals = function (other) {\n    return other instanceof ServerTimestampTransform;\n  };\n\n  ServerTimestampTransform.instance = new ServerTimestampTransform();\n  return ServerTimestampTransform;\n}();\n\nexport { ServerTimestampTransform };\n/** A field path and the TransformOperation to perform upon it. */\n\nvar FieldTransform =\n/** @class */\nfunction () {\n  function FieldTransform(field, transform) {\n    this.field = field;\n    this.transform = transform;\n  }\n\n  FieldTransform.prototype.equals = function (other) {\n    return this.field.equals(other.field) && this.transform.equals(other.transform);\n  };\n\n  return FieldTransform;\n}();\n\nexport { FieldTransform };\n/** The result of successfully applying a mutation to the backend. */\n\nvar MutationResult =\n/** @class */\nfunction () {\n  function MutationResult(\n  /**\n   * The version at which the mutation was committed or null for a delete.\n   */\n  version,\n  /**\n   * The resulting fields returned from the backend after a\n   * TransformMutation has been committed. Contains one FieldValue for each\n   * FieldTransform that was in the mutation.\n   *\n   * Will be null if the mutation was not a TransformMutation.\n   */\n  transformResults) {\n    this.version = version;\n    this.transformResults = transformResults;\n  }\n\n  return MutationResult;\n}();\n\nexport { MutationResult };\nexport var MutationType;\n\n(function (MutationType) {\n  MutationType[MutationType[\"Set\"] = 0] = \"Set\";\n  MutationType[MutationType[\"Patch\"] = 1] = \"Patch\";\n  MutationType[MutationType[\"Transform\"] = 2] = \"Transform\";\n  MutationType[MutationType[\"Delete\"] = 3] = \"Delete\";\n})(MutationType || (MutationType = {}));\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\n\n\nvar Precondition =\n/** @class */\nfunction () {\n  function Precondition(updateTime, exists) {\n    this.updateTime = updateTime;\n    this.exists = exists;\n    assert(updateTime === undefined || exists === undefined, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n  }\n  /** Creates a new Precondition with an exists flag. */\n\n\n  Precondition.exists = function (exists) {\n    return new Precondition(undefined, exists);\n  };\n  /** Creates a new Precondition based on a version a document exists at. */\n\n\n  Precondition.updateTime = function (version) {\n    return new Precondition(version);\n  };\n\n  Object.defineProperty(Precondition.prototype, \"isNone\", {\n    /** Returns whether this Precondition is empty. */\n    get: function get() {\n      return this.updateTime === undefined && this.exists === undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns true if the preconditions is valid for the given document\n   * (or null if no document is available).\n   */\n\n  Precondition.prototype.isValidFor = function (maybeDoc) {\n    if (this.updateTime !== undefined) {\n      return maybeDoc instanceof Document && maybeDoc.version.equals(this.updateTime);\n    } else if (this.exists !== undefined) {\n      if (this.exists) {\n        return maybeDoc instanceof Document;\n      } else {\n        return maybeDoc === null || maybeDoc instanceof NoDocument;\n      }\n    } else {\n      assert(this.isNone, 'Precondition should be empty');\n      return true;\n    }\n  };\n\n  Precondition.prototype.equals = function (other) {\n    return misc.equals(this.updateTime, other.updateTime) && this.exists === other.exists;\n  };\n\n  Precondition.NONE = new Precondition();\n  return Precondition;\n}();\n\nexport { Precondition };\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\n\nvar Mutation =\n/** @class */\nfunction () {\n  function Mutation() {}\n\n  Mutation.prototype.verifyKeyMatches = function (maybeDoc) {\n    if (maybeDoc != null) {\n      assert(maybeDoc.key.equals(this.key), 'Can only apply a mutation to a document with the same key');\n    }\n  };\n  /**\n   * Returns the version from the given document for use as the result of a\n   * mutation. Mutations are defined to return the version of the base document\n   * only if it is an existing document. Deleted and unknown documents have a\n   * post-mutation version of SnapshotVersion.MIN.\n   */\n\n\n  Mutation.getPostMutationVersion = function (maybeDoc) {\n    if (maybeDoc instanceof Document) {\n      return maybeDoc.version;\n    } else {\n      return SnapshotVersion.MIN;\n    }\n  };\n\n  return Mutation;\n}();\n\nexport { Mutation };\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\n\nvar SetMutation =\n/** @class */\nfunction (_super) {\n  __extends(SetMutation, _super);\n\n  function SetMutation(key, value, precondition) {\n    var _this = _super.call(this) || this;\n\n    _this.key = key;\n    _this.value = value;\n    _this.precondition = precondition;\n    _this.type = MutationType.Set;\n    return _this;\n  }\n\n  SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n    this.verifyKeyMatches(maybeDoc);\n    assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.'); // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    var version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: false\n    });\n  };\n\n  SetMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    var version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: true\n    });\n  };\n\n  SetMutation.prototype.equals = function (other) {\n    return other instanceof SetMutation && this.key.equals(other.key) && this.value.equals(other.value) && this.precondition.equals(other.precondition);\n  };\n\n  return SetMutation;\n}(Mutation);\n\nexport { SetMutation };\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\n\nvar PatchMutation =\n/** @class */\nfunction (_super) {\n  __extends(PatchMutation, _super);\n\n  function PatchMutation(key, data, fieldMask, precondition) {\n    var _this = _super.call(this) || this;\n\n    _this.key = key;\n    _this.data = data;\n    _this.fieldMask = fieldMask;\n    _this.precondition = precondition;\n    _this.type = MutationType.Patch;\n    return _this;\n  }\n\n  PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n    this.verifyKeyMatches(maybeDoc);\n    assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.'); // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    var version = Mutation.getPostMutationVersion(maybeDoc);\n    var newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: false\n    });\n  };\n\n  PatchMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    var version = Mutation.getPostMutationVersion(maybeDoc);\n    var newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: true\n    });\n  };\n\n  PatchMutation.prototype.equals = function (other) {\n    return other instanceof PatchMutation && this.key.equals(other.key) && this.fieldMask.equals(other.fieldMask) && this.precondition.equals(other.precondition);\n  };\n  /**\n   * Patches the data of document if available or creates a new document. Note\n   * that this does not check whether or not the precondition of this patch\n   * holds.\n   */\n\n\n  PatchMutation.prototype.patchDocument = function (maybeDoc) {\n    var data;\n\n    if (maybeDoc instanceof Document) {\n      data = maybeDoc.data;\n    } else {\n      data = ObjectValue.EMPTY;\n    }\n\n    return this.patchObject(data);\n  };\n\n  PatchMutation.prototype.patchObject = function (data) {\n    for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {\n      var fieldPath = _a[_i];\n      var newValue = this.data.field(fieldPath);\n\n      if (newValue !== undefined) {\n        data = data.set(fieldPath, newValue);\n      } else {\n        data = data.delete(fieldPath);\n      }\n    }\n\n    return data;\n  };\n\n  return PatchMutation;\n}(Mutation);\n\nexport { PatchMutation };\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\n\nvar TransformMutation =\n/** @class */\nfunction (_super) {\n  __extends(TransformMutation, _super);\n\n  function TransformMutation(key, fieldTransforms) {\n    var _this = _super.call(this) || this;\n\n    _this.key = key;\n    _this.fieldTransforms = fieldTransforms;\n    _this.type = MutationType.Transform; // NOTE: We set a precondition of exists: true as a safety-check, since we\n    // always combine TransformMutations with a SetMutation or PatchMutation which\n    // (if successful) should end up with an existing document.\n\n    _this.precondition = Precondition.exists(true);\n    return _this;\n  }\n\n  TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n    this.verifyKeyMatches(maybeDoc);\n    assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');\n    var transformResults = mutationResult.transformResults; // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    var doc = this.requireDocument(maybeDoc);\n    var newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: false\n    });\n  };\n\n  TransformMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    var doc = this.requireDocument(maybeDoc);\n    var transformResults = this.localTransformResults(localWriteTime);\n    var newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: true\n    });\n  };\n\n  TransformMutation.prototype.equals = function (other) {\n    return other instanceof TransformMutation && this.key.equals(other.key) && misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) && this.precondition.equals(other.precondition);\n  };\n  /**\n   * Asserts that the given MaybeDocument is actually a Document and verifies\n   * that it matches the key for this mutation. Since we only support\n   * transformations with precondition exists this method is guaranteed to be\n   * safe.\n   */\n\n\n  TransformMutation.prototype.requireDocument = function (maybeDoc) {\n    assert(maybeDoc instanceof Document, 'Unknown MaybeDocument type ' + maybeDoc);\n    var doc = maybeDoc;\n    assert(doc.key.equals(this.key), 'Can only transform a document with the same key');\n    return doc;\n  };\n  /**\n   * Creates a list of \"transform results\" (a transform result is a field value\n   * representing the result of applying a transform) for use when applying a\n   * TransformMutation locally.\n   *\n   * @param localWriteTime The local time of the transform mutation (used to\n   *     generate ServerTimestampValues).\n   * @return The transform results list.\n   */\n\n\n  TransformMutation.prototype.localTransformResults = function (localWriteTime) {\n    var transformResults = [];\n\n    for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {\n      var fieldTransform = _a[_i];\n      var transform = fieldTransform.transform;\n\n      if (transform instanceof ServerTimestampTransform) {\n        transformResults.push(new ServerTimestampValue(localWriteTime));\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n\n    return transformResults;\n  };\n\n  TransformMutation.prototype.transformObject = function (data, transformResults) {\n    assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');\n\n    for (var i = 0; i < this.fieldTransforms.length; i++) {\n      var fieldTransform = this.fieldTransforms[i];\n      var transform = fieldTransform.transform;\n      var fieldPath = fieldTransform.field;\n\n      if (transform instanceof ServerTimestampTransform) {\n        data = data.set(fieldPath, transformResults[i]);\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n\n    return data;\n  };\n\n  return TransformMutation;\n}(Mutation);\n\nexport { TransformMutation };\n/** A mutation that deletes the document at the given key. */\n\nvar DeleteMutation =\n/** @class */\nfunction (_super) {\n  __extends(DeleteMutation, _super);\n\n  function DeleteMutation(key, precondition) {\n    var _this = _super.call(this) || this;\n\n    _this.key = key;\n    _this.precondition = precondition;\n    _this.type = MutationType.Delete;\n    return _this;\n  }\n\n  DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n    this.verifyKeyMatches(maybeDoc);\n    assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.'); // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    return new NoDocument(this.key, SnapshotVersion.MIN);\n  };\n\n  DeleteMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    if (maybeDoc) {\n      assert(maybeDoc.key.equals(this.key), 'Can only apply mutation to document with same key');\n    }\n\n    return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n  };\n\n  DeleteMutation.prototype.equals = function (other) {\n    return other instanceof DeleteMutation && this.key.equals(other.key) && this.precondition.equals(other.precondition);\n  };\n\n  return DeleteMutation;\n}(Mutation);\n\nexport { DeleteMutation };","map":{"version":3,"sources":["../src/model/mutation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\n\nimport { Document, MaybeDocument, NoDocument } from './document';\nimport { DocumentKey } from './document_key';\nimport { FieldValue, ObjectValue, ServerTimestampValue } from './field_value';\nimport { FieldPath } from './path';\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nexport class FieldMask {\n  constructor(readonly fields: FieldPath[]) {\n    // TODO(dimond): validation of FieldMask\n  }\n\n  equals(other: FieldMask): boolean {\n    return misc.arrayEquals(this.fields, other.fields);\n  }\n}\n\n/** Represents a transform within a TransformMutation. */\nexport interface TransformOperation {\n  equals(other: TransformOperation): boolean;\n}\n\n/** Transforms a value into a server-generated timestamp. */\nexport class ServerTimestampTransform implements TransformOperation {\n  private constructor() {}\n  static instance = new ServerTimestampTransform();\n\n  equals(other: TransformOperation): boolean {\n    return other instanceof ServerTimestampTransform;\n  }\n}\n\n/** A field path and the TransformOperation to perform upon it. */\nexport class FieldTransform {\n  constructor(\n    readonly field: FieldPath,\n    readonly transform: TransformOperation\n  ) {}\n\n  equals(other: FieldTransform): boolean {\n    return (\n      this.field.equals(other.field) && this.transform.equals(other.transform)\n    );\n  }\n}\n\n/** The result of successfully applying a mutation to the backend. */\nexport class MutationResult {\n  constructor(\n    /**\n     * The version at which the mutation was committed or null for a delete.\n     */\n    readonly version: SnapshotVersion | null,\n    /**\n     * The resulting fields returned from the backend after a\n     * TransformMutation has been committed. Contains one FieldValue for each\n     * FieldTransform that was in the mutation.\n     *\n     * Will be null if the mutation was not a TransformMutation.\n     */\n    readonly transformResults: FieldValue[] | null\n  ) {}\n}\n\nexport enum MutationType {\n  Set,\n  Patch,\n  Transform,\n  Delete\n}\n\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nexport class Precondition {\n  static readonly NONE = new Precondition();\n\n  private constructor(\n    public readonly updateTime?: SnapshotVersion,\n    public readonly exists?: boolean\n  ) {\n    assert(\n      updateTime === undefined || exists === undefined,\n      'Precondition can specify \"exists\" or \"updateTime\" but not both'\n    );\n  }\n\n  /** Creates a new Precondition with an exists flag. */\n  static exists(exists: boolean) {\n    return new Precondition(undefined, exists);\n  }\n\n  /** Creates a new Precondition based on a version a document exists at. */\n  static updateTime(version: SnapshotVersion) {\n    return new Precondition(version);\n  }\n\n  /** Returns whether this Precondition is empty. */\n  get isNone(): boolean {\n    return this.updateTime === undefined && this.exists === undefined;\n  }\n\n  /**\n   * Returns true if the preconditions is valid for the given document\n   * (or null if no document is available).\n   */\n  isValidFor(maybeDoc: MaybeDocument | null) {\n    if (this.updateTime !== undefined) {\n      return (\n        maybeDoc instanceof Document && maybeDoc.version.equals(this.updateTime)\n      );\n    } else if (this.exists !== undefined) {\n      if (this.exists) {\n        return maybeDoc instanceof Document;\n      } else {\n        return maybeDoc === null || maybeDoc instanceof NoDocument;\n      }\n    } else {\n      assert(this.isNone, 'Precondition should be empty');\n      return true;\n    }\n  }\n\n  equals(other: Precondition) {\n    return (\n      misc.equals(this.updateTime, other.updateTime) &&\n      this.exists === other.exists\n    );\n  }\n}\n\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nexport abstract class Mutation {\n  readonly type: MutationType;\n  readonly key: DocumentKey;\n  readonly precondition: Precondition;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing a new remote document. Both the input and returned documents\n   * can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param mutationResult The result of applying the mutation from the backend.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing the new local view of a document. Both the input and returned\n   * documents can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param localWriteTime A timestamp indicating the local write time of the\n   *     batch this mutation is a part of.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null;\n\n  abstract equals(other: Mutation): boolean;\n\n  protected verifyKeyMatches(maybeDoc: MaybeDocument | null): void {\n    if (maybeDoc != null) {\n      assert(\n        maybeDoc.key.equals(this.key),\n        'Can only apply a mutation to a document with the same key'\n      );\n    }\n  }\n\n  /**\n   * Returns the version from the given document for use as the result of a\n   * mutation. Mutations are defined to return the version of the base document\n   * only if it is an existing document. Deleted and unknown documents have a\n   * post-mutation version of SnapshotVersion.MIN.\n   */\n  protected static getPostMutationVersion(\n    maybeDoc: MaybeDocument | null\n  ): SnapshotVersion {\n    if (maybeDoc instanceof Document) {\n      return maybeDoc.version;\n    } else {\n      return SnapshotVersion.MIN;\n    }\n  }\n}\n\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nexport class SetMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly value: ObjectValue,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Set;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by SetMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof SetMutation &&\n      this.key.equals(other.key) &&\n      this.value.equals(other.value) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n}\n\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nexport class PatchMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Patch;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by PatchMutation.'\n    );\n\n    // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof PatchMutation &&\n      this.key.equals(other.key) &&\n      this.fieldMask.equals(other.fieldMask) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n\n  /**\n   * Patches the data of document if available or creates a new document. Note\n   * that this does not check whether or not the precondition of this patch\n   * holds.\n   */\n  private patchDocument(maybeDoc: MaybeDocument | null): ObjectValue {\n    let data: ObjectValue;\n    if (maybeDoc instanceof Document) {\n      data = maybeDoc.data;\n    } else {\n      data = ObjectValue.EMPTY;\n    }\n    return this.patchObject(data);\n  }\n\n  private patchObject(data: ObjectValue): ObjectValue {\n    for (const fieldPath of this.fieldMask.fields) {\n      const newValue = this.data.field(fieldPath);\n      if (newValue !== undefined) {\n        data = data.set(fieldPath, newValue);\n      } else {\n        data = data.delete(fieldPath);\n      }\n    }\n    return data;\n  }\n}\n\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nexport class TransformMutation extends Mutation {\n  readonly type: MutationType = MutationType.Transform;\n\n  // NOTE: We set a precondition of exists: true as a safety-check, since we\n  // always combine TransformMutations with a SetMutation or PatchMutation which\n  // (if successful) should end up with an existing document.\n  readonly precondition = Precondition.exists(true);\n\n  constructor(\n    readonly key: DocumentKey,\n    readonly fieldTransforms: FieldTransform[]\n  ) {\n    super();\n  }\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults != null,\n      'Transform results missing for TransformMutation.'\n    );\n    const transformResults = mutationResult.transformResults!;\n\n    // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const transformResults = this.localTransformResults(localWriteTime);\n    const newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof TransformMutation &&\n      this.key.equals(other.key) &&\n      misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n\n  /**\n   * Asserts that the given MaybeDocument is actually a Document and verifies\n   * that it matches the key for this mutation. Since we only support\n   * transformations with precondition exists this method is guaranteed to be\n   * safe.\n   */\n  private requireDocument(maybeDoc: MaybeDocument | null): Document {\n    assert(\n      maybeDoc instanceof Document,\n      'Unknown MaybeDocument type ' + maybeDoc\n    );\n    const doc = maybeDoc! as Document;\n    assert(\n      doc.key.equals(this.key),\n      'Can only transform a document with the same key'\n    );\n    return doc;\n  }\n\n  /**\n   * Creates a list of \"transform results\" (a transform result is a field value\n   * representing the result of applying a transform) for use when applying a\n   * TransformMutation locally.\n   *\n   * @param localWriteTime The local time of the transform mutation (used to\n   *     generate ServerTimestampValues).\n   * @return The transform results list.\n   */\n  private localTransformResults(localWriteTime: Timestamp): FieldValue[] {\n    const transformResults = [] as FieldValue[];\n    for (const fieldTransform of this.fieldTransforms) {\n      const transform = fieldTransform.transform;\n      if (transform instanceof ServerTimestampTransform) {\n        transformResults.push(new ServerTimestampValue(localWriteTime));\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n    return transformResults;\n  }\n\n  private transformObject(\n    data: ObjectValue,\n    transformResults: FieldValue[]\n  ): ObjectValue {\n    assert(\n      transformResults.length === this.fieldTransforms.length,\n      'TransformResults length mismatch.'\n    );\n\n    for (let i = 0; i < this.fieldTransforms.length; i++) {\n      const fieldTransform = this.fieldTransforms[i];\n      const transform = fieldTransform.transform;\n      const fieldPath = fieldTransform.field;\n      if (transform instanceof ServerTimestampTransform) {\n        data = data.set(fieldPath, transformResults[i]);\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n    return data;\n  }\n}\n\n/** A mutation that deletes the document at the given key. */\nexport class DeleteMutation extends Mutation {\n  constructor(readonly key: DocumentKey, readonly precondition: Precondition) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Delete;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by DeleteMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    return new NoDocument(this.key, SnapshotVersion.MIN);\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(this.key),\n        'Can only apply mutation to document with same key'\n      );\n    }\n    return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof DeleteMutation &&\n      this.key.equals(other.key) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}