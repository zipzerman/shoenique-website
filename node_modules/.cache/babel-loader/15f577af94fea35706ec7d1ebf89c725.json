{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DoubleValue, NullValue, RefValue } from '../model/field_value';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\n\nvar Query =\n/** @class */\nfunction () {\n  function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {\n    if (explicitOrderBy === void 0) {\n      explicitOrderBy = [];\n    }\n\n    if (filters === void 0) {\n      filters = [];\n    }\n\n    if (limit === void 0) {\n      limit = null;\n    }\n\n    if (startAt === void 0) {\n      startAt = null;\n    }\n\n    if (endAt === void 0) {\n      endAt = null;\n    }\n\n    this.path = path;\n    this.explicitOrderBy = explicitOrderBy;\n    this.filters = filters;\n    this.limit = limit;\n    this.startAt = startAt;\n    this.endAt = endAt;\n    this.memoizedCanonicalId = null;\n    this.memoizedOrderBy = null;\n\n    if (this.startAt) {\n      this.assertValidBound(this.startAt);\n    }\n\n    if (this.endAt) {\n      this.assertValidBound(this.endAt);\n    }\n  }\n\n  Query.atPath = function (path) {\n    return new Query(path);\n  };\n\n  Object.defineProperty(Query.prototype, \"orderBy\", {\n    get: function get() {\n      if (this.memoizedOrderBy === null) {\n        var inequalityField = this.getInequalityFilterField();\n        var firstOrderByField = this.getFirstOrderByField();\n\n        if (inequalityField !== null && firstOrderByField === null) {\n          // In order to implicitly add key ordering, we must also add the\n          // inequality filter field for it to be a valid query.\n          // Note that the default inequality field and key ordering is ascending.\n          if (inequalityField.isKeyField()) {\n            this.memoizedOrderBy = [KEY_ORDERING_ASC];\n          } else {\n            this.memoizedOrderBy = [new OrderBy(inequalityField), KEY_ORDERING_ASC];\n          }\n        } else {\n          assert(inequalityField === null || firstOrderByField !== null && inequalityField.equals(firstOrderByField), 'First orderBy should match inequality field.');\n          this.memoizedOrderBy = [];\n          var foundKeyOrdering = false;\n\n          for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            this.memoizedOrderBy.push(orderBy);\n\n            if (orderBy.field.isKeyField()) {\n              foundKeyOrdering = true;\n            }\n          }\n\n          if (!foundKeyOrdering) {\n            // The order of the implicit key ordering always matches the last\n            // explicit order by\n            var lastDirection = this.explicitOrderBy.length > 0 ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : Direction.ASCENDING;\n            this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING ? KEY_ORDERING_ASC : KEY_ORDERING_DESC);\n          }\n        }\n      }\n\n      return this.memoizedOrderBy;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Query.prototype.addFilter = function (filter) {\n    assert(this.getInequalityFilterField() == null || !(filter instanceof RelationFilter) || !filter.isInequality() || filter.field.equals(this.getInequalityFilterField()), 'Query must only have one inequality field.');\n    assert(!DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');\n    var newFilters = this.filters.concat([filter]);\n    return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);\n  };\n\n  Query.prototype.addOrderBy = function (orderBy) {\n    assert(!DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');\n    assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy'); // TODO(dimond): validate that orderBy does not list the same key twice.\n\n    var newOrderBy = this.explicitOrderBy.concat([orderBy]);\n    return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);\n  };\n\n  Query.prototype.withLimit = function (limit) {\n    return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);\n  };\n\n  Query.prototype.withStartAt = function (bound) {\n    return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);\n  };\n\n  Query.prototype.withEndAt = function (bound) {\n    return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);\n  }; // TODO(b/29183165): This is used to get a unique string from a query to, for\n  // example, use as a dictionary key, but the implementation is subject to\n  // collisions. Make it collision-free.\n\n\n  Query.prototype.canonicalId = function () {\n    if (this.memoizedCanonicalId === null) {\n      var canonicalId = this.path.canonicalString();\n      canonicalId += '|f:';\n\n      for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n        var filter = _a[_i];\n        canonicalId += filter.canonicalId();\n        canonicalId += ',';\n      }\n\n      canonicalId += '|ob:'; // TODO(dimond): make this collision resistant\n\n      for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {\n        var orderBy = _c[_b];\n        canonicalId += orderBy.canonicalId();\n        canonicalId += ',';\n      }\n\n      if (!isNullOrUndefined(this.limit)) {\n        canonicalId += '|l:';\n        canonicalId += this.limit;\n      }\n\n      if (this.startAt) {\n        canonicalId += '|lb:';\n        canonicalId += this.startAt.canonicalId();\n      }\n\n      if (this.endAt) {\n        canonicalId += '|ub:';\n        canonicalId += this.endAt.canonicalId();\n      }\n\n      this.memoizedCanonicalId = canonicalId;\n    }\n\n    return this.memoizedCanonicalId;\n  };\n\n  Query.prototype.toString = function () {\n    var str = 'Query(' + this.path.canonicalString();\n\n    if (this.filters.length > 0) {\n      str += \", filters: [\" + this.filters.join(', ') + \"]\";\n    }\n\n    if (!isNullOrUndefined(this.limit)) {\n      str += ', limit: ' + this.limit;\n    }\n\n    if (this.explicitOrderBy.length > 0) {\n      str += \", orderBy: [\" + this.explicitOrderBy.join(', ') + \"]\";\n    }\n\n    if (this.startAt) {\n      str += ', startAt: ' + this.startAt.canonicalId();\n    }\n\n    if (this.endAt) {\n      str += ', endAt: ' + this.endAt.canonicalId();\n    }\n\n    return str + ')';\n  };\n\n  Query.prototype.equals = function (other) {\n    if (this.limit !== other.limit) {\n      return false;\n    }\n\n    if (this.orderBy.length !== other.orderBy.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.orderBy.length; i++) {\n      if (!this.orderBy[i].equals(other.orderBy[i])) {\n        return false;\n      }\n    }\n\n    if (this.filters.length !== other.filters.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].equals(other.filters[i])) {\n        return false;\n      }\n    }\n\n    if (!this.path.equals(other.path)) {\n      return false;\n    }\n\n    if (this.startAt !== null ? !this.startAt.equals(other.startAt) : other.startAt !== null) {\n      return false;\n    }\n\n    return this.endAt !== null ? this.endAt.equals(other.endAt) : other.endAt === null;\n  };\n\n  Query.prototype.docComparator = function (d1, d2) {\n    var comparedOnKeyField = false;\n\n    for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {\n      var orderBy = _a[_i];\n      var comp = orderBy.compare(d1, d2);\n      if (comp !== 0) return comp;\n      comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n    } // Assert that we actually compared by key\n\n\n    assert(comparedOnKeyField, \"orderBy used that doesn't compare on key field\");\n    return 0;\n  };\n\n  Query.prototype.matches = function (doc) {\n    return this.matchesAncestor(doc) && this.matchesOrderBy(doc) && this.matchesFilters(doc) && this.matchesBounds(doc);\n  };\n\n  Query.prototype.hasLimit = function () {\n    return !isNullOrUndefined(this.limit);\n  };\n\n  Query.prototype.getFirstOrderByField = function () {\n    return this.explicitOrderBy.length > 0 ? this.explicitOrderBy[0].field : null;\n  };\n\n  Query.prototype.getInequalityFilterField = function () {\n    for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n      var filter = _a[_i];\n\n      if (filter instanceof RelationFilter && filter.isInequality()) {\n        return filter.field;\n      }\n    }\n\n    return null;\n  };\n\n  Query.prototype.isDocumentQuery = function () {\n    return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n  };\n\n  Query.prototype.matchesAncestor = function (doc) {\n    var docPath = doc.key.path;\n\n    if (DocumentKey.isDocumentKey(this.path)) {\n      // exact match for document queries\n      return this.path.equals(docPath);\n    } else {\n      // shallow ancestor queries by default\n      return this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1;\n    }\n  };\n  /**\n   * A document must have a value for every ordering clause in order to show up\n   * in the results.\n   */\n\n\n  Query.prototype.matchesOrderBy = function (doc) {\n    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n      var orderBy = _a[_i]; // order by key always matches\n\n      if (!orderBy.field.isKeyField() && doc.field(orderBy.field) === undefined) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Query.prototype.matchesFilters = function (doc) {\n    for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n      var filter = _a[_i];\n\n      if (!filter.matches(doc)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Makes sure a document is within the bounds, if provided.\n   */\n\n\n  Query.prototype.matchesBounds = function (doc) {\n    if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n\n    if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Query.prototype.assertValidBound = function (bound) {\n    assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');\n  };\n\n  return Query;\n}();\n\nexport { Query };\n\nvar RelationOp =\n/** @class */\nfunction () {\n  function RelationOp(name) {\n    this.name = name;\n  }\n\n  RelationOp.fromString = function (op) {\n    switch (op) {\n      case '<':\n        return RelationOp.LESS_THAN;\n\n      case '<=':\n        return RelationOp.LESS_THAN_OR_EQUAL;\n\n      case '==':\n        return RelationOp.EQUAL;\n\n      case '>=':\n        return RelationOp.GREATER_THAN_OR_EQUAL;\n\n      case '>':\n        return RelationOp.GREATER_THAN;\n\n      default:\n        return fail('Unknown relation: ' + op);\n    }\n  };\n\n  RelationOp.prototype.toString = function () {\n    return this.name;\n  };\n\n  RelationOp.prototype.equals = function (other) {\n    return this.name === other.name;\n  };\n\n  RelationOp.LESS_THAN = new RelationOp('<');\n  RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');\n  RelationOp.EQUAL = new RelationOp('==');\n  RelationOp.GREATER_THAN = new RelationOp('>');\n  RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n  return RelationOp;\n}();\n\nexport { RelationOp };\n\nvar RelationFilter =\n/** @class */\nfunction () {\n  function RelationFilter(field, op, value) {\n    this.field = field;\n    this.op = op;\n    this.value = value;\n  }\n\n  RelationFilter.prototype.matches = function (doc) {\n    if (this.field.isKeyField()) {\n      assert(this.value instanceof RefValue, 'Comparing on key, but filter value not a RefValue');\n      var refValue = this.value;\n      var comparison = DocumentKey.comparator(doc.key, refValue.key);\n      return this.matchesComparison(comparison);\n    } else {\n      var val = doc.field(this.field);\n      return val !== undefined && this.matchesValue(val);\n    }\n  };\n\n  RelationFilter.prototype.matchesValue = function (value) {\n    // Only compare types with matching backend order (such as double and int).\n    if (this.value.typeOrder !== value.typeOrder) {\n      return false;\n    }\n\n    return this.matchesComparison(value.compareTo(this.value));\n  };\n\n  RelationFilter.prototype.matchesComparison = function (comparison) {\n    switch (this.op) {\n      case RelationOp.LESS_THAN:\n        return comparison < 0;\n\n      case RelationOp.LESS_THAN_OR_EQUAL:\n        return comparison <= 0;\n\n      case RelationOp.EQUAL:\n        return comparison === 0;\n\n      case RelationOp.GREATER_THAN:\n        return comparison > 0;\n\n      case RelationOp.GREATER_THAN_OR_EQUAL:\n        return comparison >= 0;\n\n      default:\n        return fail('Unknown relation op' + this.op);\n    }\n  };\n\n  RelationFilter.prototype.isInequality = function () {\n    return this.op !== RelationOp.EQUAL;\n  };\n\n  RelationFilter.prototype.canonicalId = function () {\n    // TODO(b/29183165): Technically, this won't be unique if two values have\n    // the same description, such as the int 3 and the string \"3\". So we should\n    // add the types in here somehow, too.\n    return this.field.canonicalString() + this.op.toString() + this.value.toString();\n  };\n\n  RelationFilter.prototype.equals = function (other) {\n    if (other instanceof RelationFilter) {\n      return this.op.equals(other.op) && this.field.equals(other.field) && this.value.equals(other.value);\n    } else {\n      return false;\n    }\n  };\n\n  RelationFilter.prototype.toString = function () {\n    return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n  };\n\n  return RelationFilter;\n}();\n\nexport { RelationFilter };\n/**\n * Filter that matches 'null' values.\n */\n\nvar NullFilter =\n/** @class */\nfunction () {\n  function NullFilter(field) {\n    this.field = field;\n  }\n\n  NullFilter.prototype.matches = function (doc) {\n    var val = doc.field(this.field);\n    return val !== undefined && val.value() === null;\n  };\n\n  NullFilter.prototype.canonicalId = function () {\n    return this.field.canonicalString() + ' IS null';\n  };\n\n  NullFilter.prototype.toString = function () {\n    return this.field.canonicalString() + \" IS null\";\n  };\n\n  NullFilter.prototype.equals = function (other) {\n    if (other instanceof NullFilter) {\n      return this.field.equals(other.field);\n    } else {\n      return false;\n    }\n  };\n\n  return NullFilter;\n}();\n\nexport { NullFilter };\n/**\n * Filter that matches 'NaN' values.\n */\n\nvar NanFilter =\n/** @class */\nfunction () {\n  function NanFilter(field) {\n    this.field = field;\n  }\n\n  NanFilter.prototype.matches = function (doc) {\n    var val = doc.field(this.field).value();\n    return typeof val === 'number' && isNaN(val);\n  };\n\n  NanFilter.prototype.canonicalId = function () {\n    return this.field.canonicalString() + ' IS NaN';\n  };\n\n  NanFilter.prototype.toString = function () {\n    return this.field.canonicalString() + \" IS NaN\";\n  };\n\n  NanFilter.prototype.equals = function (other) {\n    if (other instanceof NanFilter) {\n      return this.field.equals(other.field);\n    } else {\n      return false;\n    }\n  };\n\n  return NanFilter;\n}();\n\nexport { NanFilter };\n/**\n * Creates a filter based on the provided arguments.\n */\n\nexport function fieldFilter(field, op, value) {\n  if (value.equals(NullValue.INSTANCE)) {\n    if (op !== RelationOp.EQUAL) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');\n    }\n\n    return new NullFilter(field);\n  } else if (value.equals(DoubleValue.NAN)) {\n    if (op !== RelationOp.EQUAL) {\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');\n    }\n\n    return new NanFilter(field);\n  } else {\n    return new RelationFilter(field, op, value);\n  }\n}\n/**\n * The direction of sorting in an order by.\n */\n\nvar Direction =\n/** @class */\nfunction () {\n  function Direction(name) {\n    this.name = name;\n  }\n\n  Direction.prototype.toString = function () {\n    return this.name;\n  };\n\n  Direction.ASCENDING = new Direction('asc');\n  Direction.DESCENDING = new Direction('desc');\n  return Direction;\n}();\n\nexport { Direction };\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\n\nvar Bound =\n/** @class */\nfunction () {\n  function Bound(position, before) {\n    this.position = position;\n    this.before = before;\n  }\n\n  Bound.prototype.canonicalId = function () {\n    // TODO(b/29183165): Make this collision robust.\n    var canonicalId = this.before ? 'b:' : 'a:';\n\n    for (var _i = 0, _a = this.position; _i < _a.length; _i++) {\n      var component = _a[_i];\n      canonicalId += component.toString();\n    }\n\n    return canonicalId;\n  };\n  /**\n   * Returns true if a document sorts before a bound using the provided sort\n   * order.\n   */\n\n\n  Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {\n    assert(this.position.length <= orderBy.length, \"Bound has more components than query's orderBy\");\n    var comparison = 0;\n\n    for (var i = 0; i < this.position.length; i++) {\n      var orderByComponent = orderBy[i];\n      var component = this.position[i];\n\n      if (orderByComponent.field.isKeyField()) {\n        assert(component instanceof RefValue, 'Bound has a non-key value where the key path is being used.');\n        comparison = DocumentKey.comparator(component.key, doc.key);\n      } else {\n        var docValue = doc.field(orderByComponent.field);\n        assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');\n        comparison = component.compareTo(docValue);\n      }\n\n      if (orderByComponent.dir === Direction.DESCENDING) {\n        comparison = comparison * -1;\n      }\n\n      if (comparison !== 0) {\n        break;\n      }\n    }\n\n    return this.before ? comparison <= 0 : comparison < 0;\n  };\n\n  Bound.prototype.equals = function (other) {\n    if (other === null) {\n      return false;\n    }\n\n    if (this.before !== other.before || this.position.length !== other.position.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.position.length; i++) {\n      var thisPosition = this.position[i];\n      var otherPosition = other.position[i];\n      return thisPosition.equals(otherPosition);\n    }\n\n    return true;\n  };\n\n  return Bound;\n}();\n\nexport { Bound };\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\n\nvar OrderBy =\n/** @class */\nfunction () {\n  function OrderBy(field, dir) {\n    this.field = field;\n\n    if (dir === undefined) {\n      dir = Direction.ASCENDING;\n    }\n\n    this.dir = dir;\n    this.isKeyOrderBy = field.isKeyField();\n  }\n\n  OrderBy.prototype.compare = function (d1, d2) {\n    var comparison = this.isKeyOrderBy ? Document.compareByKey(d1, d2) : Document.compareByField(this.field, d1, d2);\n\n    switch (this.dir) {\n      case Direction.ASCENDING:\n        return comparison;\n\n      case Direction.DESCENDING:\n        return -1 * comparison;\n\n      default:\n        return fail('Unknown direction: ' + this.dir);\n    }\n  };\n\n  OrderBy.prototype.canonicalId = function () {\n    // TODO(b/29183165): Make this collision robust.\n    return this.field.canonicalString() + this.dir.toString();\n  };\n\n  OrderBy.prototype.toString = function () {\n    return this.field.canonicalString() + \" (\" + this.dir + \")\";\n  };\n\n  OrderBy.prototype.equals = function (other) {\n    return this.dir === other.dir && this.field.equals(other.field);\n  };\n\n  return OrderBy;\n}();\n\nexport { OrderBy };\nvar KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);\nvar KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);","map":{"version":3,"sources":["../src/core/query.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAAS,QAAT,QAAyB,mBAAzB;AACA,SAAS,WAAT,QAA4B,uBAA5B;AACA,SACE,WADF,EAGE,SAHF,EAIE,QAJF,QAKO,sBALP;AAMA,SAAS,SAAT,QAAwC,eAAxC;AACA,SAAS,MAAT,EAAiB,IAAjB,QAA6B,gBAA7B;AACA,SAAS,IAAT,EAAe,cAAf,QAAqC,eAArC;AACA,SAAS,iBAAT,QAAkC,eAAlC;;AAEA,IAAA,KAAA;AAAA;AAAA,YAAA;AAQE,WAAA,KAAA,CACW,IADX,EAEW,eAFX,EAGW,OAHX,EAIW,KAJX,EAKW,OALX,EAMW,KANX,EAMqC;AAJ1B,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,EAAA;AAA+B;;AAC/B,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAsB;;AACtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA2B;;AAC3B,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,IAAA;AAA4B;;AAC5B,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA0B;;AAL1B,SAAA,IAAA,GAAA,IAAA;AACA,SAAA,eAAA,GAAA,eAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,KAAA,GAAA,KAAA;AATH,SAAA,mBAAA,GAAqC,IAArC;AACA,SAAA,eAAA,GAAoC,IAApC;;AAUN,QAAI,KAAK,OAAT,EAAkB;AAChB,WAAK,gBAAL,CAAsB,KAAK,OAA3B;AACD;;AACD,QAAI,KAAK,KAAT,EAAgB;AACd,WAAK,gBAAL,CAAsB,KAAK,KAA3B;AACD;AACF;;AArBM,EAAA,KAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAAgC;AAC9B,WAAO,IAAI,KAAJ,CAAU,IAAV,CAAP;AACD,GAFM;;AAuBP,EAAA,MAAA,CAAA,cAAA,CAAI,KAAA,CAAA,SAAJ,EAAI,SAAJ,EAAW;SAAX,eAAA;AACE,UAAI,KAAK,eAAL,KAAyB,IAA7B,EAAmC;AACjC,YAAM,eAAe,GAAG,KAAK,wBAAL,EAAxB;AACA,YAAM,iBAAiB,GAAG,KAAK,oBAAL,EAA1B;;AACA,YAAI,eAAe,KAAK,IAApB,IAA4B,iBAAiB,KAAK,IAAtD,EAA4D;AAC1D;AACA;AACA;AACA,cAAI,eAAe,CAAC,UAAhB,EAAJ,EAAkC;AAChC,iBAAK,eAAL,GAAuB,CAAC,gBAAD,CAAvB;AACD,WAFD,MAEO;AACL,iBAAK,eAAL,GAAuB,CACrB,IAAI,OAAJ,CAAY,eAAZ,CADqB,EAErB,gBAFqB,CAAvB;AAID;AACF,SAZD,MAYO;AACL,UAAA,MAAM,CACJ,eAAe,KAAK,IAApB,IACG,iBAAiB,KAAK,IAAtB,IACC,eAAe,CAAC,MAAhB,CAAuB,iBAAvB,CAHA,EAIJ,8CAJI,CAAN;AAMA,eAAK,eAAL,GAAuB,EAAvB;AACA,cAAI,gBAAgB,GAAG,KAAvB;;AACA,eAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,eAA3B,EAAsB,EAAA,GAAA,EAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAA0C;AAArC,gBAAM,OAAO,GAAA,EAAA,CAAA,EAAA,CAAb;AACH,iBAAK,eAAL,CAAqB,IAArB,CAA0B,OAA1B;;AACA,gBAAI,OAAO,CAAC,KAAR,CAAc,UAAd,EAAJ,EAAgC;AAC9B,cAAA,gBAAgB,GAAG,IAAnB;AACD;AACF;;AACD,cAAI,CAAC,gBAAL,EAAuB;AACrB;AACA;AACA,gBAAM,aAAa,GACjB,KAAK,eAAL,CAAqB,MAArB,GAA8B,CAA9B,GACI,KAAK,eAAL,CAAqB,KAAK,eAAL,CAAqB,MAArB,GAA8B,CAAnD,EAAsD,GAD1D,GAEI,SAAS,CAAC,SAHhB;AAIA,iBAAK,eAAL,CAAqB,IAArB,CACE,aAAa,KAAK,SAAS,CAAC,SAA5B,GACI,gBADJ,GAEI,iBAHN;AAKD;AACF;AACF;;AACD,aAAO,KAAK,eAAZ;AACD,KA/CU;oBAAA;;AAAA,GAAX;;AAiDA,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,MAAV,EAAwB;AACtB,IAAA,MAAM,CACJ,KAAK,wBAAL,MAAmC,IAAnC,IACE,EAAE,MAAM,YAAY,cAApB,CADF,IAEE,CAAC,MAAM,CAAC,YAAP,EAFH,IAGE,MAAM,CAAC,KAAP,CAAa,MAAb,CAAoB,KAAK,wBAAL,EAApB,CAJE,EAKJ,4CALI,CAAN;AAQA,IAAA,MAAM,CACJ,CAAC,WAAW,CAAC,aAAZ,CAA0B,KAAK,IAA/B,CADG,EAEJ,yCAFI,CAAN;AAIA,QAAM,UAAU,GAAG,KAAK,OAAL,CAAa,MAAb,CAAoB,CAAC,MAAD,CAApB,CAAnB;AACA,WAAO,IAAI,KAAJ,CACL,KAAK,IADA,EAEL,KAAK,eAAL,CAAqB,KAArB,EAFK,EAGL,UAHK,EAIL,KAAK,KAJA,EAKL,KAAK,OALA,EAML,KAAK,KANA,CAAP;AAQD,GAtBD;;AAwBA,EAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,OAAX,EAA2B;AACzB,IAAA,MAAM,CACJ,CAAC,WAAW,CAAC,aAAZ,CAA0B,KAAK,IAA/B,CADG,EAEJ,wCAFI,CAAN;AAIA,IAAA,MAAM,CAAC,CAAC,KAAK,OAAN,IAAiB,CAAC,KAAK,KAAxB,EAA+B,kCAA/B,CAAN,CALyB,CAMzB;;AACA,QAAM,UAAU,GAAG,KAAK,eAAL,CAAqB,MAArB,CAA4B,CAAC,OAAD,CAA5B,CAAnB;AACA,WAAO,IAAI,KAAJ,CACL,KAAK,IADA,EAEL,UAFK,EAGL,KAAK,OAAL,CAAa,KAAb,EAHK,EAIL,KAAK,KAJA,EAKL,KAAK,OALA,EAML,KAAK,KANA,CAAP;AAQD,GAhBD;;AAkBA,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,KAAV,EAA8B;AAC5B,WAAO,IAAI,KAAJ,CACL,KAAK,IADA,EAEL,KAAK,eAAL,CAAqB,KAArB,EAFK,EAGL,KAAK,OAAL,CAAa,KAAb,EAHK,EAIL,KAJK,EAKL,KAAK,OALA,EAML,KAAK,KANA,CAAP;AAQD,GATD;;AAWA,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,KAAZ,EAAwB;AACtB,WAAO,IAAI,KAAJ,CACL,KAAK,IADA,EAEL,KAAK,eAAL,CAAqB,KAArB,EAFK,EAGL,KAAK,OAAL,CAAa,KAAb,EAHK,EAIL,KAAK,KAJA,EAKL,KALK,EAML,KAAK,KANA,CAAP;AAQD,GATD;;AAWA,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,KAAV,EAAsB;AACpB,WAAO,IAAI,KAAJ,CACL,KAAK,IADA,EAEL,KAAK,eAAL,CAAqB,KAArB,EAFK,EAGL,KAAK,OAAL,CAAa,KAAb,EAHK,EAIL,KAAK,KAJA,EAKL,KAAK,OALA,EAML,KANK,CAAP;AAQD,GATD,CAzIF,CAoJE;AACA;AACA;;;AACA,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,QAAI,KAAK,mBAAL,KAA6B,IAAjC,EAAuC;AACrC,UAAI,WAAW,GAAG,KAAK,IAAL,CAAU,eAAV,EAAlB;AACA,MAAA,WAAW,IAAI,KAAf;;AACA,WAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA1B,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAiC;AAA5B,YAAM,MAAM,GAAA,EAAA,CAAA,EAAA,CAAZ;AACH,QAAA,WAAW,IAAI,MAAM,CAAC,WAAP,EAAf;AACA,QAAA,WAAW,IAAI,GAAf;AACD;;AACD,MAAA,WAAW,IAAI,MAAf,CAPqC,CAQrC;;AACA,WAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA3B,EAAsB,EAAA,GAAA,EAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAAkC;AAA7B,YAAM,OAAO,GAAA,EAAA,CAAA,EAAA,CAAb;AACH,QAAA,WAAW,IAAI,OAAO,CAAC,WAAR,EAAf;AACA,QAAA,WAAW,IAAI,GAAf;AACD;;AACD,UAAI,CAAC,iBAAiB,CAAC,KAAK,KAAN,CAAtB,EAAoC;AAClC,QAAA,WAAW,IAAI,KAAf;AACA,QAAA,WAAW,IAAI,KAAK,KAApB;AACD;;AACD,UAAI,KAAK,OAAT,EAAkB;AAChB,QAAA,WAAW,IAAI,MAAf;AACA,QAAA,WAAW,IAAI,KAAK,OAAL,CAAa,WAAb,EAAf;AACD;;AACD,UAAI,KAAK,KAAT,EAAgB;AACd,QAAA,WAAW,IAAI,MAAf;AACA,QAAA,WAAW,IAAI,KAAK,KAAL,CAAW,WAAX,EAAf;AACD;;AACD,WAAK,mBAAL,GAA2B,WAA3B;AACD;;AACD,WAAO,KAAK,mBAAZ;AACD,GA7BD;;AA+BA,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,QAAI,GAAG,GAAG,WAAW,KAAK,IAAL,CAAU,eAAV,EAArB;;AACA,QAAI,KAAK,OAAL,CAAa,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,MAAA,GAAG,IAAI,iBAAe,KAAK,OAAL,CAAa,IAAb,CAAkB,IAAlB,CAAf,GAAsC,GAA7C;AACD;;AACD,QAAI,CAAC,iBAAiB,CAAC,KAAK,KAAN,CAAtB,EAAoC;AAClC,MAAA,GAAG,IAAI,cAAc,KAAK,KAA1B;AACD;;AACD,QAAI,KAAK,eAAL,CAAqB,MAArB,GAA8B,CAAlC,EAAqC;AACnC,MAAA,GAAG,IAAI,iBAAe,KAAK,eAAL,CAAqB,IAArB,CAA0B,IAA1B,CAAf,GAA8C,GAArD;AACD;;AACD,QAAI,KAAK,OAAT,EAAkB;AAChB,MAAA,GAAG,IAAI,gBAAgB,KAAK,OAAL,CAAa,WAAb,EAAvB;AACD;;AACD,QAAI,KAAK,KAAT,EAAgB;AACd,MAAA,GAAG,IAAI,cAAc,KAAK,KAAL,CAAW,WAAX,EAArB;AACD;;AAED,WAAO,GAAG,GAAG,GAAb;AACD,GAnBD;;AAqBA,EAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAmB;AACjB,QAAI,KAAK,KAAL,KAAe,KAAK,CAAC,KAAzB,EAAgC;AAC9B,aAAO,KAAP;AACD;;AAED,QAAI,KAAK,OAAL,CAAa,MAAb,KAAwB,KAAK,CAAC,OAAN,CAAc,MAA1C,EAAkD;AAChD,aAAO,KAAP;AACD;;AAED,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,OAAL,CAAa,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,UAAI,CAAC,KAAK,OAAL,CAAa,CAAb,EAAgB,MAAhB,CAAuB,KAAK,CAAC,OAAN,CAAc,CAAd,CAAvB,CAAL,EAA+C;AAC7C,eAAO,KAAP;AACD;AACF;;AAED,QAAI,KAAK,OAAL,CAAa,MAAb,KAAwB,KAAK,CAAC,OAAN,CAAc,MAA1C,EAAkD;AAChD,aAAO,KAAP;AACD;;AAED,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,OAAL,CAAa,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,UAAI,CAAC,KAAK,OAAL,CAAa,CAAb,EAAgB,MAAhB,CAAuB,KAAK,CAAC,OAAN,CAAc,CAAd,CAAvB,CAAL,EAA+C;AAC7C,eAAO,KAAP;AACD;AACF;;AAED,QAAI,CAAC,KAAK,IAAL,CAAU,MAAV,CAAiB,KAAK,CAAC,IAAvB,CAAL,EAAmC;AACjC,aAAO,KAAP;AACD;;AAED,QACE,KAAK,OAAL,KAAiB,IAAjB,GACI,CAAC,KAAK,OAAL,CAAa,MAAb,CAAoB,KAAK,CAAC,OAA1B,CADL,GAEI,KAAK,CAAC,OAAN,KAAkB,IAHxB,EAIE;AACA,aAAO,KAAP;AACD;;AAED,WAAO,KAAK,KAAL,KAAe,IAAf,GACH,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,KAAxB,CADG,GAEH,KAAK,CAAC,KAAN,KAAgB,IAFpB;AAGD,GAxCD;;AA0CA,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,EAAd,EAA4B,EAA5B,EAAwC;AACtC,QAAI,kBAAkB,GAAG,KAAzB;;AACA,SAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA3B,EAAsB,EAAA,GAAA,EAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAAkC;AAA7B,UAAM,OAAO,GAAA,EAAA,CAAA,EAAA,CAAb;AACH,UAAM,IAAI,GAAG,OAAO,CAAC,OAAR,CAAgB,EAAhB,EAAoB,EAApB,CAAb;AACA,UAAI,IAAI,KAAK,CAAb,EAAgB,OAAO,IAAP;AAChB,MAAA,kBAAkB,GAAG,kBAAkB,IAAI,OAAO,CAAC,KAAR,CAAc,UAAd,EAA3C;AACD,KANqC,CAOtC;;;AACA,IAAA,MAAM,CACJ,kBADI,EAEJ,gDAFI,CAAN;AAIA,WAAO,CAAP;AACD,GAbD;;AAeA,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,GAAR,EAAqB;AACnB,WACE,KAAK,eAAL,CAAqB,GAArB,KACA,KAAK,cAAL,CAAoB,GAApB,CADA,IAEA,KAAK,cAAL,CAAoB,GAApB,CAFA,IAGA,KAAK,aAAL,CAAmB,GAAnB,CAJF;AAMD,GAPD;;AASA,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,CAAC,iBAAiB,CAAC,KAAK,KAAN,CAAzB;AACD,GAFD;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AACE,WAAO,KAAK,eAAL,CAAqB,MAArB,GAA8B,CAA9B,GACH,KAAK,eAAL,CAAqB,CAArB,EAAwB,KADrB,GAEH,IAFJ;AAGD,GAJD;;AAMA,EAAA,KAAA,CAAA,SAAA,CAAA,wBAAA,GAAA,YAAA;AACE,SAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA1B,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAiC;AAA5B,UAAM,MAAM,GAAA,EAAA,CAAA,EAAA,CAAZ;;AACH,UAAI,MAAM,YAAY,cAAlB,IAAoC,MAAM,CAAC,YAAP,EAAxC,EAA+D;AAC7D,eAAO,MAAM,CAAC,KAAd;AACD;AACF;;AACD,WAAO,IAAP;AACD,GAPD;;AASA,EAAA,KAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,WAAO,WAAW,CAAC,aAAZ,CAA0B,KAAK,IAA/B,KAAwC,KAAK,OAAL,CAAa,MAAb,KAAwB,CAAvE;AACD,GAFD;;AAIQ,EAAA,KAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,GAAxB,EAAqC;AACnC,QAAM,OAAO,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAAxB;;AACA,QAAI,WAAW,CAAC,aAAZ,CAA0B,KAAK,IAA/B,CAAJ,EAA0C;AACxC;AACA,aAAO,KAAK,IAAL,CAAU,MAAV,CAAiB,OAAjB,CAAP;AACD,KAHD,MAGO;AACL;AACA,aACE,KAAK,IAAL,CAAU,UAAV,CAAqB,OAArB,KAAiC,KAAK,IAAL,CAAU,MAAV,KAAqB,OAAO,CAAC,MAAR,GAAiB,CADzE;AAGD;AACF,GAXO;AAaR;;;AAGG;;;AACK,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAR,UAAuB,GAAvB,EAAoC;AAClC,SAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,eAA3B,EAAsB,EAAA,GAAA,EAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAA0C;AAArC,UAAM,OAAO,GAAA,EAAA,CAAA,EAAA,CAAb,CAAqC,CACxC;;AACA,UACE,CAAC,OAAO,CAAC,KAAR,CAAc,UAAd,EAAD,IACA,GAAG,CAAC,KAAJ,CAAU,OAAO,CAAC,KAAlB,MAA6B,SAF/B,EAGE;AACA,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD,GAXO;;AAaA,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAR,UAAuB,GAAvB,EAAoC;AAClC,SAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA1B,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAiC;AAA5B,UAAM,MAAM,GAAA,EAAA,CAAA,EAAA,CAAZ;;AACH,UAAI,CAAC,MAAM,CAAC,OAAP,CAAe,GAAf,CAAL,EAA0B;AACxB,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD,GAPO;AASR;;AAEG;;;AACK,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,GAAtB,EAAmC;AACjC,QAAI,KAAK,OAAL,IAAgB,CAAC,KAAK,OAAL,CAAa,mBAAb,CAAiC,KAAK,OAAtC,EAA+C,GAA/C,CAArB,EAA0E;AACxE,aAAO,KAAP;AACD;;AACD,QAAI,KAAK,KAAL,IAAc,KAAK,KAAL,CAAW,mBAAX,CAA+B,KAAK,OAApC,EAA6C,GAA7C,CAAlB,EAAqE;AACnE,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD,GARO;;AAUA,EAAA,KAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,KAAzB,EAAqC;AACnC,IAAA,MAAM,CACJ,KAAK,CAAC,QAAN,CAAe,MAAf,IAAyB,KAAK,OAAL,CAAa,MADlC,EAEJ,8BAFI,CAAN;AAID,GALO;;AAMV,SAAA,KAAA;AAAC,CA9VD,EAAA;;;;AAsWA,IAAA,UAAA;AAAA;AAAA,YAAA;AAwBE,WAAA,UAAA,CAAmB,IAAnB,EAA+B;AAAZ,SAAA,IAAA,GAAA,IAAA;AAAgB;;AAjB5B,EAAA,UAAA,CAAA,UAAA,GAAP,UAAkB,EAAlB,EAA4B;AAC1B,YAAQ,EAAR;AACE,WAAK,GAAL;AACE,eAAO,UAAU,CAAC,SAAlB;;AACF,WAAK,IAAL;AACE,eAAO,UAAU,CAAC,kBAAlB;;AACF,WAAK,IAAL;AACE,eAAO,UAAU,CAAC,KAAlB;;AACF,WAAK,IAAL;AACE,eAAO,UAAU,CAAC,qBAAlB;;AACF,WAAK,GAAL;AACE,eAAO,UAAU,CAAC,YAAlB;;AACF;AACE,eAAO,IAAI,CAAC,uBAAuB,EAAxB,CAAX;AAZJ;AAcD,GAfM;;AAmBP,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,KAAK,IAAZ;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAwB;AACtB,WAAO,KAAK,IAAL,KAAc,KAAK,CAAC,IAA3B;AACD,GAFD;;AA7BO,EAAA,UAAA,CAAA,SAAA,GAAY,IAAI,UAAJ,CAAe,GAAf,CAAZ;AACA,EAAA,UAAA,CAAA,kBAAA,GAAqB,IAAI,UAAJ,CAAe,IAAf,CAArB;AACA,EAAA,UAAA,CAAA,KAAA,GAAQ,IAAI,UAAJ,CAAe,IAAf,CAAR;AACA,EAAA,UAAA,CAAA,YAAA,GAAe,IAAI,UAAJ,CAAe,GAAf,CAAf;AACA,EAAA,UAAA,CAAA,qBAAA,GAAwB,IAAI,UAAJ,CAAe,IAAf,CAAxB;AA4BT,SAAA,UAAA;AAAC,CAjCD,EAAA;;SAAa,U;;AAmCb,IAAA,cAAA;AAAA;AAAA,YAAA;AACE,WAAA,cAAA,CACS,KADT,EAES,EAFT,EAGS,KAHT,EAG0B;AAFjB,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,EAAA,GAAA,EAAA;AACA,SAAA,KAAA,GAAA,KAAA;AACL;;AAEJ,EAAA,cAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,GAAR,EAAqB;AACnB,QAAI,KAAK,KAAL,CAAW,UAAX,EAAJ,EAA6B;AAC3B,MAAA,MAAM,CACJ,KAAK,KAAL,YAAsB,QADlB,EAEJ,mDAFI,CAAN;AAIA,UAAM,QAAQ,GAAG,KAAK,KAAtB;AACA,UAAM,UAAU,GAAG,WAAW,CAAC,UAAZ,CAAuB,GAAG,CAAC,GAA3B,EAAgC,QAAQ,CAAC,GAAzC,CAAnB;AACA,aAAO,KAAK,iBAAL,CAAuB,UAAvB,CAAP;AACD,KARD,MAQO;AACL,UAAM,GAAG,GAAG,GAAG,CAAC,KAAJ,CAAU,KAAK,KAAf,CAAZ;AACA,aAAO,GAAG,KAAK,SAAR,IAAqB,KAAK,YAAL,CAAkB,GAAlB,CAA5B;AACD;AACF,GAbD;;AAeQ,EAAA,cAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,KAArB,EAAsC;AACpC;AACA,QAAI,KAAK,KAAL,CAAW,SAAX,KAAyB,KAAK,CAAC,SAAnC,EAA8C;AAC5C,aAAO,KAAP;AACD;;AACD,WAAO,KAAK,iBAAL,CAAuB,KAAK,CAAC,SAAN,CAAgB,KAAK,KAArB,CAAvB,CAAP;AACD,GANO;;AAQA,EAAA,cAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,UAA1B,EAA4C;AAC1C,YAAQ,KAAK,EAAb;AACE,WAAK,UAAU,CAAC,SAAhB;AACE,eAAO,UAAU,GAAG,CAApB;;AACF,WAAK,UAAU,CAAC,kBAAhB;AACE,eAAO,UAAU,IAAI,CAArB;;AACF,WAAK,UAAU,CAAC,KAAhB;AACE,eAAO,UAAU,KAAK,CAAtB;;AACF,WAAK,UAAU,CAAC,YAAhB;AACE,eAAO,UAAU,GAAG,CAApB;;AACF,WAAK,UAAU,CAAC,qBAAhB;AACE,eAAO,UAAU,IAAI,CAArB;;AACF;AACE,eAAO,IAAI,CAAC,wBAAwB,KAAK,EAA9B,CAAX;AAZJ;AAcD,GAfO;;AAiBR,EAAA,cAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,WAAO,KAAK,EAAL,KAAY,UAAU,CAAC,KAA9B;AACD,GAFD;;AAIA,EAAA,cAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE;AACA;AACA;AACA,WACE,KAAK,KAAL,CAAW,eAAX,KAA+B,KAAK,EAAL,CAAQ,QAAR,EAA/B,GAAoD,KAAK,KAAL,CAAW,QAAX,EADtD;AAGD,GAPD;;AASA,EAAA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAoB;AAClB,QAAI,KAAK,YAAY,cAArB,EAAqC;AACnC,aACE,KAAK,EAAL,CAAQ,MAAR,CAAe,KAAK,CAAC,EAArB,KACA,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,KAAxB,CADA,IAEA,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,KAAxB,CAHF;AAKD,KAND,MAMO;AACL,aAAO,KAAP;AACD;AACF,GAVD;;AAYA,EAAA,cAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAU,KAAK,KAAL,CAAW,eAAX,KAA4B,GAA5B,GAAgC,KAAK,EAArC,GAAuC,GAAvC,GAA2C,KAAK,KAAL,CAAW,KAAX,EAArD;AACD,GAFD;;AAGF,SAAA,cAAA;AAAC,CA3ED,EAAA;;;AA6EA;;AAEG;;AACH,IAAA,UAAA;AAAA;AAAA,YAAA;AACE,WAAA,UAAA,CAAmB,KAAnB,EAAmC;AAAhB,SAAA,KAAA,GAAA,KAAA;AAAoB;;AAEvC,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,GAAR,EAAqB;AACnB,QAAM,GAAG,GAAG,GAAG,CAAC,KAAJ,CAAU,KAAK,KAAf,CAAZ;AACA,WAAO,GAAG,KAAK,SAAR,IAAqB,GAAG,CAAC,KAAJ,OAAgB,IAA5C;AACD,GAHD;;AAKA,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,WAAO,KAAK,KAAL,CAAW,eAAX,KAA+B,UAAtC;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAU,KAAK,KAAL,CAAW,eAAX,KAA4B,UAAtC;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAoB;AAClB,QAAI,KAAK,YAAY,UAArB,EAAiC;AAC/B,aAAO,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,KAAxB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAP;AACD;AACF,GAND;;AAOF,SAAA,UAAA;AAAC,CAvBD,EAAA;;;AAyBA;;AAEG;;AACH,IAAA,SAAA;AAAA;AAAA,YAAA;AACE,WAAA,SAAA,CAAmB,KAAnB,EAAmC;AAAhB,SAAA,KAAA,GAAA,KAAA;AAAoB;;AAEvC,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,GAAR,EAAqB;AACnB,QAAM,GAAG,GAAG,GAAG,CAAC,KAAJ,CAAU,KAAK,KAAf,EAAsB,KAAtB,EAAZ;AACA,WAAO,OAAO,GAAP,KAAe,QAAf,IAA2B,KAAK,CAAC,GAAD,CAAvC;AACD,GAHD;;AAKA,EAAA,SAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,WAAO,KAAK,KAAL,CAAW,eAAX,KAA+B,SAAtC;AACD,GAFD;;AAIA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAU,KAAK,KAAL,CAAW,eAAX,KAA4B,SAAtC;AACD,GAFD;;AAIA,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAoB;AAClB,QAAI,KAAK,YAAY,SAArB,EAAgC;AAC9B,aAAO,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,KAAxB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAP;AACD;AACF,GAND;;AAOF,SAAA,SAAA;AAAC,CAvBD,EAAA;;;AAyBA;;AAEG;;AACH,OAAM,SAAA,WAAA,CACJ,KADI,EAEJ,EAFI,EAGJ,KAHI,EAGa;AAEjB,MAAI,KAAK,CAAC,MAAN,CAAa,SAAS,CAAC,QAAvB,CAAJ,EAAsC;AACpC,QAAI,EAAE,KAAK,UAAU,CAAC,KAAtB,EAA6B;AAC3B,YAAM,IAAI,cAAJ,CACJ,IAAI,CAAC,gBADD,EAEJ,gDAAgD,sBAF5C,CAAN;AAID;;AACD,WAAO,IAAI,UAAJ,CAAe,KAAf,CAAP;AACD,GARD,MAQO,IAAI,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,GAAzB,CAAJ,EAAmC;AACxC,QAAI,EAAE,KAAK,UAAU,CAAC,KAAtB,EAA6B;AAC3B,YAAM,IAAI,cAAJ,CACJ,IAAI,CAAC,gBADD,EAEJ,gDAAgD,qBAF5C,CAAN;AAID;;AACD,WAAO,IAAI,SAAJ,CAAc,KAAd,CAAP;AACD,GARM,MAQA;AACL,WAAO,IAAI,cAAJ,CAAmB,KAAnB,EAA0B,EAA1B,EAA8B,KAA9B,CAAP;AACD;AACF;AAED;;AAEG;;AACH,IAAA,SAAA;AAAA;AAAA,YAAA;AAIE,WAAA,SAAA,CAA2B,IAA3B,EAAuC;AAAZ,SAAA,IAAA,GAAA,IAAA;AAAgB;;AAE3C,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,KAAK,IAAZ;AACD,GAFD;;AALO,EAAA,SAAA,CAAA,SAAA,GAAY,IAAI,SAAJ,CAAc,KAAd,CAAZ;AACA,EAAA,SAAA,CAAA,UAAA,GAAa,IAAI,SAAJ,CAAc,MAAd,CAAb;AAOT,SAAA,SAAA;AAAC,CATD,EAAA;;SAAa,S;AAWb;;;;;;;;;;;;;AAaG;;AACH,IAAA,KAAA;AAAA;AAAA,YAAA;AACE,WAAA,KAAA,CAAqB,QAArB,EAAsD,MAAtD,EAAqE;AAAhD,SAAA,QAAA,GAAA,QAAA;AAAiC,SAAA,MAAA,GAAA,MAAA;AAAmB;;AAEzE,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE;AACA,QAAI,WAAW,GAAG,KAAK,MAAL,GAAc,IAAd,GAAqB,IAAvC;;AACA,SAAwB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAA7B,EAAwB,EAAA,GAAA,EAAA,CAAA,MAAxB,EAAwB,EAAA,EAAxB,EAAqC;AAAhC,UAAM,SAAS,GAAA,EAAA,CAAA,EAAA,CAAf;AACH,MAAA,WAAW,IAAI,SAAS,CAAC,QAAV,EAAf;AACD;;AACD,WAAO,WAAP;AACD,GAPD;AASA;;;AAGG;;;AACH,EAAA,KAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,OAApB,EAAwC,GAAxC,EAAqD;AACnD,IAAA,MAAM,CACJ,KAAK,QAAL,CAAc,MAAd,IAAwB,OAAO,CAAC,MAD5B,EAEJ,gDAFI,CAAN;AAIA,QAAI,UAAU,GAAG,CAAjB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,QAAL,CAAc,MAAlC,EAA0C,CAAC,EAA3C,EAA+C;AAC7C,UAAM,gBAAgB,GAAG,OAAO,CAAC,CAAD,CAAhC;AACA,UAAM,SAAS,GAAG,KAAK,QAAL,CAAc,CAAd,CAAlB;;AACA,UAAI,gBAAgB,CAAC,KAAjB,CAAuB,UAAvB,EAAJ,EAAyC;AACvC,QAAA,MAAM,CACJ,SAAS,YAAY,QADjB,EAEJ,6DAFI,CAAN;AAIA,QAAA,UAAU,GAAG,WAAW,CAAC,UAAZ,CACV,SAAsB,CAAC,GADb,EAEX,GAAG,CAAC,GAFO,CAAb;AAID,OATD,MASO;AACL,YAAM,QAAQ,GAAG,GAAG,CAAC,KAAJ,CAAU,gBAAgB,CAAC,KAA3B,CAAjB;AACA,QAAA,MAAM,CACJ,QAAQ,KAAK,SADT,EAEJ,gEAFI,CAAN;AAIA,QAAA,UAAU,GAAG,SAAS,CAAC,SAAV,CAAoB,QAApB,CAAb;AACD;;AACD,UAAI,gBAAgB,CAAC,GAAjB,KAAyB,SAAS,CAAC,UAAvC,EAAmD;AACjD,QAAA,UAAU,GAAG,UAAU,GAAG,CAAC,CAA3B;AACD;;AACD,UAAI,UAAU,KAAK,CAAnB,EAAsB;AACpB;AACD;AACF;;AACD,WAAO,KAAK,MAAL,GAAc,UAAU,IAAI,CAA5B,GAAgC,UAAU,GAAG,CAApD;AACD,GAlCD;;AAoCA,EAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAA0B;AACxB,QAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAO,KAAP;AACD;;AACD,QACE,KAAK,MAAL,KAAgB,KAAK,CAAC,MAAtB,IACA,KAAK,QAAL,CAAc,MAAd,KAAyB,KAAK,CAAC,QAAN,CAAe,MAF1C,EAGE;AACA,aAAO,KAAP;AACD;;AACD,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,QAAL,CAAc,MAAlC,EAA0C,CAAC,EAA3C,EAA+C;AAC7C,UAAM,YAAY,GAAG,KAAK,QAAL,CAAc,CAAd,CAArB;AACA,UAAM,aAAa,GAAG,KAAK,CAAC,QAAN,CAAe,CAAf,CAAtB;AACA,aAAO,YAAY,CAAC,MAAb,CAAoB,aAApB,CAAP;AACD;;AACD,WAAO,IAAP;AACD,GAhBD;;AAiBF,SAAA,KAAA;AAAC,CArED,EAAA;;;AAuEA;;AAEG;;AACH,IAAA,OAAA;AAAA;AAAA,YAAA;AAIE,WAAA,OAAA,CAA4B,KAA5B,EAA8C,GAA9C,EAA6D;AAAjC,SAAA,KAAA,GAAA,KAAA;;AAC1B,QAAI,GAAG,KAAK,SAAZ,EAAuB;AACrB,MAAA,GAAG,GAAG,SAAS,CAAC,SAAhB;AACD;;AACD,SAAK,GAAL,GAAW,GAAX;AACA,SAAK,YAAL,GAAoB,KAAK,CAAC,UAAN,EAApB;AACD;;AAED,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,EAAR,EAAsB,EAAtB,EAAkC;AAChC,QAAM,UAAU,GAAG,KAAK,YAAL,GACf,QAAQ,CAAC,YAAT,CAAsB,EAAtB,EAA0B,EAA1B,CADe,GAEf,QAAQ,CAAC,cAAT,CAAwB,KAAK,KAA7B,EAAoC,EAApC,EAAwC,EAAxC,CAFJ;;AAGA,YAAQ,KAAK,GAAb;AACE,WAAK,SAAS,CAAC,SAAf;AACE,eAAO,UAAP;;AACF,WAAK,SAAS,CAAC,UAAf;AACE,eAAO,CAAC,CAAD,GAAK,UAAZ;;AACF;AACE,eAAO,IAAI,CAAC,wBAAwB,KAAK,GAA9B,CAAX;AANJ;AAQD,GAZD;;AAcA,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE;AACA,WAAO,KAAK,KAAL,CAAW,eAAX,KAA+B,KAAK,GAAL,CAAS,QAAT,EAAtC;AACD,GAHD;;AAKA,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAU,KAAK,KAAL,CAAW,eAAX,KAA4B,IAA5B,GAAiC,KAAK,GAAtC,GAAyC,GAAnD;AACD,GAFD;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAqB;AACnB,WAAO,KAAK,GAAL,KAAa,KAAK,CAAC,GAAnB,IAA0B,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,KAAxB,CAAjC;AACD,GAFD;;AAGF,SAAA,OAAA;AAAC,CAtCD,EAAA;;;AAwCA,IAAM,gBAAgB,GAAG,IAAI,OAAJ,CAAY,SAAS,CAAC,QAAV,EAAZ,EAAkC,SAAS,CAAC,SAA5C,CAAzB;AACA,IAAM,iBAAiB,GAAG,IAAI,OAAJ,CACxB,SAAS,CAAC,QAAV,EADwB,EAExB,SAAS,CAAC,UAFc,CAA1B","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  DoubleValue,\n  FieldValue,\n  NullValue,\n  RefValue\n} from '../model/field_value';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\n\nexport class Query {\n  static atPath(path: ResourcePath): Query {\n    return new Query(path);\n  }\n\n  private memoizedCanonicalId: string | null = null;\n  private memoizedOrderBy: OrderBy[] | null = null;\n\n  constructor(\n    readonly path: ResourcePath,\n    readonly explicitOrderBy: OrderBy[] = [],\n    readonly filters: Filter[] = [],\n    readonly limit: number | null = null,\n    readonly startAt: Bound | null = null,\n    readonly endAt: Bound | null = null\n  ) {\n    if (this.startAt) {\n      this.assertValidBound(this.startAt);\n    }\n    if (this.endAt) {\n      this.assertValidBound(this.endAt);\n    }\n  }\n\n  get orderBy(): OrderBy[] {\n    if (this.memoizedOrderBy === null) {\n      const inequalityField = this.getInequalityFilterField();\n      const firstOrderByField = this.getFirstOrderByField();\n      if (inequalityField !== null && firstOrderByField === null) {\n        // In order to implicitly add key ordering, we must also add the\n        // inequality filter field for it to be a valid query.\n        // Note that the default inequality field and key ordering is ascending.\n        if (inequalityField.isKeyField()) {\n          this.memoizedOrderBy = [KEY_ORDERING_ASC];\n        } else {\n          this.memoizedOrderBy = [\n            new OrderBy(inequalityField),\n            KEY_ORDERING_ASC\n          ];\n        }\n      } else {\n        assert(\n          inequalityField === null ||\n            (firstOrderByField !== null &&\n              inequalityField.equals(firstOrderByField)),\n          'First orderBy should match inequality field.'\n        );\n        this.memoizedOrderBy = [];\n        let foundKeyOrdering = false;\n        for (const orderBy of this.explicitOrderBy) {\n          this.memoizedOrderBy.push(orderBy);\n          if (orderBy.field.isKeyField()) {\n            foundKeyOrdering = true;\n          }\n        }\n        if (!foundKeyOrdering) {\n          // The order of the implicit key ordering always matches the last\n          // explicit order by\n          const lastDirection =\n            this.explicitOrderBy.length > 0\n              ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n              : Direction.ASCENDING;\n          this.memoizedOrderBy.push(\n            lastDirection === Direction.ASCENDING\n              ? KEY_ORDERING_ASC\n              : KEY_ORDERING_DESC\n          );\n        }\n      }\n    }\n    return this.memoizedOrderBy;\n  }\n\n  addFilter(filter: Filter): Query {\n    assert(\n      this.getInequalityFilterField() == null ||\n        !(filter instanceof RelationFilter) ||\n        !filter.isInequality() ||\n        filter.field.equals(this.getInequalityFilterField()!),\n      'Query must only have one inequality field.'\n    );\n\n    assert(\n      !DocumentKey.isDocumentKey(this.path),\n      'No filtering allowed for document query'\n    );\n    const newFilters = this.filters.concat([filter]);\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      newFilters,\n      this.limit,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  addOrderBy(orderBy: OrderBy): Query {\n    assert(\n      !DocumentKey.isDocumentKey(this.path),\n      'No ordering allowed for document query'\n    );\n    assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = this.explicitOrderBy.concat([orderBy]);\n    return new Query(\n      this.path,\n      newOrderBy,\n      this.filters.slice(),\n      this.limit,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withLimit(limit: number | null): Query {\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      limit,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withStartAt(bound: Bound): Query {\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      bound,\n      this.endAt\n    );\n  }\n\n  withEndAt(bound: Bound): Query {\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      this.startAt,\n      bound\n    );\n  }\n\n  // TODO(b/29183165): This is used to get a unique string from a query to, for\n  // example, use as a dictionary key, but the implementation is subject to\n  // collisions. Make it collision-free.\n  canonicalId(): string {\n    if (this.memoizedCanonicalId === null) {\n      let canonicalId = this.path.canonicalString();\n      canonicalId += '|f:';\n      for (const filter of this.filters) {\n        canonicalId += filter.canonicalId();\n        canonicalId += ',';\n      }\n      canonicalId += '|ob:';\n      // TODO(dimond): make this collision resistant\n      for (const orderBy of this.orderBy) {\n        canonicalId += orderBy.canonicalId();\n        canonicalId += ',';\n      }\n      if (!isNullOrUndefined(this.limit)) {\n        canonicalId += '|l:';\n        canonicalId += this.limit!;\n      }\n      if (this.startAt) {\n        canonicalId += '|lb:';\n        canonicalId += this.startAt.canonicalId();\n      }\n      if (this.endAt) {\n        canonicalId += '|ub:';\n        canonicalId += this.endAt.canonicalId();\n      }\n      this.memoizedCanonicalId = canonicalId;\n    }\n    return this.memoizedCanonicalId;\n  }\n\n  toString(): string {\n    let str = 'Query(' + this.path.canonicalString();\n    if (this.filters.length > 0) {\n      str += `, filters: [${this.filters.join(', ')}]`;\n    }\n    if (!isNullOrUndefined(this.limit)) {\n      str += ', limit: ' + this.limit;\n    }\n    if (this.explicitOrderBy.length > 0) {\n      str += `, orderBy: [${this.explicitOrderBy.join(', ')}]`;\n    }\n    if (this.startAt) {\n      str += ', startAt: ' + this.startAt.canonicalId();\n    }\n    if (this.endAt) {\n      str += ', endAt: ' + this.endAt.canonicalId();\n    }\n\n    return str + ')';\n  }\n\n  equals(other: Query): boolean {\n    if (this.limit !== other.limit) {\n      return false;\n    }\n\n    if (this.orderBy.length !== other.orderBy.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.orderBy.length; i++) {\n      if (!this.orderBy[i].equals(other.orderBy[i])) {\n        return false;\n      }\n    }\n\n    if (this.filters.length !== other.filters.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].equals(other.filters[i])) {\n        return false;\n      }\n    }\n\n    if (!this.path.equals(other.path)) {\n      return false;\n    }\n\n    if (\n      this.startAt !== null\n        ? !this.startAt.equals(other.startAt)\n        : other.startAt !== null\n    ) {\n      return false;\n    }\n\n    return this.endAt !== null\n      ? this.endAt.equals(other.endAt)\n      : other.endAt === null;\n  }\n\n  docComparator(d1: Document, d2: Document): number {\n    let comparedOnKeyField = false;\n    for (const orderBy of this.orderBy) {\n      const comp = orderBy.compare(d1, d2);\n      if (comp !== 0) return comp;\n      comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n    }\n    // Assert that we actually compared by key\n    assert(\n      comparedOnKeyField,\n      \"orderBy used that doesn't compare on key field\"\n    );\n    return 0;\n  }\n\n  matches(doc: Document): boolean {\n    return (\n      this.matchesAncestor(doc) &&\n      this.matchesOrderBy(doc) &&\n      this.matchesFilters(doc) &&\n      this.matchesBounds(doc)\n    );\n  }\n\n  hasLimit(): boolean {\n    return !isNullOrUndefined(this.limit);\n  }\n\n  getFirstOrderByField(): FieldPath | null {\n    return this.explicitOrderBy.length > 0\n      ? this.explicitOrderBy[0].field\n      : null;\n  }\n\n  getInequalityFilterField(): FieldPath | null {\n    for (const filter of this.filters) {\n      if (filter instanceof RelationFilter && filter.isInequality()) {\n        return filter.field;\n      }\n    }\n    return null;\n  }\n\n  isDocumentQuery(): boolean {\n    return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n  }\n\n  private matchesAncestor(doc: Document): boolean {\n    const docPath = doc.key.path;\n    if (DocumentKey.isDocumentKey(this.path)) {\n      // exact match for document queries\n      return this.path.equals(docPath);\n    } else {\n      // shallow ancestor queries by default\n      return (\n        this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1\n      );\n    }\n  }\n\n  /**\n   * A document must have a value for every ordering clause in order to show up\n   * in the results.\n   */\n  private matchesOrderBy(doc: Document): boolean {\n    for (const orderBy of this.explicitOrderBy) {\n      // order by key always matches\n      if (\n        !orderBy.field.isKeyField() &&\n        doc.field(orderBy.field) === undefined\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private matchesFilters(doc: Document): boolean {\n    for (const filter of this.filters) {\n      if (!filter.matches(doc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Makes sure a document is within the bounds, if provided.\n   */\n  private matchesBounds(doc: Document): boolean {\n    if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n    if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n    return true;\n  }\n\n  private assertValidBound(bound: Bound): void {\n    assert(\n      bound.position.length <= this.orderBy.length,\n      'Bound is longer than orderBy'\n    );\n  }\n}\n\nexport interface Filter {\n  matches(doc: Document): boolean;\n  canonicalId(): string;\n  equals(filter: Filter): boolean;\n}\n\nexport class RelationOp {\n  static LESS_THAN = new RelationOp('<');\n  static LESS_THAN_OR_EQUAL = new RelationOp('<=');\n  static EQUAL = new RelationOp('==');\n  static GREATER_THAN = new RelationOp('>');\n  static GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n\n  static fromString(op: string): RelationOp {\n    switch (op) {\n      case '<':\n        return RelationOp.LESS_THAN;\n      case '<=':\n        return RelationOp.LESS_THAN_OR_EQUAL;\n      case '==':\n        return RelationOp.EQUAL;\n      case '>=':\n        return RelationOp.GREATER_THAN_OR_EQUAL;\n      case '>':\n        return RelationOp.GREATER_THAN;\n      default:\n        return fail('Unknown relation: ' + op);\n    }\n  }\n\n  constructor(public name: string) {}\n\n  toString(): string {\n    return this.name;\n  }\n\n  equals(other: RelationOp): boolean {\n    return this.name === other.name;\n  }\n}\n\nexport class RelationFilter implements Filter {\n  constructor(\n    public field: FieldPath,\n    public op: RelationOp,\n    public value: FieldValue\n  ) {}\n\n  matches(doc: Document): boolean {\n    if (this.field.isKeyField()) {\n      assert(\n        this.value instanceof RefValue,\n        'Comparing on key, but filter value not a RefValue'\n      );\n      const refValue = this.value as RefValue;\n      const comparison = DocumentKey.comparator(doc.key, refValue.key);\n      return this.matchesComparison(comparison);\n    } else {\n      const val = doc.field(this.field);\n      return val !== undefined && this.matchesValue(val);\n    }\n  }\n\n  private matchesValue(value: FieldValue): boolean {\n    // Only compare types with matching backend order (such as double and int).\n    if (this.value.typeOrder !== value.typeOrder) {\n      return false;\n    }\n    return this.matchesComparison(value.compareTo(this.value));\n  }\n\n  private matchesComparison(comparison: number) {\n    switch (this.op) {\n      case RelationOp.LESS_THAN:\n        return comparison < 0;\n      case RelationOp.LESS_THAN_OR_EQUAL:\n        return comparison <= 0;\n      case RelationOp.EQUAL:\n        return comparison === 0;\n      case RelationOp.GREATER_THAN:\n        return comparison > 0;\n      case RelationOp.GREATER_THAN_OR_EQUAL:\n        return comparison >= 0;\n      default:\n        return fail('Unknown relation op' + this.op);\n    }\n  }\n\n  isInequality(): boolean {\n    return this.op !== RelationOp.EQUAL;\n  }\n\n  canonicalId(): string {\n    // TODO(b/29183165): Technically, this won't be unique if two values have\n    // the same description, such as the int 3 and the string \"3\". So we should\n    // add the types in here somehow, too.\n    return (\n      this.field.canonicalString() + this.op.toString() + this.value.toString()\n    );\n  }\n\n  equals(other: Filter): boolean {\n    if (other instanceof RelationFilter) {\n      return (\n        this.op.equals(other.op) &&\n        this.field.equals(other.field) &&\n        this.value.equals(other.value)\n      );\n    } else {\n      return false;\n    }\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} ${this.op} ${this.value.value()}`;\n  }\n}\n\n/**\n * Filter that matches 'null' values.\n */\nexport class NullFilter implements Filter {\n  constructor(public field: FieldPath) {}\n\n  matches(doc: Document): boolean {\n    const val = doc.field(this.field);\n    return val !== undefined && val.value() === null;\n  }\n\n  canonicalId(): string {\n    return this.field.canonicalString() + ' IS null';\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} IS null`;\n  }\n\n  equals(other: Filter): boolean {\n    if (other instanceof NullFilter) {\n      return this.field.equals(other.field);\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Filter that matches 'NaN' values.\n */\nexport class NanFilter implements Filter {\n  constructor(public field: FieldPath) {}\n\n  matches(doc: Document): boolean {\n    const val = doc.field(this.field).value();\n    return typeof val === 'number' && isNaN(val);\n  }\n\n  canonicalId(): string {\n    return this.field.canonicalString() + ' IS NaN';\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} IS NaN`;\n  }\n\n  equals(other: Filter): boolean {\n    if (other instanceof NanFilter) {\n      return this.field.equals(other.field);\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Creates a filter based on the provided arguments.\n */\nexport function fieldFilter(\n  field: FieldPath,\n  op: RelationOp,\n  value: FieldValue\n) {\n  if (value.equals(NullValue.INSTANCE)) {\n    if (op !== RelationOp.EQUAL) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You can only perform equals ' + 'comparisons on null.'\n      );\n    }\n    return new NullFilter(field);\n  } else if (value.equals(DoubleValue.NAN)) {\n    if (op !== RelationOp.EQUAL) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You can only perform equals ' + 'comparisons on NaN.'\n      );\n    }\n    return new NanFilter(field);\n  } else {\n    return new RelationFilter(field, op, value);\n  }\n}\n\n/**\n * The direction of sorting in an order by.\n */\nexport class Direction {\n  static ASCENDING = new Direction('asc');\n  static DESCENDING = new Direction('desc');\n\n  private constructor(public name: string) {}\n\n  toString(): string {\n    return this.name;\n  }\n}\n\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nexport class Bound {\n  constructor(readonly position: FieldValue[], readonly before: boolean) {}\n\n  canonicalId(): string {\n    // TODO(b/29183165): Make this collision robust.\n    let canonicalId = this.before ? 'b:' : 'a:';\n    for (const component of this.position) {\n      canonicalId += component.toString();\n    }\n    return canonicalId;\n  }\n\n  /**\n   * Returns true if a document sorts before a bound using the provided sort\n   * order.\n   */\n  sortsBeforeDocument(orderBy: OrderBy[], doc: Document): boolean {\n    assert(\n      this.position.length <= orderBy.length,\n      \"Bound has more components than query's orderBy\"\n    );\n    let comparison = 0;\n    for (let i = 0; i < this.position.length; i++) {\n      const orderByComponent = orderBy[i];\n      const component = this.position[i];\n      if (orderByComponent.field.isKeyField()) {\n        assert(\n          component instanceof RefValue,\n          'Bound has a non-key value where the key path is being used.'\n        );\n        comparison = DocumentKey.comparator(\n          (component as RefValue).key,\n          doc.key\n        );\n      } else {\n        const docValue = doc.field(orderByComponent.field);\n        assert(\n          docValue !== undefined,\n          'Field should exist since document matched the orderBy already.'\n        );\n        comparison = component.compareTo(docValue);\n      }\n      if (orderByComponent.dir === Direction.DESCENDING) {\n        comparison = comparison * -1;\n      }\n      if (comparison !== 0) {\n        break;\n      }\n    }\n    return this.before ? comparison <= 0 : comparison < 0;\n  }\n\n  equals(other: Bound | null): boolean {\n    if (other === null) {\n      return false;\n    }\n    if (\n      this.before !== other.before ||\n      this.position.length !== other.position.length\n    ) {\n      return false;\n    }\n    for (let i = 0; i < this.position.length; i++) {\n      const thisPosition = this.position[i];\n      const otherPosition = other.position[i];\n      return thisPosition.equals(otherPosition);\n    }\n    return true;\n  }\n}\n\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nexport class OrderBy {\n  readonly dir: Direction;\n  private readonly isKeyOrderBy: boolean;\n\n  constructor(public readonly field: FieldPath, dir?: Direction) {\n    if (dir === undefined) {\n      dir = Direction.ASCENDING;\n    }\n    this.dir = dir;\n    this.isKeyOrderBy = field.isKeyField();\n  }\n\n  compare(d1: Document, d2: Document): number {\n    const comparison = this.isKeyOrderBy\n      ? Document.compareByKey(d1, d2)\n      : Document.compareByField(this.field, d1, d2);\n    switch (this.dir) {\n      case Direction.ASCENDING:\n        return comparison;\n      case Direction.DESCENDING:\n        return -1 * comparison;\n      default:\n        return fail('Unknown direction: ' + this.dir);\n    }\n  }\n\n  canonicalId(): string {\n    // TODO(b/29183165): Make this collision robust.\n    return this.field.canonicalString() + this.dir.toString();\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} (${this.dir})`;\n  }\n\n  equals(other: OrderBy): boolean {\n    return this.dir === other.dir && this.field.equals(other.field);\n  }\n}\n\nconst KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);\nconst KEY_ORDERING_DESC = new OrderBy(\n  FieldPath.keyField(),\n  Direction.DESCENDING\n);\n"]},"metadata":{},"sourceType":"module"}