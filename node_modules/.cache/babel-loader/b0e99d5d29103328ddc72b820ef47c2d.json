{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RESERVED_BITS = 1;\nvar GeneratorIds;\n\n(function (GeneratorIds) {\n  GeneratorIds[GeneratorIds[\"LocalStore\"] = 0] = \"LocalStore\";\n  GeneratorIds[GeneratorIds[\"SyncEngine\"] = 1] = \"SyncEngine\";\n})(GeneratorIds || (GeneratorIds = {}));\n/**\n * TargetIdGenerator generates monotonically increasing integer IDs. There are\n * separate generators for different scopes. While these generators will operate\n * independently of each other, they are scoped, such that no two generators\n * will ever produce the same ID. This is useful, because sometimes the backend\n * may group IDs from separate parts of the client into the same ID space.\n */\n\n\nvar TargetIdGenerator =\n/** @class */\nfunction () {\n  function TargetIdGenerator(generatorId, initAfter) {\n    if (initAfter === void 0) {\n      initAfter = 0;\n    }\n\n    this.generatorId = generatorId; // Replace the generator part of initAfter with this generator's ID.\n\n    var afterWithoutGenerator = initAfter >> RESERVED_BITS << RESERVED_BITS;\n    var afterGenerator = initAfter - afterWithoutGenerator;\n\n    if (afterGenerator >= generatorId) {\n      // For example, if:\n      //   this.generatorId = 0b0000\n      //   after = 0b1011\n      //   afterGenerator = 0b0001\n      // Then:\n      //   previous = 0b1010\n      //   next = 0b1100\n      this.previousId = afterWithoutGenerator | this.generatorId;\n    } else {\n      // For example, if:\n      //   this.generatorId = 0b0001\n      //   after = 0b1010\n      //   afterGenerator = 0b0000\n      // Then:\n      //   previous = 0b1001\n      //   next = 0b1011\n      this.previousId = (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);\n    }\n  }\n\n  TargetIdGenerator.prototype.next = function () {\n    this.previousId += 1 << RESERVED_BITS;\n    return this.previousId;\n  };\n\n  TargetIdGenerator.forLocalStore = function (initAfter) {\n    if (initAfter === void 0) {\n      initAfter = 0;\n    }\n\n    return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);\n  };\n\n  TargetIdGenerator.forSyncEngine = function () {\n    return new TargetIdGenerator(GeneratorIds.SyncEngine);\n  };\n\n  return TargetIdGenerator;\n}();\n\nexport { TargetIdGenerator };","map":{"version":3,"sources":["../src/core/target_id_generator.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAIH,IAAM,aAAa,GAAG,CAAtB;AAEA,IAAK,YAAL;;AAAA,CAAA,UAAK,YAAL,EAAiB;AACf,EAAA,YAAA,CAAA,YAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAA,YAAA,CAAA,YAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACD,CAHD,EAAK,YAAY,KAAZ,YAAY,GAAA,EAAA,CAAjB;AAKA;;;;;;AAMG;;;AACH,IAAA,iBAAA;AAAA;AAAA,YAAA;AAGE,WAAA,iBAAA,CAAoB,WAApB,EAAyC,SAAzC,EAAgE;AAAvB,QAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,SAAA,GAAA,CAAA;AAAuB;;AAA5C,SAAA,WAAA,GAAA,WAAA,CAA4C,CAC9D;;AACA,QAAM,qBAAqB,GAAI,SAAS,IAAI,aAAd,IAAgC,aAA9D;AACA,QAAM,cAAc,GAAG,SAAS,GAAG,qBAAnC;;AACA,QAAI,cAAc,IAAI,WAAtB,EAAmC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAK,UAAL,GAAkB,qBAAqB,GAAG,KAAK,WAA/C;AACD,KATD,MASO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAK,UAAL,GACE,CAAC,qBAAqB,GAAG,KAAK,WAA9B,KAA8C,KAAK,aAAnD,CADF;AAED;AACF;;AAED,EAAA,iBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,SAAK,UAAL,IAAmB,KAAK,aAAxB;AACA,WAAO,KAAK,UAAZ;AACD,GAHD;;AAKO,EAAA,iBAAA,CAAA,aAAA,GAAP,UAAqB,SAArB,EAA4C;AAAvB,QAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,SAAA,GAAA,CAAA;AAAuB;;AAC1C,WAAO,IAAI,iBAAJ,CAAsB,YAAY,CAAC,UAAnC,EAA+C,SAA/C,CAAP;AACD,GAFM;;AAIA,EAAA,iBAAA,CAAA,aAAA,GAAP,YAAA;AACE,WAAO,IAAI,iBAAJ,CAAsB,YAAY,CAAC,UAAnC,CAAP;AACD,GAFM;;AAGT,SAAA,iBAAA;AAAC,CAzCD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TargetId } from './types';\n\nconst RESERVED_BITS = 1;\n\nenum GeneratorIds {\n  LocalStore = 0,\n  SyncEngine = 1\n}\n\n/**\n * TargetIdGenerator generates monotonically increasing integer IDs. There are\n * separate generators for different scopes. While these generators will operate\n * independently of each other, they are scoped, such that no two generators\n * will ever produce the same ID. This is useful, because sometimes the backend\n * may group IDs from separate parts of the client into the same ID space.\n */\nexport class TargetIdGenerator {\n  private previousId: TargetId;\n\n  constructor(private generatorId: number, initAfter: TargetId = 0) {\n    // Replace the generator part of initAfter with this generator's ID.\n    const afterWithoutGenerator = (initAfter >> RESERVED_BITS) << RESERVED_BITS;\n    const afterGenerator = initAfter - afterWithoutGenerator;\n    if (afterGenerator >= generatorId) {\n      // For example, if:\n      //   this.generatorId = 0b0000\n      //   after = 0b1011\n      //   afterGenerator = 0b0001\n      // Then:\n      //   previous = 0b1010\n      //   next = 0b1100\n      this.previousId = afterWithoutGenerator | this.generatorId;\n    } else {\n      // For example, if:\n      //   this.generatorId = 0b0001\n      //   after = 0b1010\n      //   afterGenerator = 0b0000\n      // Then:\n      //   previous = 0b1001\n      //   next = 0b1011\n      this.previousId =\n        (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);\n    }\n  }\n\n  next(): TargetId {\n    this.previousId += 1 << RESERVED_BITS;\n    return this.previousId;\n  }\n\n  static forLocalStore(initAfter: TargetId = 0): TargetIdGenerator {\n    return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);\n  }\n\n  static forSyncEngine(): TargetIdGenerator {\n    return new TargetIdGenerator(GeneratorIds.SyncEngine);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}