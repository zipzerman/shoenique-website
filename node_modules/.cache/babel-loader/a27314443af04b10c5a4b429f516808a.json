{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n\nvar OAuthToken =\n/** @class */\nfunction () {\n  function OAuthToken(value, user) {\n    this.user = user;\n    this.type = 'OAuth';\n    this.authHeaders = {\n      Authorization: \"Bearer \" + value\n    };\n  }\n\n  return OAuthToken;\n}();\n\nexport { OAuthToken };\n/** A CredentialsProvider that always yields an empty token. */\n\nvar EmptyCredentialsProvider =\n/** @class */\nfunction () {\n  function EmptyCredentialsProvider() {\n    /**\n     * Stores the User listener registered with setUserChangeListener()\n     * This isn't actually necessary since the UID never changes, but we use this\n     * to verify the listen contract is adhered to in tests.\n     */\n    this.userListener = null;\n  }\n\n  EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n    return Promise.resolve(null);\n  };\n\n  EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener; // Fire with initial user.\n\n    listener(User.UNAUTHENTICATED);\n  };\n\n  EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\n    assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\n    this.userListener = null;\n  };\n\n  return EmptyCredentialsProvider;\n}();\n\nexport { EmptyCredentialsProvider };\n\nvar FirebaseCredentialsProvider =\n/** @class */\nfunction () {\n  function FirebaseCredentialsProvider(app) {\n    var _this = this;\n\n    this.app = app;\n    /**\n     * The auth token listener registered with FirebaseApp, retained here so we\n     * can unregister it.\n     */\n\n    this.tokenListener = null;\n    /**\n     * Counter used to detect if the user changed while a getToken request was\n     * outstanding.\n     */\n\n    this.userCounter = 0;\n    /** The User listener registered with setUserChangeListener(). */\n\n    this.userListener = null; // We listen for token changes but all we really care about is knowing when\n    // the uid may have changed.\n\n    this.tokenListener = function () {\n      var newUser = _this.getUser();\n\n      if (!_this.currentUser || !newUser.equals(_this.currentUser)) {\n        _this.currentUser = newUser;\n        _this.userCounter++;\n\n        if (_this.userListener) {\n          _this.userListener(_this.currentUser);\n        }\n      }\n    };\n\n    this.userCounter = 0; // Will fire at least once where we set this.currentUser\n\n    this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n  }\n\n  FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\n    var _this = this;\n\n    assert(this.tokenListener != null, 'getToken cannot be called after listener removed.'); // Take note of the current value of the userCounter so that this method can\n    // fail (with an ABORTED error) if there is a user change while the request\n    // is outstanding.\n\n    var initialUserCounter = this.userCounter;\n    return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\n      // Cancel the request since the user changed while the request was\n      // outstanding so the response is likely for a previous user (which\n      // user, we can't be sure).\n      if (_this.userCounter !== initialUserCounter) {\n        throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\n      } else {\n        if (tokenData) {\n          assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\n          return new OAuthToken(tokenData.accessToken, _this.currentUser);\n        } else {\n          return null;\n        }\n      }\n    });\n  };\n\n  FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener; // Fire the initial event, but only if we received the initial user\n\n    if (this.currentUser) {\n      listener(this.currentUser);\n    }\n  };\n\n  FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\n    assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\n    assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\n    this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\n    this.tokenListener = null;\n    this.userListener = null;\n  };\n\n  FirebaseCredentialsProvider.prototype.getUser = function () {\n    // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n    if (typeof this.app.INTERNAL.getUid !== 'function') {\n      fail('This version of the Firestore SDK requires at least version' + ' 3.7.0 of firebase.js.');\n    }\n\n    var currentUid = this.app.INTERNAL.getUid();\n    assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\n    return new User(currentUid);\n  };\n\n  return FirebaseCredentialsProvider;\n}();\n\nexport { FirebaseCredentialsProvider };\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\n\nvar FirstPartyToken =\n/** @class */\nfunction () {\n  function FirstPartyToken(gapi, sessionIndex) {\n    this.gapi = gapi;\n    this.sessionIndex = sessionIndex;\n    this.type = 'FirstParty';\n    this.user = User.FIRST_PARTY;\n    assert(this.gapi && this.gapi['auth'] && this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n  }\n\n  Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\n    get: function get() {\n      return {\n        Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n        'X-Goog-AuthUser': this.sessionIndex\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FirstPartyToken;\n}();\n\nexport { FirstPartyToken };\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\n\nvar FirstPartyCredentialsProvider =\n/** @class */\nfunction () {\n  function FirstPartyCredentialsProvider(gapi, sessionIndex) {\n    this.gapi = gapi;\n    this.sessionIndex = sessionIndex;\n    assert(this.gapi && this.gapi['auth'] && this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n  }\n\n  FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n    return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n  }; // TODO(33108925): can someone switch users w/o a page refresh?\n  // TODO(33110621): need to understand token/session lifecycle\n\n\n  FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n    // Fire with initial uid.\n    listener(User.FIRST_PARTY);\n  };\n\n  FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () {};\n\n  return FirstPartyCredentialsProvider;\n}();\n\nexport { FirstPartyCredentialsProvider };\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\n\nexport function makeCredentialsProvider(credentials) {\n  if (!credentials) {\n    return new EmptyCredentialsProvider();\n  }\n\n  switch (credentials.type) {\n    case 'gapi':\n      return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\n\n    case 'provider':\n      return credentials.client;\n\n    default:\n      throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\n  }\n}","map":{"version":3,"sources":["../src/api/credentials.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { AnyJs } from '../util/misc';\nimport { FirebaseApp } from '@firebase/app';\n\n// TODO(mikelehen): This should be split into multiple files and probably\n// moved to an auth/ folder to match other platforms.\n\nexport interface FirstPartyCredentialsSettings {\n  type: 'gapi';\n  client: Gapi;\n  sessionIndex: string;\n}\n\nexport interface ProviderCredentialsSettings {\n  type: 'provider';\n  client: CredentialsProvider;\n}\n\n/** Settings for private credentials */\nexport type CredentialsSettings =\n  | FirstPartyCredentialsSettings\n  | ProviderCredentialsSettings;\n\nexport type TokenType = 'OAuth' | 'FirstParty';\nexport interface Token {\n  /** Type of token. */\n  type: TokenType;\n\n  /**\n   * The user with which the token is associated (used for persisting user\n   * state on disk, etc.).\n   */\n  user: User;\n\n  /** Extra header values to be passed along with a request */\n  authHeaders: { [header: string]: string };\n}\n\nexport class OAuthToken implements Token {\n  type = 'OAuth' as TokenType;\n  authHeaders: { [header: string]: string };\n  constructor(value: string, public user: User) {\n    this.authHeaders = { Authorization: `Bearer ${value}` };\n  }\n}\n\n/**\n * A Listener for user change events.\n */\nexport type UserListener = (user: User) => void;\n\n/**\n * Provides methods for getting the uid and token for the current user and\n * listening for changes.\n */\nexport interface CredentialsProvider {\n  /**\n   * Requests a token for the current user, optionally forcing a refreshed\n   * token to be fetched.\n   */\n  getToken(forceRefresh: boolean): Promise<Token | null>;\n\n  /**\n   * Specifies a listener to be notified of user changes (sign-in / sign-out).\n   * It immediately called once with the initial user.\n   */\n  setUserChangeListener(listener: UserListener): void;\n\n  /** Removes the previously-set user change listener. */\n  removeUserChangeListener(): void;\n}\n\n/** A CredentialsProvider that always yields an empty token. */\nexport class EmptyCredentialsProvider implements CredentialsProvider {\n  /**\n   * Stores the User listener registered with setUserChangeListener()\n   * This isn't actually necessary since the UID never changes, but we use this\n   * to verify the listen contract is adhered to in tests.\n   */\n  private userListener: UserListener | null = null;\n\n  constructor() {}\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return Promise.resolve<Token | null>(null);\n  }\n\n  setUserChangeListener(listener: UserListener): void {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener;\n    // Fire with initial user.\n    listener(User.UNAUTHENTICATED);\n  }\n\n  removeUserChangeListener(): void {\n    assert(\n      this.userListener !== null,\n      'removeUserChangeListener() when no listener registered'\n    );\n    this.userListener = null;\n  }\n}\n\nexport class FirebaseCredentialsProvider implements CredentialsProvider {\n  /**\n   * The auth token listener registered with FirebaseApp, retained here so we\n   * can unregister it.\n   */\n  private tokenListener: ((token: string | null) => void) | null = null;\n\n  /** Tracks the current User. */\n  private currentUser: User;\n\n  /**\n   * Counter used to detect if the user changed while a getToken request was\n   * outstanding.\n   */\n  private userCounter = 0;\n\n  /** The User listener registered with setUserChangeListener(). */\n  private userListener: UserListener | null = null;\n\n  constructor(private readonly app: FirebaseApp) {\n    // We listen for token changes but all we really care about is knowing when\n    // the uid may have changed.\n    this.tokenListener = () => {\n      const newUser = this.getUser();\n      if (!this.currentUser || !newUser.equals(this.currentUser)) {\n        this.currentUser = newUser;\n        this.userCounter++;\n        if (this.userListener) {\n          this.userListener(this.currentUser);\n        }\n      }\n    };\n\n    this.userCounter = 0;\n\n    // Will fire at least once where we set this.currentUser\n    this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n  }\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    assert(\n      this.tokenListener != null,\n      'getToken cannot be called after listener removed.'\n    );\n\n    // Take note of the current value of the userCounter so that this method can\n    // fail (with an ABORTED error) if there is a user change while the request\n    // is outstanding.\n    const initialUserCounter = this.userCounter;\n    return this.app.INTERNAL.getToken(forceRefresh).then(tokenData => {\n      // Cancel the request since the user changed while the request was\n      // outstanding so the response is likely for a previous user (which\n      // user, we can't be sure).\n      if (this.userCounter !== initialUserCounter) {\n        throw new FirestoreError(\n          Code.ABORTED,\n          'getToken aborted due to uid change.'\n        );\n      } else {\n        if (tokenData) {\n          assert(\n            typeof tokenData.accessToken === 'string',\n            'Invalid tokenData returned from getToken():' + tokenData\n          );\n          return new OAuthToken(tokenData.accessToken, this.currentUser);\n        } else {\n          return null;\n        }\n      }\n    });\n  }\n\n  setUserChangeListener(listener: UserListener): void {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener;\n\n    // Fire the initial event, but only if we received the initial user\n    if (this.currentUser) {\n      listener(this.currentUser);\n    }\n  }\n\n  removeUserChangeListener(): void {\n    assert(\n      this.tokenListener != null,\n      'removeUserChangeListener() called twice'\n    );\n    assert(\n      this.userListener !== null,\n      'removeUserChangeListener() called when no listener registered'\n    );\n    this.app.INTERNAL.removeAuthTokenListener(this.tokenListener!);\n    this.tokenListener = null;\n    this.userListener = null;\n  }\n\n  private getUser(): User {\n    // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n    if (typeof this.app.INTERNAL.getUid !== 'function') {\n      fail(\n        'This version of the Firestore SDK requires at least version' +\n          ' 3.7.0 of firebase.js.'\n      );\n    }\n    const currentUid = this.app.INTERNAL.getUid();\n    assert(\n      currentUid === null || typeof currentUid === 'string',\n      'Received invalid UID: ' + currentUid\n    );\n    return new User(currentUid);\n  }\n}\n\n// TODO(b/32935141): Ideally gapi type would be declared as an extern\n// tslint:disable-next-line:no-any\nexport type Gapi = any;\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nexport class FirstPartyToken implements Token {\n  type = 'FirstParty' as TokenType;\n  user = User.FIRST_PARTY;\n\n  constructor(private gapi: Gapi, private sessionIndex: string) {\n    assert(\n      this.gapi &&\n        this.gapi['auth'] &&\n        this.gapi['auth']['getAuthHeaderValueForFirstParty'],\n      'unexpected gapi interface'\n    );\n  }\n\n  get authHeaders(): { [header: string]: string } {\n    return {\n      Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n      'X-Goog-AuthUser': this.sessionIndex\n    };\n  }\n}\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nexport class FirstPartyCredentialsProvider implements CredentialsProvider {\n  constructor(private gapi: Gapi, private sessionIndex: string) {\n    assert(\n      this.gapi &&\n        this.gapi['auth'] &&\n        this.gapi['auth']['getAuthHeaderValueForFirstParty'],\n      'unexpected gapi interface'\n    );\n  }\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n  }\n\n  // TODO(33108925): can someone switch users w/o a page refresh?\n  // TODO(33110621): need to understand token/session lifecycle\n  setUserChangeListener(listener: UserListener): void {\n    // Fire with initial uid.\n    listener(User.FIRST_PARTY);\n  }\n\n  removeUserChangeListener(): void {}\n}\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(credentials?: CredentialsSettings) {\n  if (!credentials) {\n    return new EmptyCredentialsProvider();\n  }\n\n  switch (credentials.type) {\n    case 'gapi':\n      return new FirstPartyCredentialsProvider(\n        credentials.client,\n        credentials.sessionIndex || '0'\n      );\n\n    case 'provider':\n      return credentials.client;\n\n    default:\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'makeCredentialsProvider failed due to invalid credential type'\n      );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}