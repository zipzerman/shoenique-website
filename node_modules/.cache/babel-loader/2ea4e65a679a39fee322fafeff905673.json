{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\n\nvar ReferenceSet =\n/** @class */\nfunction () {\n  function ReferenceSet() {\n    // A set of outstanding references to a document sorted by key.\n    this.refsByKey = new SortedSet(DocReference.compareByKey); // A set of outstanding references to a document sorted by target id.\n\n    this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n    /** Keeps track of keys that have references */\n\n    this.garbageCollector = null;\n  }\n  /** Returns true if the reference set contains no references. */\n\n\n  ReferenceSet.prototype.isEmpty = function () {\n    return this.refsByKey.isEmpty();\n  };\n  /** Adds a reference to the given document key for the given ID. */\n\n\n  ReferenceSet.prototype.addReference = function (key, id) {\n    var ref = new DocReference(key, id);\n    this.refsByKey = this.refsByKey.add(ref);\n    this.refsByTarget = this.refsByTarget.add(ref);\n  };\n  /** Add references to the given document keys for the given ID. */\n\n\n  ReferenceSet.prototype.addReferences = function (keys, id) {\n    var _this = this;\n\n    keys.forEach(function (key) {\n      return _this.addReference(key, id);\n    });\n  };\n  /**\n   * Removes a reference to the given document key for the given\n   * ID.\n   */\n\n\n  ReferenceSet.prototype.removeReference = function (key, id) {\n    this.removeRef(new DocReference(key, id));\n  };\n\n  ReferenceSet.prototype.removeReferences = function (keys, id) {\n    var _this = this;\n\n    keys.forEach(function (key) {\n      return _this.removeReference(key, id);\n    });\n  };\n  /**\n   * Clears all references with a given ID. Calls removeRef() for each key\n   * removed.\n   */\n\n\n  ReferenceSet.prototype.removeReferencesForId = function (id) {\n    var _this = this;\n\n    var emptyKey = DocumentKey.EMPTY;\n    var startRef = new DocReference(emptyKey, id);\n    var endRef = new DocReference(emptyKey, id + 1);\n    this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n      _this.removeRef(ref);\n    });\n  };\n\n  ReferenceSet.prototype.removeAllReferences = function () {\n    var _this = this;\n\n    this.refsByKey.forEach(function (ref) {\n      return _this.removeRef(ref);\n    });\n  };\n\n  ReferenceSet.prototype.removeRef = function (ref) {\n    this.refsByKey = this.refsByKey.delete(ref);\n    this.refsByTarget = this.refsByTarget.delete(ref);\n\n    if (this.garbageCollector !== null) {\n      this.garbageCollector.addPotentialGarbageKey(ref.key);\n    }\n  };\n\n  ReferenceSet.prototype.referencesForId = function (id) {\n    var emptyKey = DocumentKey.EMPTY;\n    var startRef = new DocReference(emptyKey, id);\n    var endRef = new DocReference(emptyKey, id + 1);\n    var keys = documentKeySet();\n    this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n      keys = keys.add(ref.key);\n    });\n    return keys;\n  };\n\n  ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {\n    this.garbageCollector = garbageCollector;\n  };\n\n  ReferenceSet.prototype.containsKey = function (txn, key) {\n    var ref = new DocReference(key, 0);\n    var firstRef = this.refsByKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(firstRef !== null && key.equals(firstRef.key));\n  };\n\n  return ReferenceSet;\n}();\n\nexport { ReferenceSet };\n\nvar DocReference =\n/** @class */\nfunction () {\n  function DocReference(key, targetOrBatchId) {\n    this.key = key;\n    this.targetOrBatchId = targetOrBatchId;\n  }\n  /** Compare by key then by ID */\n\n\n  DocReference.compareByKey = function (left, right) {\n    return DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);\n  };\n  /** Compare by ID then by key */\n\n\n  DocReference.compareByTargetId = function (left, right) {\n    return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || DocumentKey.comparator(left.key, right.key);\n  };\n\n  return DocReference;\n}();\n\nexport { DocReference };","map":{"version":3,"sources":["../src/local/reference_set.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchId, TargetId } from '../core/types';\nimport { documentKeySet, DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { GarbageSource } from './garbage_source';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nexport class ReferenceSet implements GarbageSource {\n  // A set of outstanding references to a document sorted by key.\n  private refsByKey = new SortedSet(DocReference.compareByKey);\n\n  // A set of outstanding references to a document sorted by target id.\n  private refsByTarget = new SortedSet(DocReference.compareByTargetId);\n\n  /** Keeps track of keys that have references */\n  private garbageCollector: GarbageCollector | null = null;\n\n  /** Returns true if the reference set contains no references. */\n  isEmpty(): boolean {\n    return this.refsByKey.isEmpty();\n  }\n\n  /** Adds a reference to the given document key for the given ID. */\n  addReference(key: DocumentKey, id: TargetId | BatchId): void {\n    const ref = new DocReference(key, id);\n    this.refsByKey = this.refsByKey.add(ref);\n    this.refsByTarget = this.refsByTarget.add(ref);\n  }\n\n  /** Add references to the given document keys for the given ID. */\n  addReferences(keys: DocumentKeySet, id: TargetId | BatchId): void {\n    keys.forEach(key => this.addReference(key, id));\n  }\n\n  /**\n   * Removes a reference to the given document key for the given\n   * ID.\n   */\n  removeReference(key: DocumentKey, id: TargetId | BatchId): void {\n    this.removeRef(new DocReference(key, id));\n  }\n\n  removeReferences(keys: DocumentKeySet, id: TargetId | BatchId): void {\n    keys.forEach(key => this.removeReference(key, id));\n  }\n\n  /**\n   * Clears all references with a given ID. Calls removeRef() for each key\n   * removed.\n   */\n  removeReferencesForId(id: TargetId | BatchId): void {\n    const emptyKey = DocumentKey.EMPTY;\n    const startRef = new DocReference(emptyKey, id);\n    const endRef = new DocReference(emptyKey, id + 1);\n    this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n      this.removeRef(ref);\n    });\n  }\n\n  removeAllReferences(): void {\n    this.refsByKey.forEach(ref => this.removeRef(ref));\n  }\n\n  private removeRef(ref: DocReference): void {\n    this.refsByKey = this.refsByKey.delete(ref);\n    this.refsByTarget = this.refsByTarget.delete(ref);\n    if (this.garbageCollector !== null) {\n      this.garbageCollector.addPotentialGarbageKey(ref.key);\n    }\n  }\n\n  referencesForId(id: TargetId | BatchId): DocumentKeySet {\n    const emptyKey = DocumentKey.EMPTY;\n    const startRef = new DocReference(emptyKey, id);\n    const endRef = new DocReference(emptyKey, id + 1);\n    let keys = documentKeySet();\n    this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n      keys = keys.add(ref.key);\n    });\n    return keys;\n  }\n\n  setGarbageCollector(garbageCollector: GarbageCollector | null): void {\n    this.garbageCollector = garbageCollector;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(\n      firstRef !== null && key.equals(firstRef.key)\n    );\n  }\n}\n\nexport class DocReference {\n  constructor(\n    public key: DocumentKey,\n    public targetOrBatchId: TargetId | BatchId\n  ) {}\n\n  /** Compare by key then by ID */\n  static compareByKey(left: DocReference, right: DocReference): number {\n    return (\n      DocumentKey.comparator(left.key, right.key) ||\n      primitiveComparator(left.targetOrBatchId, right.targetOrBatchId)\n    );\n  }\n\n  /** Compare by ID then by key */\n  static compareByTargetId(left: DocReference, right: DocReference): number {\n    return (\n      primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n      DocumentKey.comparator(left.key, right.key)\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}