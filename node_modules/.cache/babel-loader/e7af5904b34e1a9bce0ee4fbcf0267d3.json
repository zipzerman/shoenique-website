{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nimport { documentMap } from './collections';\nimport { DocumentKey } from './document_key';\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\n\nvar DocumentSet =\n/** @class */\nfunction () {\n  /** The default ordering is by key if the comparator is omitted */\n  function DocumentSet(comp) {\n    // We are adding document key comparator to the end as it's the only\n    // guaranteed unique property of a document.\n    if (comp) {\n      this.comparator = function (d1, d2) {\n        return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n      };\n    } else {\n      this.comparator = function (d1, d2) {\n        return DocumentKey.comparator(d1.key, d2.key);\n      };\n    }\n\n    this.keyedMap = documentMap();\n    this.sortedSet = new SortedMap(this.comparator);\n  }\n  /**\n   * Returns an empty copy of the existing DocumentSet, using the same\n   * comparator.\n   */\n\n\n  DocumentSet.emptySet = function (oldSet) {\n    return new DocumentSet(oldSet.comparator);\n  };\n\n  DocumentSet.prototype.has = function (key) {\n    return this.keyedMap.get(key) != null;\n  };\n\n  DocumentSet.prototype.get = function (key) {\n    return this.keyedMap.get(key);\n  };\n\n  DocumentSet.prototype.first = function () {\n    return this.sortedSet.minKey();\n  };\n\n  DocumentSet.prototype.last = function () {\n    return this.sortedSet.maxKey();\n  };\n\n  DocumentSet.prototype.isEmpty = function () {\n    return this.sortedSet.isEmpty();\n  };\n  /**\n   * Returns previous document or null if it's a first doc.\n   *\n   * @param key A key that MUST be present in the DocumentSet.\n   */\n\n\n  DocumentSet.prototype.prevDoc = function (key) {\n    assert(this.has(key), 'Trying to get a previous document to non-existing key: ' + key);\n    var doc = this.keyedMap.get(key);\n    return this.sortedSet.getPredecessorKey(doc);\n  };\n  /**\n   * Returns the index of the provided key in the document set, or -1 if the\n   * document key is not present in the set;\n   */\n\n\n  DocumentSet.prototype.indexOf = function (key) {\n    var doc = this.keyedMap.get(key);\n    return doc ? this.sortedSet.indexOf(doc) : -1;\n  };\n\n  Object.defineProperty(DocumentSet.prototype, \"size\", {\n    get: function get() {\n      return this.sortedSet.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Iterates documents in order defined by \"comparator\" */\n\n  DocumentSet.prototype.forEach = function (cb) {\n    this.sortedSet.inorderTraversal(function (k, v) {\n      cb(k);\n      return false;\n    });\n  };\n  /** Inserts or updates a document with the same key */\n\n\n  DocumentSet.prototype.add = function (doc) {\n    // First remove the element if we have it.\n    var set = this.delete(doc.key);\n    return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n  };\n  /** Deletes a document with a given key */\n\n\n  DocumentSet.prototype.delete = function (key) {\n    var doc = this.get(key);\n\n    if (!doc) {\n      return this;\n    }\n\n    return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n  };\n\n  DocumentSet.prototype.equals = function (other) {\n    if (!(other instanceof DocumentSet)) return false;\n    if (this.size !== other.size) return false;\n    var thisIt = this.sortedSet.getIterator();\n    var otherIt = other.sortedSet.getIterator();\n\n    while (thisIt.hasNext()) {\n      var thisDoc = thisIt.getNext().key;\n      var otherDoc = otherIt.getNext().key;\n      if (!thisDoc.equals(otherDoc)) return false;\n    }\n\n    return true;\n  };\n\n  DocumentSet.prototype.toString = function () {\n    var docStrings = [];\n    this.forEach(function (doc) {\n      docStrings.push(doc.toString());\n    });\n\n    if (docStrings.length === 0) {\n      return 'DocumentSet ()';\n    } else {\n      return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n    }\n  };\n\n  DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n    var newSet = new DocumentSet();\n    newSet.comparator = this.comparator;\n    newSet.keyedMap = keyedMap;\n    newSet.sortedSet = sortedSet;\n    return newSet;\n  };\n\n  return DocumentSet;\n}();\n\nexport { DocumentSet };","map":{"version":3,"sources":["../src/model/document_set.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\n\nimport { documentMap } from './collections';\nimport { Document } from './document';\nimport { DocumentComparator } from './document_comparator';\nimport { DocumentKey } from './document_key';\n\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\n\nexport class DocumentSet {\n  /**\n   * Returns an empty copy of the existing DocumentSet, using the same\n   * comparator.\n   */\n  static emptySet(oldSet: DocumentSet): DocumentSet {\n    return new DocumentSet(oldSet.comparator);\n  }\n\n  private comparator: DocumentComparator;\n  private keyedMap: SortedMap<DocumentKey, Document>;\n  private sortedSet: SortedMap<Document, null>;\n\n  /** The default ordering is by key if the comparator is omitted */\n  constructor(comp?: DocumentComparator) {\n    // We are adding document key comparator to the end as it's the only\n    // guaranteed unique property of a document.\n    if (comp) {\n      this.comparator = (d1: Document, d2: Document) =>\n        comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n    } else {\n      this.comparator = (d1: Document, d2: Document) =>\n        DocumentKey.comparator(d1.key, d2.key);\n    }\n\n    this.keyedMap = documentMap();\n    this.sortedSet = new SortedMap<Document, null>(this.comparator);\n  }\n\n  has(key: DocumentKey): boolean {\n    return this.keyedMap.get(key) != null;\n  }\n\n  get(key: DocumentKey): Document | null {\n    return this.keyedMap.get(key);\n  }\n\n  first(): Document | null {\n    return this.sortedSet.minKey();\n  }\n\n  last(): Document | null {\n    return this.sortedSet.maxKey();\n  }\n\n  isEmpty(): boolean {\n    return this.sortedSet.isEmpty();\n  }\n\n  /**\n   * Returns previous document or null if it's a first doc.\n   *\n   * @param key A key that MUST be present in the DocumentSet.\n   */\n  prevDoc(key: DocumentKey): Document | null {\n    assert(\n      this.has(key),\n      'Trying to get a previous document to non-existing key: ' + key\n    );\n    const doc = this.keyedMap.get(key);\n    return this.sortedSet.getPredecessorKey(doc!);\n  }\n\n  /**\n   * Returns the index of the provided key in the document set, or -1 if the\n   * document key is not present in the set;\n   */\n  indexOf(key: DocumentKey): number {\n    const doc = this.keyedMap.get(key);\n    return doc ? this.sortedSet.indexOf(doc) : -1;\n  }\n\n  get size(): number {\n    return this.sortedSet.size;\n  }\n\n  /** Iterates documents in order defined by \"comparator\" */\n  forEach(cb: (doc: Document) => void): void {\n    this.sortedSet.inorderTraversal((k, v) => {\n      cb(k);\n      return false;\n    });\n  }\n\n  /** Inserts or updates a document with the same key */\n  add(doc: Document): DocumentSet {\n    // First remove the element if we have it.\n    const set = this.delete(doc.key);\n    return set.copy(\n      set.keyedMap.insert(doc.key, doc),\n      set.sortedSet.insert(doc, null)\n    );\n  }\n\n  /** Deletes a document with a given key */\n  delete(key: DocumentKey): DocumentSet {\n    const doc = this.get(key);\n    if (!doc) {\n      return this;\n    }\n\n    return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n  }\n\n  equals(other: DocumentSet | null | undefined): boolean {\n    if (!(other instanceof DocumentSet)) return false;\n    if (this.size !== other.size) return false;\n\n    const thisIt = this.sortedSet.getIterator();\n    const otherIt = other.sortedSet.getIterator();\n    while (thisIt.hasNext()) {\n      const thisDoc = thisIt.getNext().key;\n      const otherDoc = otherIt.getNext().key;\n      if (!thisDoc.equals(otherDoc)) return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    const docStrings: string[] = [];\n    this.forEach(doc => {\n      docStrings.push(doc.toString());\n    });\n    if (docStrings.length === 0) {\n      return 'DocumentSet ()';\n    } else {\n      return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n    }\n  }\n\n  private copy(\n    keyedMap: SortedMap<DocumentKey, Document>,\n    sortedSet: SortedMap<Document, null>\n  ): DocumentSet {\n    const newSet = new DocumentSet();\n    newSet.comparator = this.comparator;\n    newSet.keyedMap = keyedMap;\n    newSet.sortedSet = sortedSet;\n    return newSet;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}