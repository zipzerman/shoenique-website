var valtio = (function (exports, react, proxyCompare, useSubscription) {
  'use strict';

  /*
  export {
    unstable_createMutableSource as createMutableSource,
    unstable_useMutableSource as useMutableSource,
  } from 'react'
  */
  var TARGET = Symbol();
  var GET_VERSION = Symbol();
  var createMutableSource = function createMutableSource(target, getVersion) {
    var _ref;

    return _ref = {}, _ref[TARGET] = target, _ref[GET_VERSION] = getVersion, _ref;
  };
  var useMutableSource = function useMutableSource(source, getSnapshot, subscribe) {
    var lastVersion = react.useRef(0);
    var versionDiff = source[GET_VERSION](source[TARGET]) - lastVersion.current; // eslint-disable-next-line react-hooks/exhaustive-deps

    var getCurrentValue = react.useCallback(function () {
      return getSnapshot(source[TARGET]);
    }, [source, getSnapshot, versionDiff]);
    var sub = react.useCallback(function (callback) {
      return subscribe(source[TARGET], function () {
        lastVersion.current = source[GET_VERSION](source[TARGET]);
        callback();
      });
    }, [source, subscribe]);
    react.useEffect(function () {
      lastVersion.current = source[GET_VERSION](source[TARGET]);
    });
    return useSubscription.useSubscription({
      getCurrentValue: getCurrentValue,
      subscribe: sub
    });
  };

  var VERSION = Symbol();
  var LISTENERS = Symbol();
  var SNAPSHOT = Symbol();
  var PROMISE_RESULT = Symbol();
  var PROMISE_ERROR = Symbol();

  var isSupportedObject = function isSupportedObject(x) {
    return typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);
  };

  var proxyCache = new WeakMap();
  var globalVersion = 1;
  var snapshotCache = new WeakMap();
  var proxy = function proxy(initialObject) {
    if (initialObject === void 0) {
      initialObject = {};
    }

    if (!isSupportedObject(initialObject)) {
      throw new Error('unsupported object type');
    }

    if (proxyCache.has(initialObject)) {
      return proxyCache.get(initialObject);
    }

    var version = globalVersion;
    var listeners = new Set();

    var notifyUpdate = function notifyUpdate(nextVersion) {
      if (!nextVersion) {
        nextVersion = ++globalVersion;
      }

      if (version !== nextVersion) {
        version = nextVersion;
        listeners.forEach(function (listener) {
          return listener(nextVersion);
        });
      }
    };

    var baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
    var p = new Proxy(baseObject, {
      get: function get(target, prop, receiver) {
        if (prop === VERSION) {
          return version;
        }

        if (prop === LISTENERS) {
          return listeners;
        }

        if (prop === SNAPSHOT) {
          var cache = snapshotCache.get(receiver);

          if (cache && cache.version === version) {
            return cache.snapshot;
          }

          var _snapshot = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));

          proxyCompare.markToTrack(_snapshot);
          snapshotCache.set(receiver, {
            version: version,
            snapshot: _snapshot
          });
          Reflect.ownKeys(target).forEach(function (key) {
            var value = target[key];

            if (!isSupportedObject(value)) {
              _snapshot[key] = value;
            } else if (value instanceof Promise) {
              if (value[PROMISE_RESULT]) {
                _snapshot[key] = value[PROMISE_RESULT];
              } else {
                var errorOrPromise = value[PROMISE_ERROR] || value;
                Object.defineProperty(_snapshot, key, {
                  get: function get() {
                    throw errorOrPromise;
                  }
                });
              }
            } else if (value[VERSION]) {
              _snapshot[key] = value[SNAPSHOT];
            } else {
              _snapshot[key] = value;
            }
          });

          if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {
            Object.freeze(_snapshot);
          }

          return _snapshot;
        }

        return target[prop];
      },
      deleteProperty: function deleteProperty(target, prop) {
        var prevValue = target[prop];
        var childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];

        if (childListeners) {
          childListeners.delete(notifyUpdate);
        }

        var deleted = Reflect.deleteProperty(target, prop);

        if (deleted) {
          notifyUpdate();
        }

        return deleted;
      },
      set: function set(target, prop, value) {
        var prevValue = target[prop];

        if (Object.is(prevValue, value)) {
          return true;
        }

        var childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];

        if (childListeners) {
          childListeners.delete(notifyUpdate);
        }

        if (!isSupportedObject(value)) {
          target[prop] = value;
        } else if (value instanceof Promise) {
          target[prop] = value.then(function (v) {
            target[prop][PROMISE_RESULT] = v;
            notifyUpdate();
          }).catch(function (e) {
            target[prop][PROMISE_ERROR] = e;
            notifyUpdate();
          });
        } else {
          value = proxyCompare.getUntrackedObject(value) || value;

          if (value[LISTENERS]) {
            target[prop] = value;
          } else {
            target[prop] = proxy(value);
          }

          target[prop][LISTENERS].add(notifyUpdate);
        }

        notifyUpdate();
        return true;
      }
    });
    proxyCache.set(initialObject, p);
    Reflect.ownKeys(initialObject).forEach(function (key) {
      var desc = Object.getOwnPropertyDescriptor(initialObject, key);

      if (desc.get) {
        Object.defineProperty(baseObject, key, desc);
      } else {
        p[key] = initialObject[key];
      }
    });
    return p;
  };
  var getVersion = function getVersion(p) {
    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[VERSION])) {
      throw new Error('Please use proxy object');
    }

    return p[VERSION];
  };
  var subscribe = function subscribe(p, callback, notifyInSync) {
    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[LISTENERS])) {
      throw new Error('Please use proxy object');
    }

    var pendingVersion = 0;

    var listener = function listener(nextVersion) {
      if (notifyInSync) {
        callback();
        return;
      }

      pendingVersion = nextVersion;
      Promise.resolve().then(function () {
        if (nextVersion === pendingVersion) {
          callback();
        }
      });
    };

    p[LISTENERS].add(listener);
    return function () {
      p[LISTENERS].delete(listener);
    };
  };
  var snapshot = function snapshot(p) {
    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[SNAPSHOT])) {
      throw new Error('Please use proxy object');
    }

    return p[SNAPSHOT];
  };

  var isSSR = typeof window === 'undefined' || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);
  var useIsomorphicLayoutEffect = isSSR ? react.useEffect : react.useLayoutEffect;
  var mutableSourceCache = new WeakMap();

  var getMutableSource = function getMutableSource(p) {
    if (!mutableSourceCache.has(p)) {
      mutableSourceCache.set(p, createMutableSource(p, getVersion));
    }

    return mutableSourceCache.get(p);
  };

  var useProxy = function useProxy(p, options) {
    var _useReducer = react.useReducer(function (c) {
      return c + 1;
    }, 0),
        forceUpdate = _useReducer[1];

    var affected = new WeakMap();
    var lastAffected = react.useRef();
    var prevSnapshot = react.useRef();
    var lastSnapshot = react.useRef();
    useIsomorphicLayoutEffect(function () {
      lastAffected.current = affected;

      if (prevSnapshot.current !== lastSnapshot.current && proxyCompare.isDeepChanged(prevSnapshot.current, lastSnapshot.current, affected, new WeakMap())) {
        prevSnapshot.current = lastSnapshot.current;
        forceUpdate();
      }
    });
    var getSnapshot = react.useMemo(function () {
      var deepChangedCache = new WeakMap();
      return function (p) {
        var nextSnapshot = snapshot(p);
        lastSnapshot.current = nextSnapshot;

        try {
          if (prevSnapshot && lastAffected.current && !proxyCompare.isDeepChanged(prevSnapshot.current, nextSnapshot, lastAffected.current, deepChangedCache)) {
            // not changed
            return prevSnapshot.current;
          }
        } catch (e) {// ignore and return nextSnapshot
        }

        return prevSnapshot.current = nextSnapshot;
      };
    }, []);
    var notifyInSync = options == null ? void 0 : options.sync;
    var sub = react.useCallback(function (p, cb) {
      return subscribe(p, cb, notifyInSync);
    }, [notifyInSync]);
    var currSnapshot = useMutableSource(getMutableSource(p), getSnapshot, sub);
    var proxyCache = react.useMemo(function () {
      return new WeakMap();
    }, []); // per-hook proxyCache

    return proxyCompare.createDeepProxy(currSnapshot, affected, proxyCache);
  };

  exports.proxy = proxy;
  exports.snapshot = snapshot;
  exports.subscribe = subscribe;
  exports.useProxy = useProxy;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}, React, proxyCompare, useSubscription));
